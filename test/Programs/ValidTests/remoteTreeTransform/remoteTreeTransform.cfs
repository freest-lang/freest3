data Tree = Leaf | Node Int Tree Tree

transform :: forall α => Tree -> (rec x. +{LeafC: Skip, NodeC: !Int;x;x;?Int});α -> (Tree, α)
transform tree c =
  case tree of
    Leaf ->
      (Leaf, select LeafC c);
    Node x l r ->
      let c = select NodeC c in
      let c = send x c in
      let l1, c = transform[(rec x. +{LeafC: Skip, NodeC: !Int;x;x;?Int});?Int;α] l c in
      let r1, c = transform[?Int;α] r c in
      let x1, c = receive c in
      (Node x1 l1 r1, c)

treeSum :: forall α => (rec x. &{LeafC: Skip, NodeC: ?Int;x;x;!Int});α -> (Int, α)
treeSum c =
  match c with
    LeafC c -> (0, c);
    NodeC c ->
      let x, c = receive c in
      let l, c = treeSum[(rec x . &{LeafC: Skip, NodeC: ?Int;x;x;!Int});!Int;α] c in
      let r, c = treeSum[!Int;α] c in
      let c    = send (x+l+r) c in
      (x + l + r, c)

aTree :: Tree
aTree = Node 1 (Node 2 Leaf (Node 3 Leaf (Node 4 Leaf (Node 5 Leaf Leaf)))) (Node 6 Leaf (Node 7 Leaf (Node 8 Leaf Leaf)))

start :: Int
start =
  let w, r  = new (rec x. +{LeafC: Skip, NodeC: !Int;x;x;?Int}) in
  let t = fork (transform[Skip] aTree w) in
  let n, r1 = treeSum[Skip] r in
  n
  
{- This start requires a different .expect file:
   Node 7 Leaf (Node 4 Leaf Leaf)

start :: Tree
start =
  let aTree = Node 3 Leaf (Node 4 Leaf Leaf) in
  let w, r  = new (rec x . +{LeafC: Skip, NodeC: !Int;x;x;?Int}) in
  let x = fork (treeSum[Skip] r) in
    fst[Tree, Skip] (transform[Skip] aTree w)

-}
