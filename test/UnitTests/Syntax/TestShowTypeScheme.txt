-- Recursive tests
forall y :: SU => rec x :: SU . x;y

-- Forall tests

forall a :: TU => Bool
forall x :: TU => !Int
forall x :: SU => !Int;x

forall a :: TU => a
forall b :: TU => b
forall a :: TU, b :: TU => a
forall x :: TU, y :: TU => !Int;x;!Bool;y

forall beta :: TU => (rec TreeChannel :: SU . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel})->((rec TreeChannel :: SU . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel});beta)->beta

-- forall beta :: TU => (rec TreeChannel :: SU . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel}) -> (rec TreeChannel :: SU . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel};beta)->beta

-- "Associativity"

forall f :: TU => f -o f -> f

forall f :: TU => (f -o f) -> f

forall a => Skip;Skip;Skip;a

forall a :: TU, b :: TU => a -> b


-- TreeChannel

forall beta => (rec TreeChannel . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel})->(rec TreeChannel . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel});beta->beta

-- Transform

forall alpha => (rec TreeChannel . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel})->((rec TreeChannel . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel});alpha)->((rec TreeChannel . +{Leaf:Skip,Node:!Int;TreeChannel;TreeChannel}),alpha)


-- TreeSum

forall alpha => ((rec xFormChan . &{Leaf:Skip,Node:?Int;xFormChan;xFormChan;!Int});alpha) -o (Int, alpha)

-- ReceiveEval
forall alpha => (rec TermChan . &{Const:?Int,Add:TermChan;TermChan,Mult:TermChan;TermChan};!Int)->(Int, alpha)
