-- Simple types

[]
Int
Int

[]
Char
Char

[]
Bool
Bool

[]
()
()

-- Session types

[]
!Int
!Int

[]
?Char
?Char

[]
!Bool
!Bool

[]
?()
?()

[]
Skip
Skip

[]
!Int
Skip;!Int

[]
!Int
!Int;Skip

[]
!Int
Skip;!Int;Skip

[]
!Int
Skip;Skip;Skip;Skip;!Int;Skip;Skip;Skip

[]
!Int;Skip;?Int
!Int;?Int

[]
Skip;!Int
!Int;Skip

[]
!Int;Skip
Skip;!Int

[]
Skip
Skip;Skip

-- Functional and session

[]
!Int -> Bool
!Int -> Bool

[]
!Int -> ?Bool
Skip;!Int -> ?Bool

[]
!Int -> Bool
Skip;!Int -> Bool

[]
!Int -> Bool
!Int;Skip -> Bool

[]
!Int -> ?Char
!Int -> Skip;?Char

[]
!Int -> !Bool
!Int -> Skip;!Bool

[]
!Int -> Bool
!Int;Skip -> Bool

[]
!Int -> Bool
!Int;Skip -> Bool

[]
!Int -> ?Char -> Bool
!Int -> ?Char -> Bool

[]
!Char -o Bool
!Char -o Bool

[]
!Int -o Bool
(Skip;!Int) -o Bool

[]
!Int -o Bool
(Skip;!Int) -o Bool

[]
!Bool -o !Char
!Bool -o !Char;Skip

[]
!Int -o ?Bool
!Int -o ?Bool;Skip

[]
!Int -o Bool
!Int;Skip -o Bool

[]
!Int -o Bool
!Int;Skip -o Bool

[]
(!Char, Bool)
(!Char, Bool)

[]
(!Int , Bool)
(Skip;!Int , Bool)

[]
(Bool, !Char)
(Bool, Skip;!Char)

[]
(Int, ?Bool)
(Int, ?Bool;Skip)

[]
(!Int , Bool)
(!Int;Skip , Bool)

[]
+{A: !Bool, B: ?Char}
+{B: ?Char, A: !Bool}

[]
+{A: ?Bool, B: Skip;!Char}
+{B: Skip;!Char, A: ?Bool}

[]
&{A: !Bool;Skip, B: ?Char}
&{B: ?Char, A: !Bool}

[]
&{A: ?Bool, B: Skip;!Char}
&{B: Skip;!Char, A: ?Bool}

[]
+{Leaf: Skip, Node: !Int};Skip
+{Leaf: Skip;Skip, Node: !Int;Skip}

-- Monoidal laws

[]
(!Int; ?Bool); !Char
!Int; (?Bool; !Char)

[]
!Int; (?Bool; !Char)
(!Int; ?Bool); !Char

[]
!Bool; Skip
!Bool

-- The below kinding environment is not strictly needed

[("α", SL)]
?Char; Skip
?Char

-- Distributivity
[("α", SL)]
+{Leaf: Skip}; α
+{Leaf: α}

[("α", SL)]
+{Node: !Int}; α
+{Node: !Int; α}

[("α", SL)]
+{Leaf: Skip, Node: Skip}; α
+{Leaf: α, Node: α}

[("α", SL)]
+{Leaf: Skip, Node: !Int}; α
+{Leaf: Skip; α, Node: !Int; α}

-- Degenerated Recursive Types

[]
rec x. Skip
Skip

[]
Skip
rec x. Skip

[]
rec x. (Skip; Skip)
Skip

[]
rec x. rec y. Skip
Skip

[]
rec x. (Skip; rec y. Skip)
Skip

[]
rec x. rec y. (Skip; rec z. Skip; ?Int; Skip)
?Int

[]
rec x. rec y. (!Int; y)
rec z. (!Int; z)

[]
rec x. (rec y. !Int; x)
rec z. (!Int; z)

[]
rec x. rec y. rec z. (!Int; y)
rec z. (!Int; z)

[]
rec x.( Skip; x)
rec y.( Skip; y)

[]
rec x.( Skip; x; Skip)
rec x.( Skip; x)

[]
rec x.( Skip; x; Skip)
rec x.( Skip; x; Skip)

[]
rec x.( Skip; x)
Skip

[]
rec x.( Skip; x; Skip)
Skip

-- Regular Recursive Types

[]
rec x . (!Int;x)
rec x . (!Int;x)

[]
rec x . (!Int;x)
rec y . (!Int;y)

[]
rec x . (!Int;x)
rec x . (!Int; !Int;x)

[]
rec x . !Int
!Int

[]
rec x . !Int; Skip
Skip; !Int

[]
rec x . Skip; !Int
rec x . !Int; Skip

[]
rec x . Skip;!Int
!Int

[]
rec x. rec y. (!Int; x)
rec y. rec x. (!Int; x)

[]
rec x. rec y. (!Int; x)
rec x. (!Int; x)

-- Context-free Recursive Types, unnormed

[]
rec x. (!Int; x; x)
rec x. (!Int; x; x)

[]
rec x. rec y. (!Int; x; y)
rec y. rec x. (!Int; x; y)

[]
rec x. rec y. (!Int; x; y)
rec y. rec x. (!Int; x; ?Bool; y)

[]
rec x . (?Bool; x)
rec y . (?Bool; y; !Int)

[]
rec x . (?Bool; x)
rec y . (?Bool; y; y)

[]
rec x . +{A: x}
rec y . +{A: y}; !Bool

[]
rec x . +{A: x}; ?Bool
rec y . +{A: y}; !Bool

[]
rec x . (?Bool; x)
rec y . (?Bool; y; y; !Char; y; ?Int; y; y; ?Bool; y; y)

[]
rec x. &{Node: ?Int;x}
rec x. &{Node: ?Int;x}

[]
rec x. &{Node: ?Int;x;x}
rec x. &{Node: ?Int;x}

[]
rec x . &{Add: x;x;!Int}
rec x . &{Add: x;x;!Int}

-- Terminated types

[]
rec x. (Skip; x)
rec x. (Skip; x)

[]
rec x. ((Skip; x); rec y. (Skip; y))
rec x. (Skip; x)

-- []
-- rec x. (Skip; x); rec x. (Skip; x)  
-- rec x. (Skip; x); rec x. (Skip; x)  

[]
Skip
Skip; Skip

[]
rec x. (Skip; x)
Skip

[]
rec x. (Skip; x)
Skip; Skip

[]
rec x. (Skip; x; (rec x. (Skip; x)))
rec x. (Skip; x); rec x. (Skip; x)  

[]
rec x. ((rec x. (Skip; x)); (rec x. (Skip; x)))
rec x. (Skip; x); rec x. (Skip; x)  

-- Context-free Recursive Types, normed

[]
rec x. &{Leaf: Skip, Node: ?Int;x}
rec x. &{Leaf: Skip, Node: ?Int;x}

[]
rec x. &{Leaf: ?Bool, Node: ?Int;x;x}
rec x. &{Leaf: ?Bool, Node: ?Int;x;x}

[]
rec x. &{Leaf: Skip, Node: ?Int;x;x}
rec x. &{Leaf: Skip, Node: ?Int;x;x}

[("α", SL)]
rec x . +{A: α, B: x; α}
rec y . (+{A: Skip, B: y}; α)

[("α", SL)]
rec y . (+{A: Skip, B: y}; α)
rec x . +{A: α, B: x; α}

[]
(rec x. &{Leaf: Skip, Node: ?Int;x;x}); (rec x. &{Leaf: Skip, Node: ?Int;x;x})
(rec x. &{Leaf: Skip, Node: ?Int;x;x}); (rec x. &{Leaf: Skip, Node: ?Int;x;x})

[]
rec x . &{Add: x;x, Const: Skip}
rec x . &{Add: x;x, Const: Skip}

[]
rec x . &{Add: x;x;Skip, Const: Skip}
rec x . &{Add: x;x;Skip, Const: Skip}

[]
rec x . &{Add: x;x;x, Const: Skip}
rec x . &{Add: x;x;x, Const: Skip}

[]
rec x . &{Add: x;x;!Int, Const: Skip}
rec x . &{Add: x;x;!Int, Const: Skip}

[]
rec x . &{Add: x;x;!Int, Const: ?Int}
rec x . &{Add: x;x;!Int, Const: ?Int}

[]
rec x . &{Add: x;x;!Int, Const: ?Int;!Int}
rec x . &{Add: x;x;!Int, Const: ?Int;!Int}

[]
rec x . &{Add: x;x;!Int, Const: ?Int;!Int, Mult: x;x;!Int}
rec x . &{Add: x;x;!Int, Const: ?Int;!Int, Mult: x;x;!Int}

[]
&{Add: (((rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)}));!Int), Const: Skip}
&{Add: (((rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)}));!Int), Const: Skip}

[]
&{Add: (((rec x. &{Add: x;x, Const: Skip}); (rec x. &{Add: x;x, Const: Skip})); !Int), Const: Skip}
&{Add: (((rec x. &{Add: x;x, Const: Skip}); (rec x. &{Add: x;x, Const: Skip})); !Int), Const: Skip}

[]
&{Add: rec x . &{Add: x;x, Const: Skip}; rec x. &{Add: x;x, Const: ?Int}; !Int, Const: Skip}
&{Add: rec x . &{Add: x;x, Const: Skip}; rec x. &{Add: x;x, Const: ?Int}; !Int, Const: Skip}

[]
&{Add: (rec x . &{Add: x;x, Const: Skip}; rec x. &{Add: x;x, Const: Skip}); !Int, Const: Skip}
&{Add: (rec x . &{Add: x;x, Const: Skip}; rec x. &{Add: x;x, Const: Skip}); !Int, Const: Skip}

[]
&{Add: (rec x . &{Add: x;x, Const: Skip}; rec x. &{Add: x;x, Const: ?Int}); !Int, Const: Skip}
&{Add: (rec x . &{Add: x;x, Const: Skip}; rec x. &{Add: x;x, Const: ?Int}); !Int, Const: Skip}

[]
&{Add: (((rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)});(rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)}));!Int), Const: ?Int;!Int, Mult: (((rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)});(rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)}));!Int)}
&{Add: (((rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)});(rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)}));!Int), Const: ?Int;!Int, Mult: (((rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)});(rec x. &{Add: (x;x), Const: ?Int, Mult: (x;x)}));!Int)}

[]
&{LeafC: (rec x . &{LeafC: Skip, NodeC: (?Int;(x;x))}), NodeC: ((?Int;((rec x . &{LeafC: Skip, NodeC: (?Int;(x;x))});(rec x . &{LeafC: Skip, NodeC: (?Int;(x;x))})));(rec x . &{LeafC: Skip, NodeC: (?Int;(x;x))}))}
&{LeafC: (rec x . &{LeafC: Skip, NodeC: (?Int;(x;x))}), NodeC: ((?Int;((rec x . &{LeafC: Skip, NodeC: (?Int;(x;x))});(rec x . &{LeafC: Skip, NodeC: (?Int;(x;x))})));(rec x . &{LeafC: Skip, NodeC: (?Int;(x;x))}))}

[]
((rec termChan . +{Add: (termChan;termChan), Const: !Int, Mult: (termChan;termChan)});!Int)
((rec termChan . +{Add: (termChan;termChan), Const: !Int, Mult: (termChan;termChan)});!Int)

[]
(rec x . &{A: !Int ; x, B: Skip}) ; (rec x . &{A: !Int ; x, B: Skip}) ; ?Bool
(rec x . &{A: !Int ; x, B: Skip}) ; ((rec x . &{A: !Int ; x, B: Skip}) ; ?Bool)

[]
(rec x . &{A: !Int ; x}) ; (rec x . &{A: !Int ; x}) ; ?Bool
(rec x . &{A: !Int ; x}) ; ((rec x . &{A: !Int ; x}) ; ?Bool)

[]
!Char ; (rec x . &{A: !Int ; x,  B: Skip}) ; ?Bool
!Char ; ((rec x . &{A: !Int ; x, B: Skip}) ; ?Bool)

[]
rec x . &{N: x; !Int, L: !Int}
(rec x . &{N: x; !Int, L: Skip}); !Int

[]
rec x . (&{N: x;!Int, L: Skip}; ?Int)
rec x . &{N: x;!Int;?Int, L: ?Int}

[]
rec x . &{N: x;!Int, L: x}
rec x . &{N: x, L: x};!Int

[]
&{And: (?Bool;(?Bool;(!Bool;(rec x : SL . &{And: (?Bool;(?Bool;(!Bool;x))), End: Skip, Not: (?Bool;(!Bool;x)), Or: (?Bool;(?Bool;(!Bool;x)))})))), End: Skip, Not: (?Bool;(!Bool;(rec x : SL . &{And: (?Bool;(?Bool;(!Bool;x))), End: Skip, Not: (?Bool;(!Bool;x)), Or: (?Bool;(?Bool;(!Bool;x)))}))), Or: (?Bool;(?Bool;(!Bool;(rec x : SL . &{And: (?Bool;(?Bool;(!Bool;x))), End: Skip, Not: (?Bool;(!Bool;x)), Or: (?Bool;(?Bool;(!Bool;x)))}))))}
&{And: (?Bool;(?Bool;(!Bool;(rec x : SL . &{And: (?Bool;(?Bool;(!Bool;x))), End: Skip, Not: (?Bool;(!Bool;x)), Or: (?Bool;(?Bool;(!Bool;x)))})))), End: Skip, Not: (?Bool;(!Bool;(rec x : SL . &{And: (?Bool;(?Bool;(!Bool;x))), End: Skip, Not: (?Bool;(!Bool;x)), Or: (?Bool;(?Bool;(!Bool;x)))}))), Or: (?Bool;(?Bool;(!Bool;(rec x : SL . &{And: (?Bool;(?Bool;(!Bool;x))), End: Skip, Not: (?Bool;(!Bool;x)), Or: (?Bool;(?Bool;(!Bool;x)))}))))}

-- Examples from QuickCheck

[("x", SL), ("z", SL)]
(!Char;(+{A: z, B: z, C: z};(rec z_0:SL. ((rec y_1:SL. x);(Skip;x)))))
((!Char;+{A: z, B: z, C: z});(rec z_2:SL. ((rec y_3:SL. x);(Skip;x))))

[("x", SL)]
rec y:SL. x
rec z:SL. x

[]
(+{C: Skip};((rec x_0:SL. (Skip;Skip));(rec z_1:SL. (x;y))))
((+{C: Skip};(rec x_2:SL. (Skip;Skip)));(rec z_3:SL. (x;y)))

[]
(((rec x_0:SL. !Int);!Int);((rec z_1:SL. ((Skip;z_1);+{A: z_1, B: z_1, C: z_1}));!Int)) 
((((rec x_2:SL. !Int);!Int);(rec z_3:SL. ((Skip;z_3);+{A: z_3, B: z_3,C: z_3})));!Int)

[]
((rec z_0:SL. (((Skip;z_0);?Char);&{A: y, B: y, C: z_0}));((?Bool;(rec x_1:SL. +{A: x_1, B: Skip, C: y}));+{A: (rec y_2:SL. Skip), B: ?Int, C: !Bool}))
(((rec z_3:SL. (((Skip;z_3);?Char);&{A: y, B: y, C: z_3}));(?Bool;(rec x_4:SL. +{A: x_4, B: Skip, C: y})));+{A: (rec y_5:SL. Skip), B: ?Int, C: !Bool})

-- this one hangs 
-- []
--  (rec y_0:SL. (!Bool;+{A: y_0, B: y_0, C: x})) ; (?Int ; (?Int;&{A: Skip, B: z, C: z}))
-- ((rec y_1:SL. (!Bool;+{A: y_1, B: y_1, C: x})) ; ?Int) ; (?Int;&{A: Skip, B: z, C: z})

-- this one hangs 
-- []
-- rec y_0:SL. !Bool; +{A: y_0}
-- rec y_1:SL. !Bool; +{A: y_1}
