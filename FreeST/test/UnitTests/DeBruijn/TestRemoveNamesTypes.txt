Int
Int

Bool
Bool

Char
Char

()
()

Skip
Skip

!Int
!Int

!Char
!Char

?Bool
?Bool

?Char
?Char

Int -> Bool
Int -> Bool

Int -o Bool
Int -o Bool

Char -> Skip
Char -> Skip

Char -o Skip
Char -o Skip

(Int,Bool)
(Int,Bool)

!Int;?Bool
!Int;?Bool

Skip;Skip
Skip;Skip

!Int;Skip
!Int;Skip

Skip;+{S:Skip,I:!Int}
Skip;+{S:Skip,I:!Int}

-- Pairs

(Int, Bool) 
(Int, Bool) 

(Int -> Bool, Char -> (Bool -> Char)) 
(Int -> Bool, Char -> (Bool -> Char)) 

(Skip, Bool) 
(Skip, Bool) 

(Bool, Skip) 
(Bool, Skip) 

(Int, Bool) 
(Int, Bool) 

(Int -> Bool, Char -> (Bool -> Char)) 
(Int -> Bool, Char -> (Bool -> Char)) 

(Skip, Bool) 
(Skip, Bool) 

(Bool, Skip) 
(Bool, Skip) 

(!Bool, ?Int)
(!Bool, ?Int)

(!Bool, Int -o Char)
(!Bool, Int -o Char)

(!Bool -o Int -o Char, ?Int;&{A:Skip, B:!Bool})
(!Bool -o Int -o Char, ?Int;&{A:Skip, B:!Bool})

(Bool, ?Int)
(Bool, ?Int)

(Skip, Skip -o Skip)
(Skip, Skip -o Skip)

(Bool -> Char -> Int, ?Int -o Bool -> Int)
(Bool -> Char -> Int, ?Int -o Bool -> Int)

(!Bool, Int)
(!Bool, Int)

(!Bool, Skip)
(!Bool, Skip)

(Bool -o Char -> (Int -> ()), Int -> Skip -> ())
(Bool -o Char -> (Int -> ()), Int -> Skip -> ())

rec b:SL. !Bool ; Skip
rec SL. !Bool ; Skip

-- Recursive types

rec a : SL . ?Bool
rec SL . ?Bool

rec a : SL . (!Int; Skip; ?Int)
rec     SL . (!Int; Skip; ?Int)
  
rec tree : SL . &{Leaf: Skip, Node: ?Int;tree;tree}
rec SL . &{Leaf: Skip, Node: ?Int;§0;§0}

rec treeChannel : SL . +{Leaf: Skip, Node: !Int;treeChannel;treeChannel}
rec SL . +{Leaf: Skip, Node: !Int;§0;§0}

-- Parse error on input 'SL' ???
-- forall a:SL . rec alpha : SL . !Int ; rec SL . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec SL . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2} ; a
-- forall   SL . rec         SL . !Int ; rec SL . +{Leaf:Skip, Node:!Int;          §0;          §0} ; rec SL . +{Leaf:Skip, Node:!Int;          §0;          §0} ; §1

rec a : TU . (a, Int)
rec TU . (§0, Int)

rec b : TU . (b, Int -> Char)
rec TU . (§0, Int -> Char)

rec a : TL . a -o a
rec TL . §0 -o §0

-- Terminated Recursive Types

rec a:SL. Skip
rec SL. Skip

rec a:SL. (Skip; Skip)
rec SL. (Skip; Skip)

rec a:SL. rec b:SL. Skip
rec SL. rec SL. Skip

rec a:SL. (Skip; rec b:SL. Skip)
rec SL. (Skip; rec SL. Skip)

Skip; rec a:SU. Skip
Skip; rec SU. Skip

Skip; rec a:SU. Skip; Skip
Skip; rec SU. Skip; Skip

Skip; rec a:SU. rec b:SL. Skip
Skip; rec SU. rec SL. Skip

Skip; Skip; rec a:SU. (Skip; rec b:SL. Skip)
Skip; Skip; rec SU. (Skip; rec SL. Skip)

forall b:SL . rec a:SL. b
forall SL . rec SL. §1

forall a:SL . rec d:SL. rec c:SL. rec b : SL. a
forall SL . rec SL. rec SL. rec SL. §3

rec a . (a, Int)
rec . (§0, Int)

--Session types generated by Quick Check

forall a:SL . forall b:SL . forall z:SL . !Bool; (((!Int;Skip); (Skip;+{A:  b, B: Skip})); (Skip;(rec b_0:SU. (&{A: ((?Char;(Skip; a));Skip), C: !Bool};Skip))))
forall   SL . forall   SL . forall   SL . !Bool; (((!Int;Skip); (Skip;+{A: §1, B: Skip})); (Skip;(rec     SU. (&{A: ((?Char;(Skip;§3));Skip), C: !Bool};Skip))))

forall a:SL . forall b:SL . forall z:SL . !Bool;((!Int;+{A:  b, B: Skip});(rec b_1:SU.  &{A: ((?Char;Skip); a), C: !Bool}))
forall   SL . forall   SL . forall   SL . !Bool;((!Int;+{A: §1, B: Skip});(rec     SU.  &{A: ((?Char;Skip);§3), C: !Bool}))

(rec b . +{A: (rec b . (rec a : SL . (+{A: (Skip;(?Int;!())), B: (Skip;?Char)}; a)))})
(rec   . +{A: (rec   . (rec     SL . (+{A: (Skip;(?Int;!())), B: (Skip;?Char)};§0)))})

+{A: (rec b. +{A: (((Skip;?Int);!());(rec b . +{A: (rec b : SL. +{A:(((Skip;?Int);!()); b),B:(?Char; b)})})), B: (?Char;(rec b. +{A: (rec b : SL. +{A: (((Skip;?Int);!()); b),B: (?Char; b)})}))})}
+{A: (rec  . +{A: (((Skip;?Int);!());(rec   . +{A: (rec     SL. +{A:(((Skip;?Int);!());§0),B:(?Char;§0)})})), B: (?Char;(rec  . +{A: (rec     SL. +{A: (((Skip;?Int);!());§0),B: (?Char;§0)})}))})}

-- Forall

∀ a . a -> a -> a -- Boolean type as Church Encoding
∀ . §0 -> §0 -> §0

∀ a : TL . a
∀     TL . §0

∀ a : TL . a
∀ TL . §0

∀ a : TU . a  -> a
∀     TU . §0 -> §0

∀ a : TL . a  -o Int
∀     TL . §0 -o Int

∀ a : TU . a  -o Int
∀     TU . §0 -o Int

∀ a : TU . a  -> Int
∀     TU . §0 -> Int

∀ a : SL . a  -> Int
∀     SL . §0 -> Int

∀ a : SL . rec b : TU . a -> b
∀     SL . rec     TU . §1 -> §0

∀ a : SL . (rec a : SL . !Int;a)  -> a
∀     SL . (rec     SL . !Int;§0) -> §0

∀ a : SL . Skip
∀     SL . Skip

∀ a : TU . a  -> Int
∀     TU . §0 -> Int

Int -> ∀ a : TU . a
Int -> ∀     TU . §0

(Int, ∀ a : TL . a)
(Int, ∀     TL . §0)

Bool -> ∀ a : SL . (rec a : SL . !Int;a)  -> a
Bool -> ∀     SL . (rec     SL . !Int;§0) -> §0

-- Dualof

dualof Skip
dualof Skip

dualof (Skip; Skip)
dualof (Skip; Skip)

dualof (rec a. Skip)
dualof (rec  . Skip)

rec a. dualof Skip
rec  . dualof Skip

rec y:SL . +{B: !(), C: !Bool} ; (+{A: y ;!(), C: !()} ; y)
rec   SL . +{B: !(), C: !Bool} ; (+{A: §0;!(), C: !()} ; §0)

rec x:SL . rec y:SL . +{B: !(), C: !Bool} ; ((+{A: y, C: Skip};!())  ; x)
rec   SL . rec   SL . +{B: !(), C: !Bool} ; ((+{A: §0, C: Skip};!()) ; §1)

-- Messages not of kind ML

!(Int, Bool)
!(Int, Bool)

!(!Int; ?Bool)
!(!Int; ?Bool)

rec a:SL . ?(!Int; a)
rec   SL . ?(!Int; §0)

-- Shared channels, raw syntax

rec a:SU . !Int; a
rec   SU . !Int; §0

rec a:SU . ?Int; a
rec   SU . ?Int; §0

rec a:SU . +{One:  a, Two:  a}
rec   SU . +{One: §0, Two: §0}

rec a:SU . &{One:  a, Two:  a}
rec   SU . &{One: §0, Two: §0}
