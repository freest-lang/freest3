-- Syntatically invalid choices, conflicting choices

+{ A: Unit, A: Bool }
+{ A: Unit, A: Bool, B: Int }
+{ A: Unit, B: Int, A: Bool }
+{ A: Unit, B: Int, B: Int, A: Bool }
&{ A: Unit, A: Bool }
&{ A: Unit, A: Bool, B: Int }
&{ A: Unit, B: Int, A: Bool }
&{ A: Unit, B: Int, B: Int, A: Bool }
&{}
+{}

-- Duplicate labels in records

+{ A: !(), A: !Bool }
+{ A: !(), A: !Bool, B: ?Int }
+{ A: !(), B: ?Int, A: ?Bool }
+{ A: !(), B: ?Int, B: ?Int, A: ?Bool }
&{ A: !(), A: ?Bool }
&{ A: !(), A: ?Bool, B: ?Int }
&{ A: !(), B: ?Int, A: ?Bool }
&{ A: !(), B: ?Int, B: ?Int, A: ?Bool }


-- Syntatically invalid datatypes, conflicting - removed these because they are not readable types anymore (only available for data declarations)

-- [ A: Char, A: Bool ]
-- [ A: Char, A: Bool, B: Int ]
-- [ A: Char, B: Int, A: Bool ]
-- [ A: Char, B: Int, B: Int, A: Bool ]
-- [ A: Char, A: Bool ]
-- [ A: Char, A: Bool, B: Int ]
-- [ A: Char, B: Int, A: Bool ]
-- [ A: Char, B: Int, B: Int, A: Bool ]
-- []

-- Rec stuff

rec x. x; !Int
rec x. x  
rec x. x;  x;  x;  x;  x
rec x. dualof x
rec x. dualof dualof x  
rec x. (dualof dualof x); &{ A: !(), B: ?Int }
rec x. dualof dualof  dualof dualof  dualof dualof  dualof dualof  dualof dualof x 
rec a. rec b. rec c. rec d. a
Int -> rec a. rec b. rec c. rec d. a
rec a. rec b. rec c. rec d. a; !Bool
rec a. ((a; !Bool); !Int) ; ?Bool
rec z:SL.(rec z:SU.(Skip;(rec x:SU.(rec z:SL.&{B: (rec z:SL.(rec x:SL.(z;(Skip;y))))}))))
rec z:SL.(rec x:SU.&{B: (rec z:SL.((z;Skip);y))})
(rec x:SU.(x;!Bool));!Bool 
rec x:SU.x;!Bool
rec z:SL.(rec x:SU.&{B: (rec z:SL.((z;Skip);y))})
rec z:SL.(rec z:SU.(Skip;(rec x:SU.(rec z:SL.&{B: (rec z:SL.(rec x:SL.(z;(Skip;y))))}))))

-- Functional vs Session

!Int ; Int -> Int
!Int ; (Int, Bool)
Int -> Int ; !Int
(Int, Bool) ; !Int
rec x : SL . Int -> Int ; x 
rec x : SU . Int -> Int ; x 
rec x : TU . !Int ; x 
rec x : TL . !Int ; x 
+{ A: () }
+{ A: () -> Bool }


