-- Empty choices

&{}
+{}

-- Duplicated labels in records

+{ A: !(), A: !Bool }
+{ A: !(), A: !Bool, B: ?Int }
+{ A: !(), B: ?Int, A: ?Bool }
+{ A: !(), B: ?Int, B: ?Int, A: ?Bool }
&{ A: !(), A: ?Bool }
&{ A: !(), A: ?Bool, B: ?Int }
&{ A: !(), B: ?Int, A: ?Bool }
&{ A: !(), B: ?Int, B: ?Int, A: ?Bool }
+{ A: Unit, A: Bool }
+{ A: Unit, A: Bool, B: Int }
+{ A: Unit, B: Int, A: Bool }
+{ A: Unit, B: Int, B: Int, A: Bool }
&{ A: Unit, A: Bool }
&{ A: Unit, A: Bool, B: Int }
&{ A: Unit, B: Int, A: Bool }
&{ A: Unit, B: Int, B: Int, A: Bool }

-- Non contractive, non terminated

rec b:SL. Skip ; b ; ?Bool
rec z:SU.(+{A: Skip, C: z} ; rec b:SL.((Skip;b);?Bool))
rec z1:SU.(rec z2:SU.(rec a:SL.(+{A: Skip, C: a} ; rec z3:SU.(rec b:SL.(Skip;(z3;?Bool))))))
rec a:SL. (Skip ; a) ; !Bool
rec a. a; !Int
rec a. rec b. rec c. rec d. a; !Bool
rec a. ((a; !Bool); !Int) ; ?Bool
rec z:SL.(rec z:SU.(Skip;(rec a:SU.(rec z:SL.&{B: (rec z:SL.(rec a:SL.(z;(Skip;b))))}))))
rec z:SL.(rec a:SU.&{B: (rec z:SL.((z;Skip);b))})
(rec a:SU.(a;!Bool));!Bool 
rec a:SU.a;!Bool
rec z:SL.(rec a:SU.&{B: (rec z:SL.((z;Skip);b))})
rec z:SL.(rec z:SU.(Skip;(rec a:SU.(rec z:SL.&{B: (rec z:SL.(rec a:SL.(z;(Skip;b))))}))))

-- Non contractive but terminated; recursion on non session type variables

rec a. a
rec a:TL. a
rec a. a;  a;  a;  a;  a
rec a. rec b. rec c. rec d. a
rec a:SU. (rec a:TU. Skip; a); (rec a:SU. (Skip; a))
Skip; rec a:SU. ((rec a:MU. (Skip; a)); (rec a:SU. (Skip; a))); Skip; Skip
Int -> rec a. rec b. rec c. rec d. a
(rec a. rec b. rec c. rec d. a) -> Bool
(rec a. rec b. rec c. rec d. a, Int)

-- Non contractive with dualof

rec a. dualof a
rec a. dualof dualof a  
rec a. (dualof dualof a); &{ A: !(), B: ?Int }
rec a. dualof dualof  dualof dualof  dualof dualof  dualof dualof  dualof dualof a 

-- Functional vs Session

!Int ; Int -> Int
!Int ; (Int, Bool)
Int -> Int ; !Int
(Int, Bool) ; !Int
rec a : SL . Int -> Int ; a 
rec a : SU . Int -> Int ; a 
rec a : TU . !Int ; a 
rec a : TL . !Int ; a 
+{ A: () }
+{ A: () -> Bool }

-- Free Variables

a
Skip; a
rec b. !Int; a
Bool -o a
(Char, Bool -o a)
Int -> ∀ a : MU . b  
Int -> ∀ a : MU . (Bool -> b)
(Char, Int -> ∀ a : MU . (Bool -> b))
forall a:SL . forall b:SL . forall z:SL . ((rec z:SL. (Skip;&{B: (+{A: (&{B: a, C: Skip};+{A: (?Bool;Skip), B: (z;Skip), C: (((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);Skip)})};(+{A: !Char};(((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);(?Char;((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z))))), C: Skip}));((a;&{B: (!Bool;(?();b)), C: (Skip;(?();c))});((?Int;+{B: a, C: ?Int});!Int)))

-- Messages not of kind ML

-- !(Int, Bool)
-- !(!Int; ?Bool)
-- rec a . ?(Int; a)

-- Syntatically invalid datatypes, conflicting - removed these because they are not readable types anymore (only available for data declarations)

-- [ A: Char, A: Bool ]
-- [ A: Char, A: Bool, B: Int ]
-- [ A: Char, B: Int, A: Bool ]
-- [ A: Char, B: Int, B: Int, A: Bool ]
-- [ A: Char, A: Bool ]
-- [ A: Char, A: Bool, B: Int ]
-- [ A: Char, B: Int, A: Bool ]
-- [ A: Char, B: Int, B: Int, A: Bool ]
-- []

-- The kind of the recursion variable is a sub-kind of the one of rec body
-- expecting the other way around.
rec a:MU . !a

forall b:SL. !Int; rec a:SL. b; a


-- Non contractive types

rec a:SL. a
SU

rec a:SU. a
SU

rec a:SU. (Skip; a)
SU

rec a:SU. Skip; a; Skip
SU

rec a:SU. Skip; a; a; a; a; a
SU

Skip; rec a:SU. (Skip; a)
SU

Skip; rec a:SU. (Skip; a; Skip)
SU

Skip; rec a:SU. (Skip; a; Skip)
SU

Skip; Skip; Skip; rec a:SU. (Skip; a; a; a; a; a)
SU

rec a:SU. (((Skip ; a) ; a) ; a)
SU

rec a:SU. (rec a:SU. Skip; a); (rec a:SU. (Skip; a))
SU

Skip; rec a:SU. ((rec a:SU. (Skip; a)); (rec a:SU. (Skip; a))); Skip; Skip
SU

-- Types with a part that is non contractive but terminated

Int -> rec a:SL. rec b:SL. rec c:SL. rec d:SL. a
TU

(rec a:TU. rec b:TU. rec c:TU. rec d:TU. a) -> Bool
TU

(rec a:SU. rec b:SU. rec c:SU. rec d:SU. a, Int)
TU

