[]
Int
TU

[]
Bool
TU

[]
Char
TU

[]
()
TU

[]
Skip
SU

[]
!Int
SL

[]
!Char
SL

[]
?Bool
SL

[]
?Char
SL

[]
Int -> Bool
TU

[]
Int -o Bool
TL

[]
Char -> Skip
TU

[]
Char -o Skip
TL

[]
(Int,Bool)
TU

[]
!Int;?Bool
SL

[]
Skip;Skip
SU

[]
!Int;Skip
SL

[]
Skip;+{S:Skip,I:!Int}
SL

-- recursive types

[]
rec x . ?Bool
SL

[]
rec x . (!Int; Skip; ?Int)
SL
  
[]
rec tree : SL . &{Leaf: Skip, Node: ?Int;tree;tree}
SL
  
[]
rec treeChannel : SL . +{Leaf: Skip, Node: !Int;treeChannel;treeChannel}
SL
  
[("x", "SL")]
rec alpha : SL . !Int ; rec treeChannel1 : SL . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : SL . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};x
SL

-- explicitely typed recursive types

[]
rec a : TU . (a, Int)
TL

[]
rec b : TU . (b, Int -> Char)
TL

-- Pairs

-- (Un, Un)
[]
(Int, Bool) 
TU

[]
(Int -> Bool, Char -> (Bool -> Char)) 
TU

[]
(Skip, Bool) 
TU

[]
(Bool, Skip) 
TU

[]
(Int, Bool) 
TL

[]
(Int -> Bool, Char -> (Bool -> Char)) 
TL

[]
(Skip, Bool) 
TL

[]
(Bool, Skip) 
TL

-- (Lin, Lin)
[]
(!Bool, ?Int)
TL

[]
(!Bool, Int -o Char)
TL

[]
(!Bool -o Int -o Char, ?Int;&{A:Skip, B:!Bool})
TL

-- (Un, Lin)
[]
(Bool, ?Int)
TL

[]
(Skip, Skip -o Skip)
TL

[]
(Bool -> Char -> Int, ?Int -o Bool -> Int)
TL

-- (Lin, Un)
[]
(!Bool, Int)
TL

[]
(!Bool, Skip)
TL

[]
(Bool -o Char -> (Int -> ()), Int -> Skip -> ())
TL

-- Quick Check

[("x", "SL") , ("y", "SL") , ("z", "SL")]
!Bool;(((!Int;Skip);(Skip;+{A: y, B: Skip}));(Skip;(rec y_0:SU. (&{A: ((?Char;(Skip;x));Skip), C: !Bool};Skip))))
SL

[("x", "SL") , ("y", "SL") , ("z", "SL")]
!Bool;((!Int;+{A: y, B: Skip});(rec y_1:SU. &{A: ((?Char;Skip);x), C: !Bool}))
SL

[("x", "SL") , ("y", "SL") , ("z", "SL")]
&{B: (&{C: (rec x_8:SL. (rec x_9:SU. (((+{A: y, C: z};?Bool);+{B: Skip, C: ?Bool});+{A: (rec x_10:SU. (rec y_11:SU. (rec y_12:SL. !()))), C: (Skip;Skip)})))};(((rec z_13:SL. +{B: ((Skip;(Skip;(Skip;(x;?Bool))));(?Bool;(Skip;!())))});(rec y_14:SU. !()));?Bool)), C: (?Char;(((rec y_15:SU. (Skip;((Skip;z);((y_15;(x;x));(Skip;(Skip;!()))))));Skip);+{A: (?Int;(&{B: Skip};(y;Skip)))}))}
SL

[]
rec y:SU. !Bool ; Skip
SL

-- Terminated Recursive Types

-- []
-- rec y:SL. Skip ; y ; ?Bool
-- SL

-- []
-- rec z:SU.(+{A: Skip, C: z} ; rec y:SL.((Skip;y);?Bool))
-- SL

-- []
-- rec z1:SU.(rec z2:SU.(rec x:SL.(+{A: Skip, C: x} ; rec z3:SU.(rec y:SL.(Skip;(z3;?Bool))))))
-- SL

-- []
-- rec x:SL. (Skip ; x) ; !Bool
-- SL

-- []
-- rec x:SU. Skip
-- SU

-- []
-- rec x:SU. (Skip; Skip)
-- SU

-- []
-- rec x:SU. rec y. Skip
-- SU

-- []
-- rec x:SU. (Skip; rec y. Skip)
-- SU

-- []
-- rec x:SU. (Skip; x)
-- SU

-- []
-- rec x:SU. Skip; x; Skip
-- SU

-- []
-- rec x:SU. Skip; x; x; x; x; x
-- SU

-- []
-- rec x:SU. (rec x:SU. Skip; x); (rec x:SU. (Skip; x))
-- SU

-- []
-- Skip; rec x:SU. Skip
-- SU

-- []
-- Skip; rec x:SU. Skip; Skip
-- SU

-- []
-- Skip; rec x:SU. rec y. Skip
-- SU

-- []
-- Skip; Skip; rec x:SU. (Skip; rec y. Skip)
-- SU

-- []
-- Skip; rec x:SU.(Skip; x)
-- SU

-- []
-- Skip; rec x:SU.( Skip; x; Skip)
-- SU

-- []
-- Skip; rec x:SU.( Skip; x; Skip)
-- SU

-- []
-- Skip; Skip; Skip; rec x:SU. (Skip; x; x; x; x; x)
-- SU

-- []
-- Skip; rec x:SU. ((rec x:SU. (Skip; x)); (rec x:SU. (Skip; x))); Skip; Skip
-- SU

-- [("y", "SL")]
-- rec x:SU. y
-- SL

-- [("a", "SL")]
-- rec d. rec c. rec b. a
-- SL

-- []
-- rec x:SU. (((Skip ; x) ; x) ; x)
-- SU

-- Dualof

-- TODO: this should be OK
-- []
-- rec x . dualof !Int
-- SL

[]
dualof Skip
SU

[]
dualof (Skip; Skip)
SU

-- TODO: this should be OK
-- []
-- dualof (rec x. Skip)
-- SU

-- TODO: this should be OK
-- []
-- rec x. dualof Skip
-- SU

[]
(rec y . +{A: (rec y . (rec x : SL . (+{A: (Skip;(?Int;!())), B: (Skip;?Char)};x)))})
SL

[]
+{A: (rec y. +{A: (((Skip;?Int);!());(rec y . +{A: (rec y : SL. +{A:(((Skip;?Int);!());y), B: (?Char;y)})})), B: (?Char;(rec y. +{A: (rec y : SL. +{A: (((Skip;?Int);!());y), B: (?Char;y)})}))})}
SL

[("x", "SL") , ("y", "SL") , ("z", "SL")]
((rec w:SL. &{B: ((+{A: &{B: x, C: Skip}};(+{A: ?Bool, B: w, C: (?Int;(&{A: ((?();(x;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w))};Skip));+{A: (!Char;(((?Int;(&{A: ((?();(x;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w));?Char);(?Int;(&{A: ((?();(x;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w))))}), C: Skip});(x;((&{B: !Bool, C: Skip};((rec δ:SU. ?());y));(?Int;(+{B: x, C: ?Int};(!Int;Skip))))))
SL

[("x", "SL") , ("y", "SL") , ("z", "SL")]
 ((rec z:SL. (Skip;&{B: (+{A: (&{B: x, C: Skip};+{A: (?Bool;Skip), B: (z;Skip), C: (((?Int;&{A: ((((?();x);z);+{A: z, C: Skip});!Int), C: !Char});z);Skip)})};(+{A: !Char};(((?Int;&{A: ((((?();x);z);+{A: z, C: Skip});!Int), C: !Char});z);(?Char;((?Int;&{A: ((((?();x);z);+{A: z, C: Skip});!Int), C: !Char});z))))), C: Skip}));((x;&{B: (!Bool;(?();y)), C: (Skip;(?();y))});((?Int;+{B: x, C: ?Int});!Int)))
SL

[("x", "SL") , ("y", "SL") , ("z", "SL")]
(rec y:SU.+{A: (y;&{A: (Skip;(rec x:SU.+{A: (y;&{A: (Skip;x), C:(y;x)}), B: (Skip;&{A: (Skip;x), C: (y;x)}), C: (!Bool;&{A: (Skip;x),C: (y;x)})})), C: (y;(rec x:SU.+{A: (y;&{A: (Skip;x), C: (y;x)}), B:(Skip;&{A: (Skip;x), C: (y;x)}), C: (!Bool;&{A: (Skip;x), C:(y;x)})}))}), B: (Skip;&{A: (Skip;(rec x:SU.+{A: (y;&{A: (Skip;x), C:(y;x)}), B: (Skip;&{A: (Skip;x), C: (y;x)}), C: (!Bool;&{A: (Skip;x),C: (y;x)})})), C: (y;(rec x:SU.+{A: (y;&{A: (Skip;x), C: (y;x)}), B:(Skip;&{A: (Skip;x), C: (y;x)}), C: (!Bool;&{A: (Skip;x), C:(y;x)})}))}), C: (!Bool;&{A: (Skip;(rec x:SU.+{A: (y;&{A: (Skip;x), C:(y;x)}), B: (Skip;&{A: (Skip;x), C: (y;x)}), C: (!Bool;&{A: (Skip;x),C: (y;x)})})), C: (y;(rec x:SU.+{A: (y;&{A: (Skip;x), C: (y;x)}), B:(Skip;&{A: (Skip;x), C: (y;x)}), C: (!Bool;&{A: (Skip;x), C:(y;x)})}))})})
SL

-- Forall λ
[]
∀ a : MU => a
MU -> MU

-- same nut it forall keyword
[]
forall a : MU => a
MU -> MU


[]
∀ a : TU => a -> a
TU -> TU

[]
∀ a : TL => a -o Int
TL -> TL

[]
∀ a : TU => a -o Int
TU -> TL

[]
∀ a : TU => a -> Int
TU -> TU

[]
∀ a : SL => a -> Int
SL -> TL

-- forall rec

[]
∀ a : SL => rec b : SL . a -> b
SL -> TL

-- same but as a subkind
[]
∀ a : SL => rec b : SL . a -> b
SL -> TU


[]
∀ a : SL => (rec a : SL . a) -> a
SL -> TU

[]
∀ a : SL => Skip
SL -> SU


-- Subkinding & forall

[]
∀ a : TU => a -> Int
TL -> TU
