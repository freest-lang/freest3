Int
TU

Bool
TU

Char
TU

()
TU

Skip
SU

!Int
SL

!Char
SL

?Bool
SL

?Char
SL

Int -> Bool
TU

Int -o Bool
TL

Char -> Skip
TU

Char -o Skip
TL

(Int,Bool)
TU

!Int;?Bool
SL

Skip;Skip
SU

!Int;Skip
SL

Skip;+{S:Skip,I:!Int}
SL

-- Pairs

(Int, Bool) 
TU

(Int -> Bool, Char -> (Bool -> Char)) 
TU

(Skip, Bool) 
TU

(Bool, Skip) 
TU

(Int, Bool) 
TL

(Int -> Bool, Char -> (Bool -> Char)) 
TL

(Skip, Bool) 
TL

(Bool, Skip) 
TL

(!Bool, ?Int)
TL

(!Bool, Int -o Char)
TL

(!Bool -o Int -o Char, ?Int;&{A:Skip, B:!Bool})
TL

(Bool, ?Int)
TL

(Skip, Skip -o Skip)
TL

(Bool -> Char -> Int, ?Int -o Bool -> Int)
TL

(!Bool, Int)
TL

(!Bool, Skip)
TL

(Bool -o Char -> (Int -> ()), Int -> Skip -> ())
TL

 rec b:SU. !Bool ; Skip
SL

-- Recursive types

rec a . ?Bool
SL

rec a . (!Int; Skip; ?Int)
SL
  
rec tree : SL . &{Leaf: Skip, Node: ?Int;tree;tree}
SL
  
rec treeChannel : SL . +{Leaf: Skip, Node: !Int;treeChannel;treeChannel}
SL
  
forall a:SL =>  rec alpha : SL . !Int ; rec treeChannel1 : SL . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : SL . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};a
TL

forall a:SL => rec alpha : SL . !Int ; rec treeChannel1 : SL . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : SL . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};a
TL

rec a : TU . (a, Int)
TL

rec b : TU . (b, Int -> Char)
TL

-- Terminated Recursive Types

rec a:SL. Skip
SL

rec a:SL. Skip
SU

rec a:SU. (Skip; Skip)
SU

rec a:SU. rec b. Skip
SU

rec a:SU. (Skip; rec b. Skip)
SU

Skip; rec a:SU. Skip
SU

Skip; rec a:SU. Skip; Skip
SU

Skip; rec a:SU. rec b. Skip
SU

Skip; Skip; rec a:SU. (Skip; rec b. Skip)
SU

forall b:SL => rec a:SU. b
TL

forall a:SL => rec d. rec c. rec b. a
TL

-- Non contractive but terminated; all these types are equivalent to
--   Skip, according to the tick-identification convention

rec a:TL. a
SU

rec a:SU. (Skip; a)
SU

rec a:SU. Skip; a; Skip
SU

rec a:SU. Skip; a; a; a; a; a
SU

Skip; rec a:SU. (Skip; a)
SU

Skip; rec a:SU. ( Skip; a; Skip)
SU

Skip; rec a:SU. ( Skip; a; Skip)
SU

Skip; Skip; Skip; rec a:SU. (Skip; a; a; a; a; a)
SU

rec a:SU. (((Skip ; a) ; a) ; a)
SU

rec a. a
SU

rec a. a;  a;  a;  a;  a
SU

rec a. rec b. rec c. rec d. a
SU

rec a:SU. (rec a:SU. Skip; a); (rec a:SU. (Skip; a))
SU

Skip; rec a:SU. ((rec a:SU. (Skip; a)); (rec a:SU. (Skip; a))); Skip; Skip
SU

-- Types with a part that is non contractive but terminated

Int -> rec a. rec b. rec c. rec d. a
TU

rec a. rec b. rec c. rec d. a -> Bool
TU

 (rec a. rec b. rec c. rec d. a, Int)
TU

--Session types generated by Quick Check

forall a:SL => forall b:SL => forall z:SL => !Bool;(((!Int;Skip);(Skip;+{A: b, B: Skip}));(Skip;(rec b_0:SU. (&{A: ((?Char;(Skip;a));Skip), C: !Bool};Skip))))
TL

forall a:SL => forall b:SL => forall z:SL => !Bool;((!Int;+{A: b, B: Skip});(rec b_1:SU. &{A: ((?Char;Skip);a), C: !Bool}))
TL

forall a:SL => forall b:SL => forall z:SL => &{B: (&{C: (rec a_8:SL. (rec a_9:SU. (((+{A: b, C: z};?Bool);+{B: Skip, C: ?Bool});+{A: (rec a_10:SU. (rec b_11:SU. (rec b_12:SL. !()))), C: (Skip;Skip)})))};(((rec z_13:SL. +{B: ((Skip;(Skip;(Skip;(a;?Bool))));(?Bool;(Skip;!())))});(rec b_14:SU. !()));?Bool)), C: (?Char;(((rec b_15:SU. (Skip;((Skip;z);((b_15;(a;a));(Skip;(Skip;!()))))));Skip);+{A: (?Int;(&{B: Skip};(b;Skip)))}))}
TL

(rec b . +{A: (rec b . (rec a : SL . (+{A: (Skip;(?Int;!())), B: (Skip;?Char)};a)))})
SL

+{A: (rec b. +{A: (((Skip;?Int);!());(rec b . +{A: (rec b : SL. +{A:(((Skip;?Int);!());b), B: (?Char;b)})})), B: (?Char;(rec b. +{A: (rec b : SL. +{A: (((Skip;?Int);!());b), B: (?Char;b)})}))})}
SL

forall a:SL => forall b:SL => forall z:SL => ((rec w:SL. &{B: ((+{A: &{B: a, C: Skip}};(+{A: ?Bool, B: w, C: (?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w))};Skip));+{A: (!Char;(((?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w));?Char);(?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w))))}), C: Skip});(a;((&{B: !Bool, C: Skip};((rec δ:SU. ?());b));(?Int;(+{B: a, C: ?Int};(!Int;Skip))))))
TL

forall a:SL => forall b:SL => forall z:SL => ((rec z:SL. (Skip;&{B: (+{A: (&{B: a, C: Skip};+{A: (?Bool;Skip), B: (z;Skip), C: (((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);Skip)})};(+{A: !Char};(((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);(?Char;((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z))))), C: Skip}));((a;&{B: (!Bool;(?();b)), C: (Skip;(?();b))});((?Int;+{B: a, C: ?Int});!Int)))
TL

forall a:SL => forall b:SL => forall z:SL => (rec b:SU.+{A: (b;&{A: (Skip;(rec a:SU.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a:SU.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))}), B: (Skip;&{A: (Skip;(rec a:SU.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a:SU.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))}), C: (!Bool;&{A: (Skip;(rec a:SU.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a:SU.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))})})
TL

-- Forall

∀ a : MU => a
TL

forall a : MU => a
TL

∀ a : TU => a -> a
TL

∀ a : TL => a -o Int
TL

∀ a : TU => a -o Int
TL

∀ a : TU => a -> Int
TL

∀ a : SL => a -> Int
TL

∀ a : SL => rec b : SL . a -> b
TL

∀ a : SL => (rec a : SL . !Int;a) -> a
TL

∀ a : SL => Skip
TL

∀ a : TU => a -> Int
TL

Int -> ∀ a : TU => a
TL

(Int, ∀ a : ML => a)
TL

Bool -> ∀ a : SL => (rec a : SL . !Int;a) -> a
TL

-- Dualof

-- TODO: this should be OK
-- rec a . dualof !Int
-- SL

dualof Skip
SU

dualof (Skip; Skip)
SU

-- TODO: this should be OK
-- dualof (rec a. Skip)
-- SU

-- TODO: this should be OK
-- rec a. dualof Skip
-- SU

