Int
*T

Bool
*T

Char
*T

()
*T

Skip
*S

!Int
1S

!Char
1S

?Bool
1S

?Char
1S

Int -> Bool
*T

Int 1-> Bool
1T

Char -> Skip
*T

Char 1-> Skip
1T

(Int,Bool)
*T

!Int;?Bool
1S

Skip;Skip
1S

!Int;Skip
1S

Skip;+{S:Skip,I:!Int}
1S

-- Pairs

(Int, Bool) 
*T

(Int -> Bool, Char -> (Bool -> Char)) 
*T

(Skip, Bool) 
*T

(Bool, Skip) 
*T

(Int, Bool) 
1T

(Int -> Bool, Char -> (Bool -> Char)) 
1T

(Skip, Bool) 
1T

(Bool, Skip) 
1T

(!Bool, ?Int)
1T

(!Bool, Int 1-> Char)
1T

(!Bool 1-> Int 1-> Char, ?Int;&{A:Skip, B:!Bool})
1T

(Bool, ?Int)
1T

(Skip, Skip 1-> Skip)
1T

(Bool -> Char -> Int, ?Int 1-> Bool -> Int)
1T

(!Bool, Int)
1T

(!Bool, Skip)
1T

(Bool 1-> Char -> (Int -> ()), Int -> Skip -> ())
1T

rec b: 1S. !Bool ; Skip
1S

-- Recursive types

rec a : 1S . ?Bool
1S

rec a : 1S . (!Int; Skip; ?Int)
1S
  
rec tree : 1S . &{Leaf: Skip, Node: ?Int;tree;tree}
1S
  
rec treeChannel : 1S . +{Leaf: Skip, Node: !Int;treeChannel;treeChannel}
1S
  
forall a: 1S .  rec alpha : 1S . !Int ; rec treeChannel1 : 1S . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : 1S . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};a
1T

forall a: 1S . rec alpha : 1S . !Int ; rec treeChannel1 : 1S . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : 1S . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};a
1T

rec a : *T . (a, Int)
1T

rec b : *T . (b, Int -> Char)
1T

rec a : 1T . a 1-> a
1T

-- Terminated Recursive Types

rec a: 1S. Skip
1S

rec a: 1S. Skip
*S

rec a: 1S. (Skip; Skip)
1S

rec a: 1S. rec b: 1S. Skip
1S

rec a: 1S. (Skip; rec b: 1S. Skip)
1S

Skip; rec a: *S. Skip
1S

Skip; rec a: *S. Skip; Skip
1S

Skip; rec a: *S. rec b: 1S. Skip
1S

Skip; Skip; rec a: *S. (Skip; rec b: 1S. Skip)
1S

forall b: 1S . rec a: 1S. b
1T

forall a: 1S . rec d: 1S. rec c: 1S. rec b : 1S. a
1T

rec a . (a, Int)
*T

--Session types generated by Quick Check

forall a: 1S . forall b: 1S . forall z: 1S . !Bool;(((!Int;Skip);(Skip;+{A: b, B: Skip}));(Skip;(rec b_0: *S. (&{A: ((?Char;(Skip;a));Skip), C: !Bool};Skip))))
1T

forall a: 1S . forall b: 1S . forall z: 1S . !Bool;((!Int;+{A: b, B: Skip});(rec b_1: *S. &{A: ((?Char;Skip);a), C: !Bool}))
1T

-- forall a:1S . forall b:1S . forall z:1S . &{B: (&{C: (rec a_8:1S. (rec a_9:1S. (((+{A: b, C: z};?Bool);+{B: Skip, C: ?Bool});+{A: (rec a_10:1S. (rec b_11:1S. (rec b_12:1S. !()))), C: (Skip;Skip)})))};(((rec z_13:1S. +{B: ((Skip;(Skip;(Skip;(a;?Bool))));(?Bool;(Skip;!())))});(rec b_14:1S. !()));?Bool)), C: (?Char;(((rec b_15:1S. (Skip;((Skip;z);((b_15;(a;a));(Skip;(Skip;!()))))));Skip);+{A: (?Int;(&{B: Skip};(b;Skip)))}))}
-- 1T

(rec b . +{A: (rec b . (rec a : 1S . (+{A: (Skip;(?Int;!())), B: (Skip;?Char)};a)))})
1S

+{A: (rec b. +{A: (((Skip;?Int);!());(rec b . +{A: (rec b : 1S. +{A:(((Skip;?Int);!());b), B: (?Char;b)})})), B: (?Char;(rec b. +{A: (rec b : 1S. +{A: (((Skip;?Int);!());b), B: (?Char;b)})}))})}
1S

forall a: 1S . forall b: 1S . forall z: 1S . ((rec w: 1S. &{B: ((+{A: &{B: a, C: Skip}};(+{A: ?Bool, B: w, C: (?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w))};Skip));+{A: (!Char;(((?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w));?Char);(?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w))))}), C: Skip});(a;((&{B: !Bool, C: Skip};((rec δ: *S. ?());b));(?Int;(+{B: a, C: ?Int};(!Int;Skip))))))
1T

forall a: 1S . forall b: 1S . forall z: 1S . ((rec z: 1S. (Skip;&{B: (+{A: (&{B: a, C: Skip};+{A: (?Bool;Skip), B: (z;Skip), C: (((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);Skip)})};(+{A: !Char};(((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);(?Char;((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z))))), C: Skip}));((a;&{B: (!Bool;(?();b)), C: (Skip;(?();b))});((?Int;+{B: a, C: ?Int});!Int)))
1T

forall a: 1S . forall b: 1S . forall z: 1S . (rec b: 1S.+{A: (b;&{A: (Skip;(rec a: 1S.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a: 1S.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))}), B: (Skip;&{A: (Skip;(rec a: 1S.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a: 1S.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))}), C: (!Bool;&{A: (Skip;(rec a: 1S.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a: 1S.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))})})
1T

-- Forall

∀ a . a -> a -> a -- Boolean type as Church Encoding
1T

∀ a : *M . a
1T

forall a : *M . a
1T

∀ a : *T . a -> a
1T

∀ a : 1T . a 1-> Int
1T

∀ a : *T . a 1-> Int
1T

∀ a : *T . a -> Int
1T

∀ a : 1S . a -> Int
1T

∀ a : 1S . rec b : *T . a -> b
1T

∀ a : 1S . (rec a : 1S . !Int;a) -> a
1T

∀ a : 1S . Skip
1T

∀ a : *T . a -> Int
1T

Int -> ∀ a : *T . a
1T

(Int, ∀ a : 1M . a)
1T

Bool -> ∀ a : 1S . (rec a : 1S . !Int;a) -> a
1T

-- Dualof

-- TODO: this should be OK
-- rec a . dualof !Int
-- 1S

dualof Skip
*S

dualof (Skip; Skip)
1S

dualof (rec a. Skip)
*S

rec a. dualof Skip
*S

rec y: 1S .             +{B: !(), C: !Bool} ; (+{A: y;!(), C: !()} ; y)
1S

rec x: 1S . rec y: 1S .  +{B: !(), C: !Bool} ; ((+{A: y, C: Skip};!())  ; x)
1S
