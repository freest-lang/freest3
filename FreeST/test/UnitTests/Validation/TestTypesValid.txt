Int
TU

Bool
TU

Char
TU

()
TU

Skip
SU

!Int
SL

!Char
SL

?Bool
SL

?Char
SL

Int -> Bool
TU

Int -o Bool
TL

Char -> Skip
TU

Char -o Skip
TL

(Int,Bool)
TU

!Int;?Bool
SL

Skip;Skip
SL

!Int;Skip
SL

Skip;+{S:Skip,I:!Int}
SL

-- Pairs

(Int, Bool) 
TU

(Int -> Bool, Char -> (Bool -> Char)) 
TU

(Skip, Bool) 
TU

(Bool, Skip) 
TU

(Int, Bool) 
TL

(Int -> Bool, Char -> (Bool -> Char)) 
TL

(Skip, Bool) 
TL

(Bool, Skip) 
TL

(!Bool, ?Int)
TL

(!Bool, Int -o Char)
TL

(!Bool -o Int -o Char, ?Int;&{A:Skip, B:!Bool})
TL

(Bool, ?Int)
TL

(Skip, Skip -o Skip)
TL

(Bool -> Char -> Int, ?Int -o Bool -> Int)
TL

(!Bool, Int)
TL

(!Bool, Skip)
TL

(Bool -o Char -> (Int -> ()), Int -> Skip -> ())
TL

rec b:SL. !Bool ; Skip
SL

-- Recursive types

rec a : SL . ?Bool
SL

rec a : SL . (!Int; Skip; ?Int)
SL
  
rec tree : SL . &{Leaf: Skip, Node: ?Int;tree;tree}
SL
  
rec treeChannel : SL . +{Leaf: Skip, Node: !Int;treeChannel;treeChannel}
SL
  
forall a:SL .  rec alpha : SL . !Int ; rec treeChannel1 : SL . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : SL . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};a
TL

forall a:SL . rec alpha : SL . !Int ; rec treeChannel1 : SL . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : SL . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};a
TL

rec a : TU . (a, Int)
TL

rec b : TU . (b, Int -> Char)
TL

rec a : TL . a -o a
TL

-- Terminated Recursive Types

rec a:SL. Skip
SL

rec a:SL. Skip
SU

rec a:SL. (Skip; Skip)
SL

rec a:SL. rec b:SL. Skip
SL

rec a:SL. (Skip; rec b:SL. Skip)
SL

Skip; rec a:SU. Skip
SL

Skip; rec a:SU. Skip; Skip
SL

Skip; rec a:SU. rec b:SL. Skip
SL

Skip; Skip; rec a:SU. (Skip; rec b:SL. Skip)
SL

forall b:SL . rec a:SL. b
TL

forall a:SL . rec d:SL. rec c:SL. rec b : SL. a
TL

rec a . (a, Int)
TU

--Session types generated by Quick Check

forall a:SL . forall b:SL . forall z:SL . !Bool;(((!Int;Skip);(Skip;+{A: b, B: Skip}));(Skip;(rec b_0:SU. (&{A: ((?Char;(Skip;a));Skip), C: !Bool};Skip))))
TL

forall a:SL . forall b:SL . forall z:SL . !Bool;((!Int;+{A: b, B: Skip});(rec b_1:SU. &{A: ((?Char;Skip);a), C: !Bool}))
TL

-- forall a:SL . forall b:SL . forall z:SL . &{B: (&{C: (rec a_8:SL. (rec a_9:SL. (((+{A: b, C: z};?Bool);+{B: Skip, C: ?Bool});+{A: (rec a_10:SL. (rec b_11:SL. (rec b_12:SL. !()))), C: (Skip;Skip)})))};(((rec z_13:SL. +{B: ((Skip;(Skip;(Skip;(a;?Bool))));(?Bool;(Skip;!())))});(rec b_14:SL. !()));?Bool)), C: (?Char;(((rec b_15:SL. (Skip;((Skip;z);((b_15;(a;a));(Skip;(Skip;!()))))));Skip);+{A: (?Int;(&{B: Skip};(b;Skip)))}))}
-- TL

(rec b . +{A: (rec b . (rec a : SL . (+{A: (Skip;(?Int;!())), B: (Skip;?Char)};a)))})
SL

+{A: (rec b. +{A: (((Skip;?Int);!());(rec b . +{A: (rec b : SL. +{A:(((Skip;?Int);!());b), B: (?Char;b)})})), B: (?Char;(rec b. +{A: (rec b : SL. +{A: (((Skip;?Int);!());b), B: (?Char;b)})}))})}
SL

forall a:SL . forall b:SL . forall z:SL . ((rec w:SL. &{B: ((+{A: &{B: a, C: Skip}};(+{A: ?Bool, B: w, C: (?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w))};Skip));+{A: (!Char;(((?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w));?Char);(?Int;(&{A: ((?();(a;w));((Skip;+{A: w, C: Skip});!Int)), C: !Char};w))))}), C: Skip});(a;((&{B: !Bool, C: Skip};((rec δ:SU. ?());b));(?Int;(+{B: a, C: ?Int};(!Int;Skip))))))
TL

forall a:SL . forall b:SL . forall z:SL . ((rec z:SL. (Skip;&{B: (+{A: (&{B: a, C: Skip};+{A: (?Bool;Skip), B: (z;Skip), C: (((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);Skip)})};(+{A: !Char};(((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);(?Char;((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z))))), C: Skip}));((a;&{B: (!Bool;(?();b)), C: (Skip;(?();b))});((?Int;+{B: a, C: ?Int});!Int)))
TL

forall a:SL . forall b:SL . forall z:SL . (rec b:SL.+{A: (b;&{A: (Skip;(rec a:SL.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a:SL.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))}), B: (Skip;&{A: (Skip;(rec a:SL.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a:SL.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))}), C: (!Bool;&{A: (Skip;(rec a:SL.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a:SL.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Bool;&{A: (Skip;a), C:(b;a)})}))})})
TL

-- Forall

∀ a . a -> a -> a -- Boolean type as Church Encoding
TL

∀ a : TL . a
TL

forall a : TL . a
TL

∀ a : TU . a -> a
TL

∀ a : TL . a -o Int
TL

∀ a : TU . a -o Int
TL

∀ a : TU . a -> Int
TL

∀ a : SL . a -> Int
TL

∀ a : SL . rec b : TU . a -> b
TL

∀ a : SL . (rec a : SL . !Int;a) -> a
TL

∀ a : SL . Skip
TL

∀ a : TU . a -> Int
TL

Int -> ∀ a : TU . a
TL

(Int, ∀ a : TL . a)
TL

Bool -> ∀ a : SL . (rec a : SL . !Int;a) -> a
TL

-- Dualof

-- TODO: this should be OK
-- rec a . dualof !Int
-- SL

dualof Skip
SU

dualof (Skip; Skip)
SL

dualof (rec a. Skip)
SU

rec a. dualof Skip
SU

rec y:SL .             +{B: !(), C: !Bool} ; (+{A: y;!(), C: !()} ; y)
SL

rec x:SL . rec y:SL . +{B: !(), C: !Bool} ; ((+{A: y, C: Skip};!())  ; x)
SL

-- Messages not of kind ML

!(Int, Bool)
SL

!(!Int; ?Bool)
SL

rec a:SL . ?(!Int; a)
SL

-- Shared channels, special syntax

*!Int
SU

*?Int
SU

*?(rec x:SL . rec y:SL . +{B: !(), C: !Bool} ; ((+{A: y, C: Skip};!())  ; x))
SU

*+{One, Two}
SU

*&{One, Two}
SU

*&{Mon, Tue, ed, Thu, Fri, Sat, Sun}
SU

-- Shared channels, raw syntax

rec a:SU . !Int; a
SU

rec a:SU . ?Int; a
SU

rec a:SU . +{One: a, Two: a}
SU

rec a:SU . &{One: a, Two: a}
SU
