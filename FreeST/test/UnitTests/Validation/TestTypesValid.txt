Int
*T

Int
*T

Float
*T

Char
*T

()
*T

Skip
*S

!Int
1S

!Float
1S

!Char
1S

?Int
1S

?Char
1S

Int -> Int
*T

Int 1-> Int
1T

Char -> Skip
*T

Char 1-> Skip
1T

(Int,Int)
*T

!Int;?Int
1S

Skip;Skip
1S

!Int;Skip
1S

Skip;+{S:Skip,I:!Int}
1S

-- Pairs

(Int, Int) 
*T

(Int -> Int, Char -> (Int -> Char)) 
*T

(Skip, Int) 
*T

(Int, Skip) 
*T

(Int, Int) 
1T

(Int -> Int, Char -> (Int -> Char)) 
1T

(Skip, Int) 
1T

(Int, Skip) 
1T

(!Int, ?Int)
1T

(!Int, Int 1-> Char)
1T

(!Int 1-> Int 1-> Char, ?Int;&{A:Skip, B:!Int})
1T

(Int, ?Int)
1T

(Skip, Skip 1-> Skip)
1T

(Int -> Char -> Int, ?Int 1-> Int -> Int)
1T

(!Int, Int)
1T

(!Int, Skip)
1T

(Int 1-> Char -> (Int -> ()), Int -> Skip -> ())
1T

rec b: 1S. !Int ; Skip
1S

-- Recursive types

rec a : 1S . ?Int
1S

rec a : 1S . (!Int; Skip; ?Int)
1S
  
rec tree : 1S . &{Leaf: Skip, Node: ?Int;tree;tree}
1S
  
rec treeChannel : 1S . +{Leaf: Skip, Node: !Int;treeChannel;treeChannel}
1S
  
forall a: 1S .  rec alpha : 1S . !Int ; rec treeChannel1 : 1S . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : 1S . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};a
1T

forall a: 1S . rec alpha : 1S . !Int ; rec treeChannel1 : 1S . +{Leaf:Skip, Node:!Int;treeChannel1;treeChannel1} ; rec treeChannel2 : 1S . +{Leaf:Skip, Node:!Int;treeChannel2;treeChannel2};a
1T

rec a : *T . (a, Int)
1T

rec b : *T . (b, Int -> Char)
1T

rec a : 1T . a 1-> a
1T

forall b: 1S . rec a: 1S. b
1T

forall b: 1S . rec a: 1S. b ; a
1T

forall a: 1S . rec d: 1S. rec c: 1S. rec b : 1S. a
1T

rec a . (a, Int)
*T

rec a . forall b: 1S . a
*T

-- Terminated Recursive Types

rec a: 1S. Skip
1S

rec a: 1S. Skip
*S

rec a: 1S. (Skip; Skip)
1S

rec a: 1S. rec b: 1S. Skip
1S

rec a: 1S. (Skip; rec b: 1S. Skip)
1S

Skip; rec a: *S. Skip
1S

Skip; rec a: *S. Skip; Skip
1S

Skip; rec a: *S. rec b: 1S. Skip
1S

Skip; Skip; rec a: *S. (Skip; rec b: 1S. Skip)
1S

--Session types generated by Quick Check

forall a:1S . forall b:1S . forall z:1S . &{B: (&{C: (rec a_8:1S. (rec a_9:1S. (((+{A: b, C: z};?Int);+{B: Skip, C: ?Int});+{A: (rec a_10:1S. (rec b_11:1S. (rec b_12:1S. !()))), C: (Skip;Skip)})))};(((rec z_13:1S. +{B: ((Skip;(Skip;(Skip;(a;?Int))));(?Int;(Skip;!())))});(rec b_14:1S. !()));?Int)), C: (?Char;(((rec b_15:1S. (Skip;((Skip;z);((b_15;(a;a));(Skip;(Skip;!()))))));Skip);+{A: (?Int;(&{B: Skip};(b;Skip)))}))}
1T

forall a: 1S . forall b: 1S . forall z: 1S . ((rec z: 1S. (Skip;&{B: (+{A: (&{B: a, C: Skip};+{A: (?Int;Skip), B: (z;Skip), C: (((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);Skip)})};(+{A: !Char};(((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z);(?Char;((?Int;&{A: ((((?();a);z);+{A: z, C: Skip});!Int), C: !Char});z))))), C: Skip}));((a;&{B: (!Int;(?();b)), C: (Skip;(?();b))});((?Int;+{B: a, C: ?Int});!Int)))
1T

forall a: 1S . forall b: 1S . forall z: 1S . (rec b: 1S.+{A: (b;&{A: (Skip;(rec a: 1S.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Int;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a: 1S.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Int;&{A: (Skip;a), C:(b;a)})}))}), B: (Skip;&{A: (Skip;(rec a: 1S.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Int;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a: 1S.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Int;&{A: (Skip;a), C:(b;a)})}))}), C: (!Int;&{A: (Skip;(rec a: 1S.+{A: (b;&{A: (Skip;a), C:(b;a)}), B: (Skip;&{A: (Skip;a), C: (b;a)}), C: (!Int;&{A: (Skip;a),C: (b;a)})})), C: (b;(rec a: 1S.+{A: (b;&{A: (Skip;a), C: (b;a)}), B:(Skip;&{A: (Skip;a), C: (b;a)}), C: (!Int;&{A: (Skip;a), C:(b;a)})}))})})
1T

-- Forall

∀ a . a -> a -> a -- Int type as Church Encoding
1T

∀ a : 1T . a
1T

forall a : 1T . a
1T

∀ a : *T . a -> a
1T

∀ a : 1T . a 1-> Int
1T

∀ a : *T . a 1-> Int
1T

∀ a : *T . a -> Int
1T

∀ a : 1S . a -> Int
1T

∀ a : 1S . rec b : *T . a -> b
1T

∀ a : 1S . (rec a : 1S . !Int;a) -> a
1T

∀ a : 1S . Skip
1T

∀ a : *T . a -> Int
1T

Int -> ∀ a : *T . a
1T

(Int, ∀ a : 1T . a)
1T

Int -> ∀ a : 1S . (rec a : 1S . !Int;a) -> a
1T

-- Dualof

dualof Skip
*S

dualof (Skip; Skip)
1S

dualof (rec a. Skip)
*S

rec a. dualof Skip
*S

rec y: 1S .             +{B: !(), C: !Int} ; (+{A: y;!(), C: !()} ; y)
1S

rec x:1S . rec y:1S . +{B: !(), C: !Int} ; ((+{A: y, C: Skip};!())  ; x)
1S

-- Messages of kind other than ML

!(Int, Int)
1S

!(!Int; ?Int)
1S

rec a:1S . ?(!Int; a)
1S

-- Shared channels, special syntax

*!Int
*S

*?Int
*S

*?(rec x:1S . rec y:1S . +{B: !(), C: !Int} ; ((+{A: y, C: Skip};!())  ; x))
*S

*+{One, Two}
*S

*&{One, Two}
*S

*&{Mon, Tue, ed, Thu, Fri, Sat, Sun}
*S

!Int ; *!Int
1S

-- Shared channels, raw syntax

rec a:*S . !Int; a
*S

rec a:*S . ?Int; a
*S

rec a:*S . +{One: a, Two: a}
*S

rec a:*S . &{One: a, Two: a}
*S

!Int ; rec a:*S . !Int ; a
1S

!Int ; !Int ; !Int ; !Int ; rec a:*S . !Int ; a
1S
