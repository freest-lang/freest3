
-- Simple tests

div 50 10
Int

254-231
Int

74 + 36
Int

55555*23
Int

-- succ'
(λx:Int → x+1) 22
Int

-- max'
(λx:Int y:Int → if x >= y then x else y) 17 23
Int

-- min'
(λx:Int y:Int → if x < y then x else y) 17 23
Int

-- pred'
(λx:Int → x-1) 1905
Int

-- id
(Λa: *T => λx:a → x) @Int 5
Int

-- Tuple destructor

-- pairs
let (x, y) = (2, True) in y
Bool

let (x, y) = (2, True) in x 
Int

-- let (x, y, z) = (6, True, 'a') in y
-- Bool

(\x : Int -> x)
Int -> Int

(\x : Int -> (\y : Int -> x + y))
Int -> Int -> Int

-- Send recv same thread

let (w,r) = new !Int in let _ = send 5 w in let (v,_) = receive r in v
Int

-- Sequences of Λ, λ, ∀ abstractions and type applications abbreviated

Λ a => Λ b => λ x:a -> λ y:b -> x
∀ a . ∀ b . a -> b -> a

Λ a b => λ x:a -> λ y:b -> x
∀ a . ∀ b . a -> b -> a

Λ a b => λ x:a -> λ y:b -> x
∀ a b . a -> b -> a

λ n:(∀ a . (a -> a) -> a -> a) -> Λ a => λ s:(a -> a) z:a -> s (n @a s z)
(∀ a . (a -> a) -> a -> a) -> (∀ a . (a -> a) -> a -> a)

(Λa b => λx:a y:b -> Λc => λz:(a -> b -> c) -> z x y) @Int @Bool
Int -> Bool -> ∀c . (Int -> Bool -> c) -> c


-- Lambda applied

(λx:Int → x) 23
Int

(λ_:Bool → λy:Int → y) False 23
Int

-- Rec skip

(\_:(rec x: *S. Skip, Skip) -> λy:Int -> y) (new Skip) 23
Int

(\_:Skip -> λy:Int -> y) (fst @Skip @Skip (new Skip)) 23
Int

-- Substitution

(Λ a:*T => 5)@(Bool,Bool)
Int
