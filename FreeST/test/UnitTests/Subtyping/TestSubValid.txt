-- Atomic top types (reflexivity)

Int 
Int 

Char
Char 

Bool 
Bool 

String
String 

()
()

Skip 
Skip

End
End

-- End 

End;Skip
Skip;End 

End;!Char
End;?Bool 

+{A: End;!Int, B: ?Bool};!Int
+{             B: ?Bool};!Int

+{A: End, B: End};!Int
+{        B: End};?Bool

-- Branch (covariant on width (label set) and depth (matched type))

&{A: !Int}
&{A: !Int}

&{A: !Int         }
&{A: !Int, B: !Int} 

&{A: !Int                  };!Int;!Char
&{A: !Int, B: !Int, C: Skip};!Int;!Char

&{Plus : ?Int;?Int;!Int;End, Eq: ?Int;?Int;!Bool;End}
&{Plus : ?Int;?Int;!Int;End, Eq: ?Int;?Int;!Bool;End}

&{Plus : ?Int;?Int;!Int;End, Eq: ?Int;?Int;!Bool;End                    }
&{Plus : ?Int;?Int;!Int;End, Eq: ?Int;?Int;!Bool;End, Neg: ?Int;!Int;End}

&{A: &{AA: !Int           }}
&{A: &{AA: !Int, AB: ?Bool}}

&{A: +{AA: !Int, AB: ?Bool}}
&{A: +{AB: ?Bool          }}

-- (does not pass with filtering rule, since the norms may differ (e.g. these types have 3 and 5 resp.))
&{A: +{AA: !Int, AB: &{ABA: &{ABAA: !Int             }}}}
&{A: +{          AB: &{ABA: &{ABAA: !Int, ABAB: ?Bool}}}}

-- Choice (contravariant on width (label set), covariant on depth (selected type))

+{A: ?Int}
+{A: ?Int}

+{A: ?Int, B: ?Int}
+{A: ?Int         }

+{Plus : !Int;!Int;?Int;End, Eq: !Int;!Int;?Bool;End, Neg: !Int;?Int;End}
+{Plus : !Int;!Int;?Int;End, Eq: !Int;!Int;?Bool;End, Neg: !Int;?Int;End}

+{Plus : !Int;!Int;?Int;End, Eq: !Int;!Int;?Bool;End, Neg: !Int;?Int;End}
+{Plus : !Int;!Int;?Int;End, Eq: !Int;!Int;?Bool;End                    }

-- Sequential composition (covariant on before and after) 

!Int;?Bool 
!Int;?Bool 

Skip;Skip 
Skip;Skip

Skip;Skip 
Skip;Skip;Skip

&{A: ?Int                   }; +{D: !Int;End}
&{A: ?Int, B: !Bool, C: Skip}; +{D: !Int;End}

&{A: ?Int}; +{D: !Int;Skip, E: Skip;!Bool}
&{A: ?Int}; +{D: !Int;Skip               }

-- (without filtering rule)
&{A: ?Int                   }; +{D: !Int;?Bool, E: Skip;!Bool}
&{A: ?Int, B: !Bool, C: Skip}; +{D: !Int;?Bool               }

-- (without filtering rule)
&{A: ?Int}; +{D: !Int;End, E: Skip;!Bool}
&{A: ?Int}; +{D: !Int;End               }

-- (without filtering rule)
&{A: ?Int                   }; +{D: !Int;End, E: Skip;!Bool}
&{A: ?Int, B: !Bool, C: Skip}; +{D: !Int;End               }

-- Output (contravariant) 

!(&{A: !Int})
!(&{A: !Int})

!(+{A: ?Int})
!(+{A: ?Int})

!(&{A: !Int, B: !Int})
!(&{A: !Int         })

!(+{A: ?Int         })
!(+{A: ?Int, B: ?Int})

!(Int 1-> Int)
!(Int  -> Int)

-- Input (covariant)

?(&{A: !Int})
?(&{A: !Int})

?(+{A: ?Int})
?(+{A: ?Int})

?(&{A: !Int         })
?(&{A: !Int, B: !Int})

?(+{A: ?Int, B: ?Int})
?(+{A: ?Int         })

-- Arrow (contravariant on domain, covariant on range and multiplicity)

+{A: !Int} -> +{B: ?Bool}
+{A: !Int} -> +{B: ?Bool}

+{A: !Int         } -> +{A: !Int, B: !Int}
+{A: !Int, B: !Int} -> +{A: !Int         }

&{A: !Int, B: !Int} -> &{A: !Int         }
&{A: !Int         } -> &{A: !Int, B: !Int}

!(+{A:!Int, B:?Char}) -> !(+{A:!Int})
!(+{A:!Int}) -> !(+{A:!Int, B:?Char})

+{A: !Int} 1-> +{B: ?Bool}
+{A: !Int} 1-> +{B: ?Bool}

+{A: !Int         } 1-> +{A: !Int, B: !Int}
+{A: !Int, B: !Int} 1-> +{A: !Int         }

+{A: !Int} -> +{B: ?Bool}
+{A: !Int} 1-> +{B: ?Bool}

&{A: !Int, B: !Int} -> &{A: !Int         }
&{A: !Int         } 1-> &{A: !Int, B: !Int}

!(+{A:!Int, B:?Char}) -> !(+{A:!Int})
!(+{A:!Int}) 1-> !(+{A:!Int, B:?Char})

-- Pair (covariant on first and second) 

(Int, Int)
(Int, Int)

(+{A: !Bool, B:?Char}, Int)
(+{A: !Bool, B:?Char}, Int)

(Int, +{A: !Bool, B:?Char})
(Int, +{A: !Bool         })

(&{A: ?Bool         }, +{A: !Bool, B:?Char})
(&{A: ?Bool, B:!Char}, +{A: !Bool         })

(&{A: ?Bool         }, +{A: !(+{A: !Bool          }), B:?Char})
(&{A: ?Bool, B:!Char}, +{A: !(+{A: !Bool, B: ?Char})         })

(Int -> Bool, Bool -> Int)
(Int 1-> Bool, Bool 1-> Int)

(Int -> Bool, !(+{A: !Int, B: ?Bool}) -> Int)
(Int -> Bool, !(+{A: !Int          }) -> Int)

-- Recursive types 

-- original
rec x . (+{A: Skip         } -> (+{A: Skip, B: Skip}, x))
rec x . (+{A: Skip, B: Skip} -> (+{A: Skip         }, x))

-- unfold first
+{A: Skip} -> (+{A: Skip, B: Skip}, (rec x . (+{A: Skip} -> (+{A: Skip, B: Skip}, x))))
rec x . (+{A: Skip, B: Skip} -> (+{A: Skip         }, x))

-- unfold second
rec x . (+{A: Skip} -> (+{A: Skip, B: Skip}, x))
+{A: Skip, B: Skip} -> (+{A: Skip}, (rec x . (+{A: Skip, B: Skip} -> (+{A: Skip}, x))))

-- original
rec l:1S . +{Cons: ?(+{A:!Int, B:!Int});l, Nil: Skip}
rec l:1S . +{Cons: ?(+{A:!Int});l, Nil: Skip}

-- unfold first
+{Cons: ?(+{A:!Int, B:!Int});(rec l:1S . +{Cons: ?(+{A:!Int, B:!Int});l, Nil: Skip}), Nil: Skip}
rec l:1S . +{Cons: ?(+{A:!Int});l, Nil: Skip}

-- unfold second
rec l:1S . +{Cons: ?(+{A:!Int, B:!Int});l, Nil: Skip}
+{Cons: ?(+{A:!Int});(rec l:1S . +{Cons: ?(+{A:!Int});l, Nil: Skip}), Nil: Skip}

-- original
rec l:1S . +{Cons: !(+{A:!Int});l, Nil: Skip}
rec l:1S . +{Cons: !(+{A:!Int, B:!Int});l, Nil: Skip}

-- unfold first
+{Cons: !(+{A:!Int});(rec l:1S . +{Cons: !(+{A:!Int});l, Nil: Skip}), Nil: Skip}
rec l:1S . +{Cons: !(+{A:!Int, B:!Int});l, Nil: Skip}

-- unfold second
rec l:1S . +{Cons: !(+{A:!Int});l, Nil: Skip}
+{Cons: !(+{A:!Int, B:!Int});(rec l:1S . +{Cons: !(+{A:!Int, B:!Int});l, Nil: Skip}), Nil: Skip}

-- original 
rec l:1S . +{Cons: ?(Int  -> Int);l, Nil: Skip}
rec l:1S . +{Cons: ?(Int 1-> Int);l, Nil: Skip}

-- unfold first 
+{Cons: ?(Int  -> Int);(rec l:1S . +{Cons: ?(Int  -> Int);l, Nil: Skip}), Nil: Skip}
rec l:1S . +{Cons: ?(Int 1-> Int);l, Nil: Skip}

-- unfold second
rec l:1S . +{Cons: ?(Int  -> Int);l, Nil: Skip}
+{Cons: ?(Int 1-> Int);(rec l:1S . +{Cons: ?(Int 1-> Int);l, Nil: Skip}), Nil: Skip}

-- original
rec l:1S . +{Cons: !(Int 1-> Int);l, Nil: Skip}
rec l:1S . +{Cons: !(Int  -> Int);l, Nil: Skip}

-- unfold first
+{Cons: !(Int 1-> Int);(rec l:1S . +{Cons: !(Int 1-> Int);l, Nil: Skip}), Nil: Skip}
rec l:1S . +{Cons: !(Int  -> Int);l, Nil: Skip}

-- unfold second 
rec l:1S . +{Cons: !(Int 1-> Int);l, Nil: Skip}
+{Cons: !(Int  -> Int);(rec l:1S . +{Cons: !(Int  -> Int);l, Nil: Skip}), Nil: Skip}

-- original
!(rec l:1S . +{Cons: !(Int  -> Int);l, Nil: Skip})
!(rec l:1S . +{Cons: !(Int 1-> Int);l, Nil: Skip})

-- unfold first 
!(+{Cons: !(Int  -> Int);(rec l:1S . +{Cons: !(Int  -> Int);l, Nil: Skip}), Nil: Skip})
!(rec l:1S . +{Cons: !(Int 1-> Int);l, Nil: Skip})

-- unfold second
!(rec l:1S . +{Cons: !(Int  -> Int);l, Nil: Skip})
!(+{Cons: !(Int 1-> Int);(rec l:1S . +{Cons: !(Int 1-> Int);l, Nil: Skip}), Nil: Skip})

rec i:1S . Skip
Skip

rec x:1S . !x
!(rec x:1S . !x)

-- are free variables ok in these tests? should we check type formation?
rec h:1S . !((+{B: End, C: b} ; Skip) ; +{C: h} ; End ; Skip)
!(+{B: End ; Skip, C: b ; Skip} ; +{C: (rec h:1S . !(+{B: End ; Skip, C: b ; Skip} ; +{C: h ; End ; Skip})) ; End ; Skip})