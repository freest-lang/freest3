\section{Correctness of the algorithm}
\label{sec:correctness}

In this section we prove that our algorithm is sound and complete
with respect to the meta-theory of context-free session types proposed
by Thiemann and Vasconcelos~\cite{thiemann2016context}.
%
We start by showing a full abstraction result between context-free
session types and grammars in Greibach normal form.
%
Then, based on results from Caucal~\cite{caucal1986decidabilite},
Christensen, H{\"{u}}ttel, and
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}, Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques}, we conclude that our algorithm is
sound and complete.

\paragraph{Type translation is fully abstract}

Sections~\ref{sec:contextfreesession} and~\ref{sec:algorithm}
introduce bisimulation relations on the set of $\mathcal T$ types
$\TypeEquiv$ and on a given set $\productions$ of productions
$\ProdEquiv$.  Our ultimate goal in this subsection is to prove that
we can faithfully analyze the bisimilarity of types by analyzing the
bisimilarity of the corresponding grammar. For this purpose, we prove
that the translation proposed in Section~\ref{sec:algorithm} is a
\emph{fully abstract encoding}, i.e., preserves the bisimilarity
relation~\cite{gorla2016full}.

% Recall from Section~\ref{sec:algorithm} that function $\toGrammark$ 
% runs under a monadic context
% \lstinline|TransState|, suitably initialised.
% %
% The monadic state comprises the productions and an integer to generate
% fresh variables.
% %
% We allow ourselves a slight abuse of notation and write
% $\vec Y = \toGrammarf S$ to denote the result of running function
% $\toGrammark$ on input~$S$, under a suitable monadic context.
% %
% Empty lists are denoted in Haskell by \lstinline|[]|;
% in formal languages symbol $\varepsilon$ is used to denote the empty
% word; we use both symbols interchangeably.

We start with a lemma that relates terminated types~$T$ to the result 
of a call to $\word(T)$. Throughout this section, we 
will abuse notation and denote by $\word(S)$ the start word for $S$.

\begin{lemma}
  \label{lemma:terminated-togrammar}
  Let $\isType[] T$. Then, $\DONE T$ if and only if
  $\word(T) = \varepsilon$.
\end{lemma}
%
\begin{proof}
  The direct implication follows by rule induction on
  predicate~$\DONE$.
  \begin{itemize}
  \item If $T \triangleq \skipk$, then $\word(T) = \varepsilon$.
  \item If $T\triangleq U;V$, then the premises of the rule read
    $\DONE{U}$ and $\DONE{V}$. Then, by induction hypothesis,
    $\word(U) = \varepsilon$ and $\word(V) = \varepsilon$. Hence,
    $\word(T;U) = \varepsilon$.
  \item If $T\triangleq \mu X.S$ then the premises of $\isType[]T$ and
    $\DONE T$ are contradictory on~$S$.
  \item If $T=X$, then $\neg \isType[]T$.
  \end{itemize}
  %
  Conversely, if $\word(T) = \varepsilon$, then by definition of
  $\word$:
  \begin{itemize}
  \item $T\triangleq \skipk$ and we have $\DONE T$;
  \item $T\triangleq U;V$ and the inversion of the function reads
    $\word(U) = \varepsilon$, $\word(V) = \varepsilon$.  Thus, by
    induction, we have $\DONE U$ and $\DONE V$. Hence, $\DONE T$;
  \item No other case in function $\word$ produces an empty word.
  \end{itemize}
\end{proof}

% To be able to use induction in the proof of 
% the key result of this section
% (Lemma~\ref{lem:transitions_mimic}), we use
% the unravelling function proposed 
% by Thiemann and Vasconcelos~\cite{thiemann2016context}:
% \[\begin{aligned}
% \Unravel(\mu X . S) &= \Unravel(\subs{\mu X.S}{X} S)\\
% \Unravel(S_1;S_2) &= 
% \begin{cases}
% 	\Unravel(S_2) & \text{if }\Unravel(S_1)=\skipk\\
% 	\Unravel(S_1);S_2 & \text{otherwise}\\
% \end{cases} \\
% \Unravel(S)&= S \text{  for all other cases}
% \end{aligned}\]
% %
% Notice that for any recursive (well-formed) ttype 
% $\mu X.S$, $\Unravel(\mu X.S)$ is not a recursive type.
% The following lemma states that $\Unravel(\mu X.S)$ preserves 
% the transitions from $\mu X.S$.

\vv{Redo (start)}

\begin{lemma}
  \label{lemma:unravelling}
  $\mu X. S \LTSderives[a] S'$ if and only if $\Unravel (\mu X. S) \LTSderives[a] S'$.
\end{lemma}
%
\begin{proof}
%  By Lemma 3.5 of~\cite{thiemann2016context}, we have
%  $\mu X.S \TypeEquiv S[\mu X. S / X]$. We thus have
%  $\mu X.S \TypeEquiv \Unravel (\mu X. S)$ and the result follows
%  immediately.
	Observing that $\Unravel(\mu X. S) = \Unravel(\subs{\mu X.S}{X}{S}$),
	it follows from the LTS.
\end{proof}

%Furthermore, the analogous result for grammars follows
%by definition of \toGrammark\ and \lstinline|collect|.
%
%\begin{lemma}
%\label{lemma:unravelling_preserves_grammars}
%	$\toGrammarf{(\mu X.S)} = \toGrammarf{(\Unravel (\mu X. S))}$.
%\end{lemma}

The following result states that grammars produced by
$\word$ mimic the transitions of the corresponding types
and vice-versa.

\newcommand{\grmcontext}{
  $(\vec X, \productions') = \grm(S, \emptyset)$ and 
  $(\vec Y, \productions) = \grm(T, \productions')$%
}

\begin{lemma}
  \label{lem:transitions_mimic}
  $S \LTSderives T$ if and only if $\vec X \LTSderivesP \vec Y$, 
  where \grmcontext.
\end{lemma}
%
\begin{proof}
	For the direct implication and using the unravelling
	function on recursive types, we can proceed by induction
	on the structure of the types. 
	
	\begin{itemize}
		%\item $S\triangleq\skipk$ does not have any transition. And
		%neither does $\toGrammarf{\skipk} = \varepsilon$.
		\item $S\triangleq\sharp B$ is such that $S \LTSderives[\sharp B] \skipk$.
		Similarly, $\word(S) \LTSderivesP[\sharp B] \varepsilon$.
		\item $S\triangleq\star\{l_i\colon S_i\}_{i\in I}$ is such that, for each $i\in I$,
		$S \LTSderives[\star l_i] S_i$. By definition of $\grm$, for each $i$, 
		$\word(S) \LTSderivesP[\star l_i] \word(S_i)$.
		\item $S\triangleq S_1;S_2$:
		\begin{itemize}
			\item if $S_1;S_2\LTSderives S_1';S_2$ with $S_1\LTSderives S_1'$,
			by induction hypothesis, we know that $\word(S_1) \LTSderivesP \word(S_1')$.
			Furthermore, for any types $S$ and $T$ we have
			\begin{equation}
			\label{eq:grammar_sequential_composition}
				\word(S;T) = \word(S)\cdot\word(T).	
			\end{equation}
			Hence, we have $\word(S_1;S_2) \LTSderivesP \word(S_1';S_2)$.
			\item assume $S_1;S_2\LTSderives S_2'$ where 
				$\DONE{S_1}$ and $S_2\LTSderives S_2'$.
			Since $\DONE{S_1}$, 
			by~\eqref{eq:grammar_sequential_composition} and
			Lemma~\ref{lemma:terminated-togrammar}, 
			we have $\word(S_1;S_2) = \word(S_2)$.
			Thus, by induction hypothesis we have 
			$\word(S_1;S_2) \LTSderivesP \word(S_2').$
		\end{itemize}
		\item $S\triangleq\mu X.T$. If $S\LTSderives S'$, by Lemma~\ref{lemma:unravelling},
		we have $\Unravel\ S \LTSderives S'$ and $\Unravel\ S$ is not a recursive
		type, hence by induction hypothesis, we have
		$\word(\Unravel\ S)\LTSderivesP \word(S')$.
		By definition of $\grm(S,\emptyset)$, we thus have
		$\word(S) = X \LTSderivesP \word(S')$. \smallskip
	\end{itemize}
	For the reverse implication, we prove that any transition in the
	grammar leads to a transition in the corresponding types.
	\begin{itemize}
		\item if $\word(S)\LTSderivesP[\sharp B] \vec X$, then
		$\word(S) = Y \vec X$, where $Y\LTSderivesP[\sharp B] \varepsilon$,
		and so $\Unravel(S) = \sharp B; T$ where $S\LTSderives[\sharp B] T$.
		\item if $\word(S) \LTSderivesP[\star l_i] \vec X $, then
		$\word(\Unravel(S)) = Y $, where $Y\LTSderivesP[\star l_i] \vec Y'$
		and $\vec X = \vec Y' \vec Z$.
		Hence, $\Unravel (S)$ is of the form $\star\{l_j' :U_j\}_{j\in J};T$ with $l_i = l_j'$ and
		$\vec Y' = \word(U_j)$, for some $j\in J$. Using 
		the LTS we conclude that 
		$S \LTSderives[\star l_i] U_j ; T$.
	\end{itemize}
\end{proof}

The main result of this subsection follows from
Lemma~\ref{lem:transitions_mimic}.

\begin{theorem}
  \label{thm:equiv_coincide}
  Let \grmcontext. Then, $\grm$ is a full abstract encoding, i.e.,
  $S \TypeEquiv T$ if and only if $\vec X \ProdEquiv \vec Y$.
\end{theorem}

\begin{proof}
For the direct implication, assume that $S \TypeEquiv T$ and let
$\mathcal{B}$ be a bisimulation for $S$ and $T$. Then, consider 
$ \mathcal{B}' = 
\{(\word (S_0), \word(T_0))\mid (S_0,T_0)\in \mathcal{B} \}. $
Obviously, $(\word(S), \word(T))\in \mathcal{B}'$. To prove that
$\mathcal{B}'$ is a bisimulation, one assumes that 
$\word (S_0)\LTSderivesP \vec X $ and proves that there exists
$\vec Y$ such that $\word (T_0)\LTSderivesP \vec Y $
with $(\vec X, \vec Y)\in \mathcal{B}'$. This proof follows 
as usual by coinduction on the structure of $S_0$, uses 
Lemmas~\ref{lemma:terminated-togrammar}
and \ref{lem:transitions_mimic}, the definition of $\word$
and the definition of $\mathcal{B}'$. \smallskip\\
For the reverse implication, assume that 
$\vec X \ProdEquiv \vec Y$, with $\vec X = \word (S)$ and
$\vec Y = \word(T)$ and let $\mathcal{B}'$ be a bisimulation
for $\vec X$ and $\vec Y$. Then, consider
$\mathcal{B} = \{(S_0, T_0)\mid (\word(S_0),\word(T_0))\in \mathcal{B}'\}$.
Notice that $(S,T)\in \mathcal{B}$.
The proof that $\mathcal{B}$ is a bisimulation, consists in proving that:
given $(S_0, T_0)\in \mathcal{B}$, such that $S_0\LTSderives S_0'$,
there exists $T_0'$ such that $T_0\LTSderives T_0'$
and $(S_0',T_0')\in \mathcal{B}$. Again, the proof
follows by coinduction on the structure of $S_0$. 
We omit the details. 
\end{proof}


\paragraph{Correctness of the algorithm}

We now focus on the correctness of function $\bisim$.  Before
proceeding to soundness, we recall the \emph{safeness property}
introduced by Jan{\v{c}}ar and Moller~\cite{janvcar1999techniques}.

\begin{lemma} [Safeness Property]
  \label{lem:safeness}
  $\vec X \ProdEquiv \vec Y$ if and only if the expansion tree rooted
  at $\{(\vec X, \vec Y)\}$ has a successful branch.
\end{lemma}

Notice that function $\bisim$ builds an expansion tree by alternating
between simplification---reflexive, congruence, and \BPA---and
expansion operations, as proposed by Jan{\v{c}}ar and Moller.
%
These simplification rules are
\emph{safe}~\cite{janvcar1999techniques}, in the sense that the
application of any rule preserves the bisimulation from a parent node
to at least one child node and, reciprocally, that bisimulation on a
child node implies the bisimulation of its parent node, thus proving
the safeness property.

While the safeness property is instrumental in proving
soundness, the \emph{finite witness property} is of
utmost importance to prove completeness. This result follows
immediately from the analysis by Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques}, which capitalizes on results by
Caucal~\cite{caucal1986decidabilite}, and Christensen, H{\"{u}}ttel, and
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}:

\begin{lemma} [Finite Witness Property]
\label{lem:finite_witness}
	If $\vec X \ProdEquiv \vec Y$, then the expansion tree rooted at
	$\{(\vec X, \vec Y)\}$ has a finite successful branch.
\end{lemma}

We refer to Caucal, Christensen, H{\"{u}}ttel, and Stirling for
details on the proof of existence of a finite witness, as stated in
Lemma~\ref{lem:finite_witness}. This proof is particularly interesting in
that it highlights the importance of the BPA rules and of pruning
productions on reaching such (finite) witness. The results in these
two papers also allow elucidate the reason for the distinction, in
the simplification phase, between the cases where all the symbols in
the grammar are and are not normed (cf.~program variable
$\mathsf{rules}$ in function $\expand$).
%
The safeness and finite witness properties ensure the termination of
the algorithm, its soundness and completeness.

\begin{lemma}[Termination]
  \label{lem:termination}
  Let \grmcontext. Then, the computation of $\Bisim(\vec X,\vec Y)$
  always terminates.
\end{lemma}
%
\begin{proof}
  If $S\TypeEquiv T$ then, by Theorem~\ref{thm:equiv_coincide}, we
  have $\word(S) \ProdEquiv \word(T) $ and thus the existence of a
  finite successful branch is ensured by the finite witness property
  (Lemma~\ref{lem:finite_witness}).  Hence, breadth-first search
  eventually terminates.
  
  When $S\not\TypeEquiv T$, we easily conclude that all branches in
  the expansion tree are finite and thence $\Bisim(\vec X,\vec Y)$
  terminates.  To conclude that all branches are finite, observe that
  any infinite branch is successful by definition and thus the
  safeness property implies $\word(S) \ProdEquiv \word(T)$ and we have
  $S\TypeEquiv T$, by Theorem~\ref{thm:equiv_coincide}.
\end{proof}

%\begin{proof}
%	On the other hand, as observed in~\cite{janvcar1999techniques},
%	the union of nodes along a successful branch is a relation $R$
%	such that $R\subseteq \ProdEquiv$. Hence, any pair $(\vec X, \vec Y)$
%	occurring along a successful branch is such that $\vec X \ProdEquiv \vec Y$,
%	which, by Lemma~\ref{lemma:filtering}, means that $|\vec X|=|\vec Y|$.
%	So, the filtering rule would node exclude any node in the successful branch
%	and, then, also preserved the safeness property.
%\end{proof}

\begin{lemma}
  \label{lem:bisimilar-to-prod}
  Let \grmcontext.  If $\Bisim(\vec X,\vec Y)$ returns $\True$, then
  $\word(S) \ProdEquiv \word(T)$.
\end{lemma}

\begin{proof}
  Function $\Bisim$ returns $\True$ whenever it reaches a (finite)
  successful branch in the expansion tree rooted at
  $\{(\vec X,\vec Y)\}$. Conclude with the safeness property,
  Lemma~\ref{lem:safeness}.
  % , whenever the expansion tree rooted
  % at $\{(X_{S}, X_{T})\}$ has a (finite) successful branch, we
  % kn that $X_{S} \ProdEquiv X_{T}$.
\end{proof}

From the previous results, the soundness of our algorithm is now
immediate: the algorithm to check the bisimulation of context-free
session types (Listing~\ref{lst:algorithm}) is sound with respect to
the meta-theory of context-free session types.

\begin{theorem}[Soundness]
  \label{thm:soundness}
  Let \grmcontext.  If $\Bisim(\vec X,\vec Y)$ returns $\True$ then
  $S\TypeEquiv T$.
\end{theorem}
%
\begin{proof}
  From Theorem~\ref{thm:equiv_coincide} and
  Lemma~\ref{lem:bisimilar-to-prod}.
\end{proof}

% \begin{corollary}
% 	If $S\not\TypeEquiv T$ then $\bisimf ST$ returns \upshape{\lstinline|False|}.
% \end{corollary}
% %
% \begin{proof}
% 	From Theorem~\ref{thm:soundness} and Lemma~\ref{lemma:terminates}.
% \end{proof}
 
Given that the algorithm terminates (Lemma~\ref{lem:termination}), we
know that if $S\not\TypeEquiv T$, then $\bisimf ST$ returns
\lstinline|False|.
%
We now show that the algorithm to check the bisimulation of
context-free session types is complete with respect to the meta-theory
of context-free session types. The finite witness property is
paramount to achieve this result.

\begin{theorem}[Completeness]
\label{thm:completeness}
  If $S \TypeEquiv T$ then $\bisimf S T$ returns
  \upshape{\lstinline|True|}.
\end{theorem}
%
\begin{proof}
  Assuming that $S \TypeEquiv T$, by Theorem~\ref{thm:equiv_coincide}
  we have $\vec X \ProdEquiv \vec Y$.  Hence,
  Lemma~\ref{lem:finite_witness} ensures the existence of a finite
  successful branch on the expansion tree rooted at
  $\{(\vec X,\vec Y)\}$, i.e., a branch terminating in an empty
  node.  Since our algorithm traverses the expansion tree using
  breadth-first search it will, eventually, reach the empty node and
  conclude the bisimulation positively.
\end{proof}

Theorem~\ref{thm:completeness} ensures that if $\Bisim(\vec X,\vec Y)$
returns $\False$ then $S \not\TypeEquiv T$. \vv{porquÃª importante?}

% \begin{corollary}
% 	If $\bisimf ST$ returns \upshape{\lstinline|False|} then $S\not\TypeEquiv T$.
% \end{corollary}
% %
% \begin{proof}
% 	From Theorem~\ref{thm:completeness}.
% \end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
