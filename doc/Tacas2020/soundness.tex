\section{Correctness of the algorithm}
\label{sec:correctness}

In this section we prove that function $\BisimT$ is sound and complete
with respect to the meta-theory of context-free session types.
%
We start by showing a full abstraction result between context-free
session types and grammars in Greibach Normal Form.
%
Then, based on results from Caucal~\cite{caucal1986decidabilite},
Christensen, H{\"{u}}ttel, and
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}, Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques}, we conclude that the algorithm 
we propose is sound and complete.

\subsection{Type translation is fully abstract}

Sections~\ref{sec:contextfreesession} and~\ref{sec:algorithm}
introduce bisimulation relations on the set $\mathcal T$ of types
$\TypeEquiv$ and on a given set $\productions$ of productions
$\ProdEquiv$.  Our ultimate goal in this subsection is to prove that
we can faithfully analyze the bisimilarity of types by analyzing the
bisimilarity of the corresponding grammar. For this purpose, we prove
that the translation proposed in Section~\ref{sec:algorithm} is a
\emph{fully abstract encoding}, i.e., preserves the bisimilarity
relation. %~\cite{gorla2016full}.

We start proving that the transformation of types to grammars preserves
the labelled transitions.
% Throughout this section, we abuse notation and denote by $\word(S)$
% the start word for $S$.
%
%\begin{lemma}
%  \label{lemma:unravelling}
%  $\mu X. S \LTSderives[a] S'$ if and only if
%  $\Unravel (\mu X. S) \LTSderives[a] S'$.
%\end{lemma}
%%
%\begin{proof}
%%  By Lemma 3.5 of~\cite{thiemann2016context}, we have
%%  $\mu X.S \TypeEquiv S[\mu X. S / X]$. We thus have
%%  $\mu X.S \TypeEquiv \Unravel (\mu X. S)$ and the result follows
%%  immediately.
%  Observing that
%  $\Unravel(\mu X. S) = \Unravel(\subs{\mu X.S}{X}{S}$), the result
%  follows from the LTS.
%\end{proof}
%
The following result states that grammars produced by
$\grm$ mimic the transitions of the corresponding types
and vice-versa.

\newcommand{\grmcontext}{
  $(\vec X, \productions') = \grm(S, \emptyset)$ and 
  $(\vec Y, \productions) = \grm(T, \productions')$%
}

\begin{lemma}
  \label{lem:transitions_mimic}
  Let \grmcontext. Then, 
  $S \LTSderives T$ if and only if $\vec X \LTSderivesP \vec Y$.
\end{lemma}
%
\begin{proof}
	For the direct implication, we proceed by rule induction on the
	hypothesis, using the definition of $\word$.
%	For the direct implication and using the unravelling
%	function on recursive types, we can proceed by induction
%	on the structure of $\LTSderives$. 
	
	\begin{itemize}
		%\item $S\triangleq\skipk$ does not have any transition. And
		%neither does $\toGrammarf{\skipk} = \varepsilon$.
		\item Case $\sharp B$: if $\sharp B \LTSderives[\sharp B] \skipk$, then 
			$\word(\sharp B) \LTSderivesP[\sharp B] \varepsilon$.
		\item Case $\star \ell_i$: if
		$\star\{\ell_i\colon S_i\}_{i\in I} \LTSderives[\star \ell_i] S_i$, then
		$\word(S) \LTSderivesP[\star \ell_i] \word(S_i)$.
		\item Case $S_1;S_2$ with $S_1\LTSderives S_1'$:
		if $S_1;S_2\LTSderives S_1';S_2$ and $S_1\LTSderives S_1'$,
			by induction hypothesis, we know that $\word(S_1) \LTSderivesP \word(S_1')$.
			Furthermore, we have
			\begin{equation}
			\label{eq:grammar_sequential_composition}
				\word(S_1;S_2) = \word(S_1)\cdot\word(S_2).	
			\end{equation}
			Hence, $\word(S_1;S_2) \LTSderivesP \word(S_1';S_2)$.
		\item Case $S_1;S_2$ with $\DONE{S_2}$ and $S_2\LTSderives S_2'$: 
			in the case $S_1;S_2\LTSderives S_2'$, where
			$\DONE{S_1}$ and $S_2\LTSderives S_2'$, 
			by~\eqref{eq:grammar_sequential_composition},
			Lemma~\ref{lemma:terminated-togrammar} and since $\DONE{S_1}$, 
			we have $\word(S_1;S_2) = \word(S_2)$.
			Thus, by induction hypothesis we have 
			$\word(S_1;S_2) \LTSderivesP \word(S_2').$
		\item Case $\mu X.T$: if $\mu X.T\LTSderives S'$, 
			then $\subs {\mu X. T}{X}{T} \LTSderives S'$. Also
			$\Unravel(S) \LTSderives S'$ and, by induction hypothesis,
			$\word(\Unravel(S))\LTSderivesP \word(S')$. Hence, by 
			definition of $\word$, 
			$\word(S) = X \LTSderivesP \word(S')$. \smallskip
%		then, by recursively going backward 
%		in the LTS rule for recursive types, we know that
%		$\Unravel(S) \LTSderives S'$ and $\Unravel(S)$ is not a recursive
%		type. Hence, by induction hypothesis, we have
%		$\word(\Unravel(S))\LTSderivesP \word(S')$.
%		By definition of $\grm(S,\emptyset)$, we thus have
%		$\word(S) = X \LTSderivesP \word(S')$. \smallskip
	\end{itemize}
	For the reverse implication, we prove that any transition in the
	grammar leads to a transition in the corresponding types.
	\begin{itemize}
		\item if $\word(S)\LTSderivesP[\sharp B] \vec X$, then
		$\word(S) = Y \cdot \vec X$, where $Y\LTSderivesP[\sharp B] \varepsilon$,
		and so $\Unravel(S) = \sharp B; T$ and thus $S\LTSderives[\sharp B] T$.
		\item if $\word(S) \LTSderivesP[\star \ell_i] \vec X $, then
		$\word(\Unravel(S)) = Y $, where $Y\LTSderivesP[\star \ell_i] \vec X$.
		Hence, $\Unravel (S)$ is of the form $\star\{\ell_j' :U_j\}_{j\in J};T$ with $\ell_i = \ell_j'$ and
		$\vec X = \word(U_j;T)$, for some $j\in J$. Using 
		the LTS we conclude that 
		$S \LTSderives[\star \ell_i] U_j ; T$. \qed
	\end{itemize}
\end{proof}

\begin{lemma}
	 \label{lem:transitions_words}
	 If $\word\ S \LTSderivesP \vec X$, then exists $T$ s.t. $S \LTSderives T$ and $\vec X = \word\ T$.
\end{lemma}
\begin{proof}
	By induction on the definition of $\word$.\qed 
\end{proof}

The main result of this subsection follows from
Lemmas~\ref{lem:transitions_mimic} and~\ref{lem:transitions_words}.

\begin{theorem}
  \label{thm:equiv_coincide}
  Let \grmcontext. Then, $\grm$ is a full abstract encoding, i.e.,
  $S \TypeEquiv T$ if and only if $\vec X \ProdEquiv \vec Y$.
\end{theorem}

\begin{proof}
For the direct implication, assume that $S \TypeEquiv T$ and let
$\mathcal{B}$ be a bisimulation for $S$ and $T$. Then, consider 
$ \mathcal{B}' = 
\{(\word (S_0), \word(T_0))\mid (S_0,T_0)\in \mathcal{B} \}. $
Obviously, $(\word(S), \word(T))\in \mathcal{B}'$. To prove that
$\mathcal{B}'$ is a bisimulation, one assumes that 
$\word (S_0)\LTSderivesP \vec X $ and proves that there exists
$\vec Y$ such that $\word (T_0)\LTSderivesP \vec Y $
with $(\vec X, \vec Y)\in \mathcal{B}'$. This proof  
is done by coinduction on the definition of $\word$, uses 
Lemmas~\ref{lemma:terminated-togrammar},
\ref{lem:transitions_mimic}, \ref{lem:transitions_words},
and the definition of $\mathcal{B}'$. \smallskip\\
For the reverse implication, assume that 
$\vec X \ProdEquiv \vec Y$, with $\vec X = \word (S)$ and
$\vec Y = \word(T)$ and let $\mathcal{B}'$ be a bisimulation
for $\vec X$ and $\vec Y$. Then, consider
$\mathcal{B} = \{(S_0, T_0)\mid (\word(S_0),\word(T_0))\in \mathcal{B}'\}$.
Notice that $(S,T)\in \mathcal{B}$.
The proof that $\mathcal{B}$ is a bisimulation, consists in proving that:
given $(S_0, T_0)\in \mathcal{B}$, such that $S_0\LTSderives S_0'$,
there exists $T_0'$ such that $T_0\LTSderives T_0'$
and $(S_0',T_0')\in \mathcal{B}$. The proof
follows by rule coinduction on the LTS and uses 
Lemmas~\ref{lemma:terminated-togrammar},
\ref{lem:transitions_mimic}, and~\ref{lem:transitions_words}. \qed 
\end{proof}

Now we sketch the proof that pruning grammars also preserves bisimulation.
We distinguish the grammars in the context through the subscript of $\sim$.

\begin{theorem}
	\label{thm:pruning_preserves_bisim}
	$\vec X \bisimP \vec Y$ if and only if $\vec X \sim_{\Prune(\productions)} \vec Y$.
\end{theorem}

\begin{proof}
For the direct implication, the bisimulation for $\vec X$ and $\vec Y$ over
$\productions$ is also a bisimulation for $\vec X$ and $\vec Y$ over
$\Prune(\productions)$. For the reverse implication, if $\mathcal{B}'$
is a bisimulation for $\vec X$ and $\vec Y$ over $\Prune(\productions)$,
then $\mathcal{B} = \mathcal{B}' \cup 
\{(\vec V W, \vec V W \vec Z) \mid  (W\rightarrow \vec V W \vec Z) \in \productions, 
\text{ $W$ unnormed} \}$ 
is a bisimulation for $\vec X$ and $\vec Y$ over $\productions$. \qed
\end{proof}


\subsection{Correctness of the algorithm}

We now focus on the correctness of the function $\Bisim$.  Before
proceeding to soundness, we recall the \emph{safeness property}
introduced by Jan{\v{c}}ar and Moller~\cite{janvcar1999techniques}.

\begin{lemma} [Safeness Property]
  \label{lem:safeness}
  Given a set of productions $\productions$,
  $\vec X \ProdEquiv \vec Y$ if and only if the expansion tree rooted
  at $\{(\vec X, \vec Y)\}$ has a successful branch.
\end{lemma}

Notice that function $\Bisim$ builds an expansion tree by alternating
between simplification---reflexive, congruence, and \BPA---and
expansion operations, as proposed by Jan{\v{c}}ar and Moller.
%
These simplification rules are
\emph{safe}~\cite{janvcar1999techniques}, in the sense that the
application of any rule preserves the bisimulation from a parent node
to at least one child node and, reciprocally, that bisimulation on a
child node implies the bisimulation of its parent node, thus proving
the safeness property.

While the safeness property is instrumental in proving
soundness, the \emph{finite witness property} is of
utmost importance to prove completeness. This result follows
immediately from the analysis by Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques}, which capitalizes on results by
Caucal~\cite{caucal1986decidabilite}, and Christensen, H{\"{u}}ttel, and
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}:

\begin{lemma} [Finite Witness Property]
\label{lem:finite_witness}
	Given a set of productions $\productions$,
	if $\vec X \ProdEquiv \vec Y$ then the expansion tree rooted at
	$\{(\vec X, \vec Y)\}$ has a finite successful branch.
\end{lemma}

We refer to Caucal, Christensen, H{\"{u}}ttel, and Stirling for
details on the proof of existence of a finite witness, as stated in
Lemma~\ref{lem:finite_witness}. This proof is particularly interesting
in that it highlights the importance of the BPA rules and of pruning
productions on reaching such (finite) witness. The results in these
two papers also elucidate the reason for the distinction, in the
simplification phase, between the cases where all the symbols in the
grammar are and are not normed (cf.~program variable $\mathsf{rules}$
in function $\expand$).
%
The safeness and finite witness properties ensure the termination of
the algorithm, its soundness and completeness.

\begin{lemma}[Termination]
  \label{lem:termination}
  Let \grmcontext. Then, the computation of $\Bisim(\vec X,\vec Y, \Prune(\productions))$
  always terminates.
\end{lemma}
%
\begin{proof}
  Start by noticing that $\Prune(\productions)$ always terminate.
  %
  For $\Bisim$ itself, if $S\TypeEquiv T$ then, by
  Theorems~\ref{thm:equiv_coincide} and
  \ref{thm:pruning_preserves_bisim}, we have
  $\word(S) \sim_{\Prune(\productions)} \word(T) $ and thus the
  existence of a finite successful branch is ensured by the finite
  witness property (Lemma~\ref{lem:finite_witness}).  Hence,
  breadth-first search eventually terminates.
  
  When $S\not\TypeEquiv T$, we easily conclude that all branches in
  the expansion tree are finite and thus $\Bisim(\vec X,\vec Y)$
  terminates.  To conclude that all branches are finite, observe that
  any infinite branch is successful by definition and thus the
  safeness property would imply $\word(S) \sim_{\Prune(\productions)} \word(T)$ 
  and we would have
  $S\TypeEquiv T$, by Theorem~\ref{thm:equiv_coincide}.\qed
\end{proof}

%\begin{proof}
%	On the other hand, as observed in~\cite{janvcar1999techniques},
%	the union of nodes along a successful branch is a relation $R$
%	such that $R\subseteq \ProdEquiv$. Hence, any pair $(\vec X, \vec Y)$
%	occurring along a successful branch is such that $\vec X \ProdEquiv \vec Y$,
%	which, by Lemma~\ref{lemma:filtering}, means that $|\vec X|=|\vec Y|$.
%	So, the filtering rule would node exclude any node in the successful branch
%	and, then, also preserved the safeness property.
%\end{proof}

\begin{lemma}
  \label{lem:bisimilar-to-prod}
  \begin{sloppypar}
  	Let \grmcontext.  If 
  $\Bisim(\vec X,\vec Y,$ $ \Prune(\productions))$ returns $\True$, then
  $\vec X \sim_{\Prune(\productions)} \vec Y$.
  \end{sloppypar}
\end{lemma}

\begin{proof}
  Function $\Bisim$ returns $\True$ whenever it reaches a (finite)
  successful branch in the expansion tree rooted at
  $\{(\vec X,\vec Y)\}$, i.e., a branch terminating in an empty node. 
  Conclude with the safeness property,
  Lemma~\ref{lem:safeness}. \qed
  % , whenever the expansion tree rooted
  % at $\{(X_{S}, X_{T})\}$ has a (finite) successful branch, we
  % kn that $X_{S} \ProdEquiv X_{T}$.
\end{proof}

From the previous results, the soundness of our algorithm is now
immediate: the algorithm to check the bisimulation of context-free
session types is sound with respect to
the meta-theory of context-free session types.

\begin{theorem}[Soundness]
  \label{thm:soundness}
  Let \grmcontext.  If $\Bisim(\vec X,\vec Y, \Prune(\productions))$ returns $\True$ then
  $S\TypeEquiv T$.
\end{theorem}
%
\begin{proof}
  From Theorem~\ref{thm:equiv_coincide}, Theorem~\ref{thm:pruning_preserves_bisim}, 
  and Lemma~\ref{lem:bisimilar-to-prod}.\qed
\end{proof}

% \begin{corollary}
% 	If $S\not\TypeEquiv T$ then $\bisimf ST$ returns \upshape{\lstinline|False|}.
% \end{corollary}
% %
% \begin{proof}
% 	From Theorem~\ref{thm:soundness} and Lemma~\ref{lemma:terminates}.
% \end{proof}
 
Given that the algorithm terminates (Lemma~\ref{lem:termination}), we
know that if $S\not\TypeEquiv T$, then $\Bisim(\vec X, \vec Y, 
\Prune(\productions))$ returns
\lstinline|False|, where \grmcontext.
%
We now show that the algorithm to check the bisimulation of
context-free session types is complete with respect to the meta-theory
of context-free session types. The finite witness property is
paramount to achieve this result.

\begin{theorem}[Completeness]
\label{thm:completeness}
  If $S \TypeEquiv T$ then $\Bisim(\vec X, \vec Y, \Prune(\productions))$ 
  returns
  \upshape{\lstinline|True|}, where \grmcontext.
\end{theorem}
%
\begin{proof}
  Assume $S \TypeEquiv T$. By Theorems~\ref{thm:equiv_coincide}
  and \ref{thm:pruning_preserves_bisim},
  we have $\vec X \sim_{\Prune(\productions)} \vec Y$.  Hence,
  Lemma~\ref{lem:finite_witness} ensures the existence of a finite
  successful branch on the expansion tree rooted at
  $\{(\vec X,\vec Y)\}$, i.e., a branch terminating in an empty
  node.  Since our algorithm traverses the expansion tree using
  breadth-first search it will, eventually, reach the empty node and
  conclude the bisimulation positively.\qed
\end{proof}

Theorem~\ref{thm:completeness} ensures that if
$\Bisim(\vec X,\vec Y, \productions)$ returns $\False$ then
$S \not\TypeEquiv T$.

% \begin{corollary}
% 	If $\bisimf ST$ returns \upshape{\lstinline|False|} then $S\not\TypeEquiv T$.
% \end{corollary}
% %
% \begin{proof}
% 	From Theorem~\ref{thm:completeness}.
% \end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
