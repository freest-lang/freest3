\section{Evaluation}
\label{sec:evaluation}

\begin{theorem}
  \begin{enumerate}
  \item $\skipk \TypeEquiv \skipk$,  $\sharp B \TypeEquiv \sharp B$,
    $X \TypeEquiv X$;
  \item $S;U \TypeEquiv T;V$ if $S \TypeEquiv T$ and $U \TypeEquiv V$; 
  \item $\mu X.S \TypeEquiv \mu X.T$ if $S \TypeEquiv T$; 
  \item $\star\{\ell_i\colon S_i\}_{i\in I}\TypeEquiv
    \star\{\ell_i\colon T_i\}_{i\in I}$ if $(S \TypeEquiv T)_{i\in I}$
  \item $S\TypeEquiv T;\skipk$ and $S\TypeEquiv \skipk;T$ if $S \TypeEquiv T$;
  \item $\star\{\ell_i\colon S_i\}_{i\in I};U\TypeEquiv
    \star\{\ell_i\colon T_i;V\}_{i\in I}$ if $(S \TypeEquiv T)_{i\in
      I}$ and $U \TypeEquiv V$; 
  \item
    $\mu x.\mu y.S \TypeEquiv \mu x.T\subs xy \TypeEquiv \mu y.T\subs
    yx$ if $S \TypeEquiv T$;
  \item $\mu x.S \TypeEquiv T$ if $S \TypeEquiv T$ and $x\notin\free(S)$;
  \item $S\subs Ux\TypeEquiv T\subs Vx$  if $S \TypeEquiv T$ and $U \TypeEquiv V$; 
  \item $\mu X.S \TypeEquiv T$
  \end{enumerate}
\end{theorem}

We implemented the algorithm sketched in Listings~\ref{lst:toGrammar}
to~\ref{lst:enhanced} in 300 lines of Haskell and used the Glasgow
Haskell Compiler, GHC version 8.6.3, from which we have obtained the
results we present in this section.  Evaluation was conducted on a Mac
mini equipped with a 3.6 GHz Intel Core i3, 8 GB of memory, running
MacOS 10.14.3.

Once the improvement proposals were established, we benchmarked the
algorithm on a test suite of carefully crafted pairs of types
based on cases observed when using the compiler where the algorithm is 
used~\cite{almeida.etal_freest-functional-language}. These
tests comprise valid and invalid equivalences, for a total of 154
tests. We have profiled our program for the time and memory allocated
during the tests. For this purpose, we have used GHC's profiling
feature, that maintains a cost-centre stack to keep track of the
incurred costs. The results are depicted in
Figure~\ref{fig:results}.

\begin{figure}[h]
	\includegraphics[height=4cm]{img/run_time}	\hspace*{2mm}
	\includegraphics[height=4cm]{img/memory_alloc}
	\caption{Test results: running times (on the left) and
	memory allocated (on the right) checking the equivalence
	of context-free session types in 154 tests.}
	\label{fig:results}
\end{figure}

For the base algorithm, proposed in Listing~\ref{lst:algorithm}, we
obtained a running time of about 4624 seconds and
8,660,309 Mb memory allocated. From the moment we introduced the
optimizations the results improved remarkably: 
implementing a double-ended queue we reduced the running time to 1788 
seconds and the allocated memory to 1,997,841 Mb, by also
iterating the
simplification phase in the search for a fixed point we decreased these values
to a running time of 1172 seconds and 
allocated memory of 1,103,397 Mb. The 
combination of these enhancements with the clean grammar generation
exhibit an improvement in more than 1,000,000\% from the base case,
achieving a running time of 0.4 seconds and 306 Mb 
of memory allocated.

%iterating the
%simplification phase in the search for a fixed point allowed to reduce
%the running time to 110.35 seconds and the memory allocated to 164,745
%Mb, whereas the implementation of the double-ended queue allowed to
%reduce the running time to 18.45 seconds and the allocated memory to
%29,298. The combination of both exhibit an improvement on more than
%1,000,000\% from the base case, achieving an average of 0.04
%seconds for the running time and 62 Mb of allocated memory.

We should also highlight that, we run example~\eqref{ex:chaotic}
with the improved algorithm, in a battery of 100 runs, and obtained an
average running time of 0.008 seconds.

The heuristic we proposed actually circumvents the exponential complexity 
inherent to the expansion tree, thus allowing to obtain running times that 
are manifestly small and to use this algorithm as an integral 
part of a compiler, as we had intended from the beginning. 
%


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
