\begin{lstlisting}[
  caption={Haskell code for stage 1: the conversion of types into grammars},
  label={lst:toGrammar},
  captionpos=b]
type Transitions = Map.Map LTSLabel [TypeVar]
type Productions = Map.Map TypeVar Transitions
type TransState = State (Productions, Int)
type Substitution = (Type, TypeVar)

convertToGrammar :: TypeEnv -> [Type] -> Grammar
convertToGrammar tEnv ts = Grammar xs (productions state)
  where (xs, state) = runState (mapM typeToGrammar ts) (initial tEnv)

typeToGrammar :: Type -> TransState Word
typeToGrammar t = collect [] t >> toGrammar t

toGrammar :: Type -> TransState Word
toGrammar (Skip _) =
  return []
toGrammar (Semi _ t u) = do
  xs <- toGrammar t
  ys <- toGrammar u
  return $ xs ++ ys
toGrammar (Message _ p b) = do
  y <- getProd $ Map.singleton (MessageLabel p b) []
  return [y]
toGrammar (Choice _ p m) = do
  ms <- tMapM toGrammar m
  y <- getProd $ Map.mapKeys (ChoiceLabel p) ms
  return [y]
toGrammar (TypeVar _ x) = do      
  y <- getProd $ Map.singleton (VarLabel x) []
  return [y]
toGrammar (Rec _ (TypeVarBind _ x _) _) =
  return [x]
  
collect :: [Substitution] -> Type -> TransState ()
collect s (Semi _ t u) = collect s t >> collect s u
collect s (Choice _ _ m) = tMapM_ (collect s) m
collect s t@(Rec _ (TypeVarBind _ x _) u) = do
  let s' = (t, x) : s
  let u' = Substitution.subsAll s' u
  (z:zs) <- toGrammar (normalise Map.empty u')
  m <- getTransitions z
  addProductions x (Map.map (++ zs) m)
  collect s' u
collect _ _ = return ()

addProductions :: TypeVar -> Transitions -> TransState ()
addProductions x m =
  modify $ \s -> s {productions = Map.insert x m (productions s)}

getProd :: Transitions -> TransState TypeVar
getProd ts = do
  ps <- getProductions
  case reverseLookup ts ps of
    Nothing -> do
      y <- freshVar
      addProductions y ts
      return y
    Just x ->
      return x
  where fold x ts' acc = if prodExists ts' ts then Just x else acc
\end{lstlisting}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

% Old version:
% toGrammar (Rec x t) =
%   | isChecked (Rec x t) = return []
%   | otherwise = do
%     zs <- toGrammar t
%     m <- getTransitions (head zs)
%     addProductions x (Map.map (++ tail zs) m)
%     return [x]
