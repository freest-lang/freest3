\section{An algorithm to decide type bisimilarity}
\label{sec:algorithm}

% Recall the type bisimulation problem for context-free session types.

% \begin{quote}
%   Given context-free session types $S$ and $T$, the type equivalence
%   problem consists in deciding if types $S$ and $T$ are equivalent,
%   i.e., $S \TypeEquiv T$.
% \end{quote}

This section presents an algorithm to decide whether two types are in
a type bisimulation. In the process we also provide an algorithm to
decide the equivalence of simple context-free languages.
%
The algorithm comprises three stages:
%
\begin{enumerate}
\item Translate the two types into a context-free grammar,
\item Prune unreachable symbols in productions, and
\item Explore an expansion tree, alternating between simplification
  and expansion operations, until either finding an empty node---case
  in which it decides positively---or failing to expand a node---case
  in which it decides negatively.
\end{enumerate}

\paragraph{Translating types to grammars}

% GREIBACH NORMAL FORMS

Type variables~$X$ are the \emph{non-terminal symbols} and LTS
labels~$a$ are the \emph{terminal symbols}. Sequences of type
variables~$\vec X$ are called \emph{words}; $\varepsilon$ denotes the
empty word.
%
A context-free grammar in Greibach normal form is a pair
$(\vec X,\mathcal P)$ where~$\vec X$ is the \emph{start word}
and~$\mathcal P$ a \emph{set of productions} of the form
$Y \rightarrow a\vec Z$ (context-free session types do not require
productions of the form $X \rightarrow\varepsilon$).
%
Due to the deterministic nature of context-free session types, the
grammars we are interested in are \emph{simple}: for each
non-terminal symbol~$X$ and each terminal symbol~$a$, there is at most
one production of the form $X \rightarrow a\vec Y$.

% We denote by $\mathcal{P}$ the context-free grammar in 
% Greibach normal form.
%
% Sometimes we abuse notation and let $\mathcal{P}$ denote the
% set of words composed by symbols in the grammar. \vv{fix me!}

% GRAMMAR LTS

Grammars in Greibach normal form naturally induce a labelled
transition system by taking words~$\vec X$ as states, terminal
symbols~$a$ as actions, and the transition relation $\LTSderivesP$,
defined as $X\vec Y\LTSderivesP \vec Z\vec Y$ when
$X \rightarrow a\vec Z \in \mathcal P$.  The associated bisimilarity
is denoted by $\ProdEquiv$. \vv{Move forward?}

% ALGORITHM

Given a well-formed context-free session type, function
\lstinline|toGrammar| returns the start word while computing the
productions in the grammar.

The algorithm keeps the set of productions and an integer (to generate
fresh non-terminal symbols) in the monadic state
\lstinline{TransState}. It uses the following functions to manipulate
state.
%
\begin{itemize}
\item \lstinline{freshVar} returns a fresh non-terminal symbol (a type
  variable);
\item \lstinline{addProduction}$\,X\,a\,\vec Y$ updates the state by inserting
  the production $X\rightarrow a\vec Y$;
% \item \lstinline{insertVisited} marks a non-terminal symbol as visited;
% \item \lstinline{isVisited} identifies whether the given non-terminal symbol
%   was previously visited;
% \item \lstinline{subst} $X\,T\,S$ replaces the occurrences of~$X$
%   by~$T$ in~$S$;
\item \lstinline|getTransitions|$\,X$ retrieves the transitions
  from~$X$ (a map from terminal symbols~$a$ to words~$\vec Y$):
\item \lstinline|reverseLookup| lookup a key for a value in the map.
\end{itemize}

\input{listing-toGrammar}

Notice that function \lstinline|toGrammar| terminates on all inputs and
that the resulting set of productions is finite, because recursion is
always on subterms.
%
Furthermore, due to the deterministic nature of the LTS,
\lstinline|toGrammar| returns a simple grammar.
%
%One can obtain a unique set of productions for two types by ensuring
%that fresh variables do not overlap when converting both types.
Function \lstinline|convertToGrammar| converts the two types
in their corresponding grammar.

\begin{example}
\label{ex:productions}
Consider the following context-free session types:
%
\begin{equation*}
\begin{array}{lll}
    S & \triangleq & (\mu x . \&\{n: x;x;?\intk, \ell: ?\intk\});(\mu z . !\intk ; z;z)\\
    T & \triangleq & (\mu y . \&\{n: y;y, \ell: \skipk\};?\intk);(\mu w. !\intk ; w)
\end{array}
\end{equation*}
%
Function \lstinline{toGrammar}, when applied to $S$ and $T$, produces
the following productions.
\begin{center}
  \begin{tabular}{l l}
    \multicolumn{2}{c}{Productions for type $S$}\\ \hline
    \multicolumn{2}{c}{Start word: $X_1X_4$}\\
     $X_1 \rightarrow \& n\, X_1 X_1 X_2$ &$X_3 \rightarrow \,? \intk$\\
    $X_1 \rightarrow \& \ell\, X_3$ &$X_4 \rightarrow \,!\intk\, X_4 X_4$\\
     $X_2 \rightarrow \,? \intk$ &\\
  \end{tabular} \qquad
  \begin{tabular}{l l}
    \multicolumn{2}{c}{Productions for type $T$}\\ \hline
    \multicolumn{2}{c}{Start word: $Y_1Y_3$}\\
    $Y_1 \rightarrow \& n\, Y_1 Y_1 Y_2 $&$Y_2 \rightarrow \,? \intk$\\
    $Y_1 \rightarrow \& \ell \,Y_2 $&$Y_3 \rightarrow \,!\intk\, Y_3$\\
  \end{tabular}
\end{center}
\end{example}

\subsection{Pruning unnormed productions}
\label{subsec:prune}

For $\vec a$ a sequence of non-terminal symbols $a_1,\ldots, a_k$
($k\ge1$), write $\vec Y \LTSderivesP[\vec a] \vec Z$ when
$\vec Y \LTSderivesP[a_1] \cdots \LTSderivesP[a_k] \vec Z$.
%
We say that $\vec Y$ is \emph{normed} when
$\vec Y \LTSderivesP[\vec a] \varepsilon$ for some~$\vec a$, and that
$\vec Y$ is \emph{unnormed} otherwise.
%
When $\vec Y$ is normed, the \emph{minimal path} of $\vec Y$ is the
shortest~$\vec a$ such that $\vec Y \LTSderivesP[\vec a]
\varepsilon$.
%
In this case, the \emph{norm} of $\vec Y$, denoted by $|\vec Y|$, is
the length of~$\vec a$.

% Using the same approach as~\cite{DBLP:journals/iandc/ChristensenHS95} on
% the definition of (un)normed processes, we say that a sequence of symbols
% $\vec Y$ is \emph{normed} if there are labels $a_1,\ldots, a_k$
% such that:
% \begin{equation}
% \label{eq:path}
% 	\vec Y \rightarrow a_1\enspace Y_1 \rightarrow \cdots \rightarrow a_k
% 	\rightarrow \varepsilon.
% \end{equation}
% $\vec Y$ is said to be \emph{unnormed} when it is not normed. If $\vec Y$
% is normed, we define its \emph{norm} as:
% \[ | \vec Y | = \underset{k}{\mathsf{min}} \{\vec Y \rightarrow a_1\enspace Y_1
% \rightarrow \cdots \rightarrow a_k \rightarrow \varepsilon \}.\]
% A \emph{minimal path} for a normed sequence of symbols $\vec Y$ is a sequence of
% labels $\vec a = a_1,\ldots,a_k$ as in~\eqref{eq:path} such that
% $k = | \vec Y |$. To ease notation, we will also represent~\eqref{eq:path} as
% $\vec Y \xrightarrow{\vec a} \varepsilon$.

As observed by Christensen H\"uttel, and
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}, any unnormed
word $\vec Y$ is bisimilar to its concatenation with any other
word, that is, if $\vec Y$ is unnormed, then
$\vec Y \ProdEquiv \vec Y \vec X$.
%
% \begin{equation}
%\label{unnormed}
%\text{ if } \vec Y \text{ is unnormed, then } \vec Y \sim \vec Y X.
%\end{equation}
%
We use this fact
% Upon the definition of the productions underlying the context-free session types,
% our algorithm builds upon~\eqref{unnormed}
to prune out unreachable symbols in unnormed sequences of symbols. The
code is in Listing~\ref{lst:prune}.
%
%\vv{normedWord needs to be rewritten}

\begin{lstlisting}[
  caption={Haskell code for stage 2: pruning unnormed productions},
  label={lst:prune},
  captionpos=b
  ]
type Visited = Set.Set [TypeVar]

prune :: Productions -> Productions
prune p = Map.map (Map.map (pruneWord p)) p

pruneWord :: Productions -> Word -> Word
pruneWord p = foldr (\x ys -> if normed p x then x:ys else [x]) []

normed :: Productions -> TypeVar -> Bool
normed p x = isJust $ maybeNorm p [x]

maybeNorm :: Productions -> [TypeVar] -> Maybe Int
maybeNorm p = norm Set.empty
  where
  norm :: Visited -> [TypeVar] -> Maybe Int
  norm _ [] = Just 0
  norm v xs
   | any (flip isSubsequenceOf xs) v = Nothing
   | otherwise = fmap (+1) (Map.foldr (compose min) Nothing (norms v xs))
  norms :: Visited -> [TypeVar] -> Map.Map Label (Maybe Int)
  norms v xs = Map.map (norm (Set.insert xs v)) (transitions xs p)
\end{lstlisting}

\begin{example}
  \label{ex:prune}
  Recall Example~\ref{ex:productions} and notice that $X_1 X_4$ and $Y_1 Y_3$
  are both unnormed. We can easily see that the last occurrence of
  $X_4$ in the last production for $S$ is unreachable, hence we can
  simplify it and obtain the pruned productions for $S$ as:
  %
  \begin{center}
    \begin{tabular}{l l l}
      \multicolumn{3}{c}{Pruned productions for type $S$}\\ \hline
      \multicolumn{3}{c}{Start word: $X_1X_4$}\\
      $X_1 \rightarrow \& \ell\, X_3$  &
      $X_1 \rightarrow \& n\, X_1 X_1 X_2$ &
      $X_2 \rightarrow \,? \intk$ 
      \\
      $X_3 \rightarrow \,? \intk$ &
      $X_4 \rightarrow \,!\intk\, X_4$
    \end{tabular}
  \end{center}
\end{example}

\subsection{Building expansion trees}
\label{subsec:expand}

% We recall that, given two context-free session types $S$ and $T$, our main goal
% is to decide whether these types are equivalent or not. For this purpose,
% the algorithm we propose starts by applying algorithm presented in
% Listing~\ref{lst:toGrammar} to convert $S$ and $T$ into a grammar containing
% the productions derived from them. Afterwards, the algorithm in
% Listing~\ref{lst:prune} is used to streamline the grammars, by pruning
% unnormed sequences of symbols. Throughout this section we focus on the
% third and last step of the algorithm.

We base the third stage of the algorithm on the notion of
\emph{expansion tree} proposed by Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques}, an adaptation of an idea by
Hirshfeld~\cite{hirshfeld1996bisimulation}. The \emph{nodes} in trees
are labelled by sets of pairs of words.
%
We say that a node $N'$ is an \emph{expansion} of $N$ if $N'$ is a
minimal set such that: for every pair $(\vec X, \vec Y) \in N$,
\begin{itemize}
\item if $\vec X \rightarrow a\vec X'$ then
  $\vec Y \rightarrow a\vec Y'$ with $(\vec X',\vec Y')\in N'$;
\item if $\vec Y \rightarrow a\vec Y'$ then
  $\vec X \rightarrow a \vec X'$ with $(\vec X',\vec Y')\in N'$.
\end{itemize}

An \emph{expansion tree} is built from a root node: the singleton set
containing the pair of words obtained by translating the two types
into a grammar. Children nodes are obtained by expansion from their
parent node. Jan{\v{c}}ar and Moller observed that expansion alone
often leads to infinite trees. We then alternate between expansion and
simplification operations, until either finding an empty node---case
in which we decide equivalence positively---or failing to expand a
node---case in which we decide equivalence negatively.
%
% The na\"ive proposal for an expansion tree considers that any
% children node is obtained by expansion from its parent
% node. Nevertheless, as Jan{\v{c}}ar and Moller observed, this would
% often lead to infinite expansion trees. Hence, we follow the
% proposal in~\cite{janvcar1999techniques} and let the expansion tree
% alternate between simplification and expansion operations until
% either finding an empty node---case in which we decide equivalence
% positively---or failing to expand a node---case in which we decide
% equivalence negatively.
%
We say that a branch is \emph{successful} if it is infinite or
finishes in an empty node, otherwise it is said to be
\emph{unsuccessful}.

%\paragraph*{Expansion step}
In the \emph{expansion step}, each node $N$ derives a single child
node, obtained as an expansion of $N$. As we are dealing with simple
grammars, no branching is expected in the expansion tree at this
step.
%
% \paragraph*{Simplification step}
The \emph{simplification step} consists on the application of the
following rules:
%
\begin{description}
\item[Reflexive rule:] Omit from a node any pair of the form $(\vec X,\vec x)$;
\item[Congruence rule:] Omit from a node $N$ any pair that belongs to
  the least congruence containing the ancestors of $N$;
  % \item {\bf Basic Process Algebra rules:} create sibling nodes for $N$
  % according to the following rules:
  % \begin{description}
\item[BPA1 rule:] If $(X_0 \vec X, Y_0 \vec Y)$ is in
  $N$ and $(X_0 \vec {X'}, Y_0 \vec {Y'})$ belongs to the ancestors of
  $N$, then create a sibling node for $N$ replacing
  $(X_0 \vec X, Y_0 \vec Y)$ by $(\vec X, \vec {X'})$ and
  $(\vec Y, \vec {Y'})$;
\item[BPA2 rule:] If $(X_0 \vec X, Y_0 \vec Y)$ is in $N$
  and $X_0$ and $Y_0$ are normed, then:
  \begin{description}
  \item[Case] $|X_0| \leq |Y_0|$: Let $\vec a$ be a minimal path
    for $X_0$ and $\vec Z$ the word such that
    $ Y_0 \LTSderivesP[\vec a] \vec Z$. Add a sibling node for
    $N$ including the pairs $(X_0 \vec Z, Y_0)$ and
    $(\vec X, \vec Z \vec Y)$ in place of $(X_0 \vec X, Y_0 \vec Y)$;
  \item[Case] $|X_0| > |Y_0|$: Let $\vec a$ be a minimal path for
    $Y_0$ and $\vec Z$ the word such that
    $ X_0 \LTSderivesP[\vec a] \vec Z$. Add a sibling node for $N$
    including the pairs $(X_0 , Y_0 \vec Z )$ and
    $(\vec Z\vec X, \vec Y)$ in place of $(X_0 \vec X, Y_0 \vec Y)$.
  \end{description}
%		  \end{description}
%	\item {\bf Filtering rule:} remove any node containing a pair
%	       $(\vec X, \vec Y)$ such that $|\vec X|\neq |\vec Y|$.
\end{description}

Contrarily to expansion and to the reflexive and congruence
simplifications, \BPA\ rules promote branching in the expansion
tree. The number of children nodes generated by these rules is
finite~\cite{DBLP:journals/iandc/ChristensenHS95}.
%
Notice that the sibling nodes do not exclude the (often) infinite
branch resulting from successive expansions.

\subsection{Checking the bisimilarity of context-free session types}

% The algorithm to decide the equivalence of context-free session
% types capitalizes on the previous algorithms.

Given two context-free session types, function \lstinline|bisimilar|
(in Listing~\ref{lst:algorithm}) starts by converting the two session
types into a grammar, which is then pruned. Function
\lstinline|convertToGrammar| (in Appendix) builds the initial monadic
state, and runs the algorithm in Listing~\ref{lst:toGrammar} to
convert the session types given as parameters.
%
An expansion tree is computed afterwards, through an alternation of
expansion of children nodes and their simplification, using the
reflexive, congruence, and \BPA\ rules.
%
To avoid getting stuck in an infinite branch of the expansion tree, we
use a breadth-first search on the expansion tree. Nodes to be processed 
are stored in a queue.
%
The simplification stage distinguishes the case where all type
variables are normed, in which case \BPA1 is not required to decide
equivalence~\cite{caucal1986decidabilite,DBLP:journals/iandc/ChristensenHS95},
from the case where some type variables might be unnormed. The
recursive procedure terminates as soon as all nodes fail to expand
and, thus, the queue is empty, case in which the algorithm returns
\lstinline|False|, or an empty node is reached, case is which the
algorithm returns \lstinline|True|.

\begin{lstlisting}[
  caption={Haskell code for checking the bisimilarity of context-free
    session types},
  label={lst:algorithm},
  captionpos=b
  ]
type Node = Set.Set (Word, Word)
type Ancestors = Node
type NodeQueue = Queue.Seq (Node, Ancestors)

bisimilar :: TypeEnv -> Type -> Type -> Bool
bisimilar tEnv t u = expand (xs, ys) (prune p)
  where Grammar [xs, ys] p = trace (show t ++ "\nbisim\n" ++ show u) $ convertToGrammar tEnv [t, u]
        
expand :: (Word, Word) -> Productions -> Bool
expand p = expand' 1 (Queue.singleton (Set.singleton p, Set.empty))
  where
  expand' :: Int -> NodeQueue -> Productions -> Bool
  expand' i ((n, a) Queue.:<| q) ps
    | Set.null n      = True
    | otherwise       = case expandNode ps n of
        Nothing -> expand' (i+1) q ps
        Just n' -> expand' (i+1) (simplify i ps n' (Set.union a n) q) ps
  expand' _ Queue.Empty _ = False

simplify :: Int -> Productions -> Node -> Ancestors -> NodeQueue -> NodeQueue
simplify i ps n a q =
  foldr enqueueNode q nas'
  where nas' = if allNormed ps
               then foldr (apply ps) nas [reflex,congruence,bpa2]
               else foldr (apply ps) nas [reflex,congruence,bpa1,bpa2]

enqueueNode :: (Node,Ancestors) -> NodeQueue -> NodeQueue
enqueueNode (n,a) q = q Queue.|> (n,a)
\end{lstlisting}
% type NodeTransformation = Productions -> Ancestors -> Node -> Set.Set Node 

\begin{example}
  The expansion tree for our running example is
  in the diagram below. Once a successful
  branch is reached (the $\checkmark$ in the figure), 
  \lstinline|bisimilar S T| returns \lstinline|true|.
  %the algorithm in
  %Listing~\ref{lst:algorithm} decides that $S\TypeEquiv T$.
\end{example}

\begin{center}
	\includegraphics[width=7.5cm]{img/expansionTree}
	%\caption{Expansion tree for the context-free session types $S$ and $T$
	%introduced in Example~\ref{ex:productions}}
\end{center}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
