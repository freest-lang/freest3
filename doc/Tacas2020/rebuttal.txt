(Review1, Review3) Concrete comparison with related algorithms

The practical algorithm in the literature closer to ours is that by Henry and SÃ©nizergues [10] that decides equivalence of deterministic pushdown automata (DPDAs) by verifying language equality. As shown in [10], section Experiments, the algorithm takes more than one hour to decide equivalence of some pairs of DPDAs. Considering the need to incorporate this functionality in a compiler, one hour is not a feasible runtime.
But we should highlight that the equivalence problem we are dealing with does not coincide with the equivalence of DPDAs: deciding equality of languages generated by two DPDAs is not the same as deciding their bisimilarity. As an example, consider the DPDA D1 with a single state X and a single transition X -> a X and a DPDA D2 with a single state Y and a transition Y -> b Y. The languages generated by both DPDAs are empty, whence L(D1) = L(D2), but they are not bisimilar because D1 has a transition by a and D2 doesn't. We'll make this precise in the camera-ready.
The remaining existing implementations do not cover the whole generality of BPAs or simple grammars that we need to handle context-free session types.


(Review2) On page 6, definition of word, item 4:  should * on the right hand side be there?

The *l notation is meant to denote a label obtained by concatenating + or & to the label itself. It is important to distinguish +l from &l labels. We will make this clear in the camera-ready.


(Review2) The goal of the simplification rules BPA1 and BPA2 is not clear

As discussed by Christensen, Huttel, and Stirling in [6], and by Jancar and Moller in [18], the goal of BPA rules is to decompose pairs and ensure the existence of a finite branch whenever in presence of an infinite bisimulation.

(Review3) The definition of bisimilarity is not given

Please see bottom of page 4.


(Review3) The algorithm is exactly the same as the bisimulation algorithm for, say, Kripke structures

Two states in a Kripke structure are bisimilar, sRt, if:
- their set of labels coincide
- for every s' s.t. s -> s', there exists t' s.t. t -> t' and s'Rt'
- for every t' s.t. t -> t', there exists s' s.t. s -> s' and s'Rt'
This definition of bisimulation is not the same as the one presented at the bottom of page 4.


(Review3) The authors motivate this research by the need to describe protocols in concurrent programs. I am not entirely sure why bisimilation would help here concurrent programs.

Session types are used to describe protocols in concurrent programs. When incorporated in programming languages, the notion of type equivalence becomes of paramount importance. Due to the characteristics of session types (choice, recursion), bisimulation is a widely used tool to define type equivalence.


(Review3)  In context-free grammars, there is an additional complication of being stuck in an infinite path on the expansion tree, but the paper avoids it by performing BFS.

Infinite paths on the expansion tree may visit infintely many different states. BFS alone is not sufficient to preclude divergence. The BPA rules are crucial here.
