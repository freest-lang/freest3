(Review1, Review3) Concrete comparison with related algorithms

The practical algorithm in the literature closer to ours is [10] which decides the equivalence of deterministic pushdown automata (DPDAs) by checking language equality. As described in [10], the algorithm takes more than one hour to decide the equivalence of some pairs of DPDAs. This is way too long if incorporated in a compiler.
We should highlight that the equivalence problem we are dealing with does not coincide with the equivalence of DPDAs: deciding equality of languages generated by two DPDAs is not the same as deciding their bisimilarity. As an example, consider the DPDA D1 with a single state X and a single transition X -> a X and a DPDA D2 with a single state Y and a transition Y -> b Y. The languages generated by both DPDAs are empty, whence L(D1) = L(D2), but they are not bisimilar because D1 has a transition by a and D2 doesn't.
The remaining existing implementations do not cover the whole generality of BPAs or simple grammars that we need to handle context-free session types.


(Review1) Why are the benchmarks generated by QuickCheck representative?

The benchmark contains pairs of guaranteedly bisimilar types of various sizes. In each step of the construction one known law of bisimilarity is used, and all known laws are use [26].


(Review2) On page 6, definition of word, item 4:  should * on the right hand side be there?

The *l notation is meant to denote a label obtained by concatenating + or & to the label itself. It is important to distinguish +l from &l labels. We will make this clear in the camera-ready.


(Review2) The goal of the simplification rules BPA1 and BPA2 is not clear

As discussed in [6,18], the goal of BPA rules is to decompose pairs and ensure the existence of a finite branch whenever in presence of an infinite bisimulation.


(Review3) The definition of bisimilarity is not given

You are right in that we do not explicitely define bisimilarity. We nevertheless say when 2 types are bisimilar (page 5, line 3). The same applies to grammars.


(Review3) The algorithm is exactly the same as the bisimulation algorithm for, say, Kripke structures

The notion of bisimulation for labeled transition systems (LTS) does not coincide with that of Kripke structures. At the expansion stage, the proposed algorithm does not check node labelling (a LTS has labels for transitions only). It rather checks whether the transition labels for both words in the current node coincide and, if so, it tests corresponding children for bisimilarity.  Weâ€™ll clarify this in the final version of the paper.


(Review3)  In context-free grammars, there is an additional complication of being stuck in an infinite path on the expansion tree, but the paper avoids it by performing BFS.

Infinite paths on the expansion tree may visit infintely many different states. BFS alone is not sufficient to preclude divergence. The BPA rules are crucial here.


(Review3) The authors motivate this research by the need to describe protocols in concurrent programs. I am not entirely sure why bisimilation would help here concurrent programs.

Session types are used to describe protocols in concurrent programs. When incorporated in programming languages, the notion of type equivalence becomes of paramount importance. Due to the characteristics of session types (choice, recursion), bisimulation is a widely used tool to define type equivalence.
