(Review1, Review3) Concrete comparison with related algorithms

The practical algorithm in the literature closer to the equivalence algorithm we propose is that by Henry and SÃ©nizergues [10] that decides the equivalence of deterministic pushdown automata (DPDAs) by verifying language equality. As shown in [10], section Experiments, the algorithm takes more than one hour to decide the equivalence of some pairs of DPDAs. Considering the need to incorporate this functionality in a compiler, one hour is not a feasible runtime.
But we should highlight that the equivalence problem we are dealing with does not coincide with the equivalence of DPDAs: deciding equality of languages generated by two DPDAs is not the same as deciding their bisimilarity. For this, consider the DPDA D1 with a single state X whose single loop is X -> a X and a DPDA D2 with a single state Y whose single loop is Y -> b Y. The languages generated by both DPDAs are empty, whence L(D1) = L(D2), but they are not bisimilar because D1 has a transition by a and D2 doesn't. We'll make this precise in the camera-ready.
The remaining existing implementations do not cover the whole generality of BPAs or simple grammars that we need to handle context-free session types.

(Review2) On page 6, definition of word, item 4:  should * on the right hand side be there?

The *l notation is meant to denote a label obtained by concatenating + or & to the label itself. It is important to distinguish +l from &l labels. We will make this clear in the camera-ready.

(Review2) The goal of the simplification rules BPA1 and BPA2 is not clear

As discussed by Christensen, Huttel, and Stirling in [6], and by Jancar and Moller in [18], the goal of BPA rules is to decompose pairs and ensure the existence of a finite branch whenever an infinite bisimulation exists.

(Review3) The definition of bisimilarity is not given

Please see bottom of page 4.

(Review3) Kripke structures

Kripke structures are state-based models where (one or more) labels are associated with states and (non-labeled) transitions exist between states. Labeled transition are event-based systems that have one label associated with each transition between states (read, types or words in a grammar, in our case). Although the definitions of bisimilarity in both cases do not coincide, several canonical embeddings have been studied for equivalence relations, namely bisimulation (see [Reniers11]).

(Review3) Bisimulation and the description of protocols in concurrent programs

Session types are used to describe protocols in concurrent programs. When incorporated in programming languages, the notion of type equivalence becomes of paramount importance. Due to the characteristics of session types (choice, recursion), bisimulation is a widely used tool to define type equivalence.

References:
[Reniers11] Reniers, Michel A., and Tim AC Willemse. "Folk theorems on the correspondence between state-based and event-based systems." International Conference on Current Trends in Theory and Practice of Computer Science. Springer, Berlin, Heidelberg, 2011.
