\section{Introduction}
\label{sec:introduction}

Session types enhance the expressivity of traditional types for
programming languages by allowing the description of structured
communication on heterogeneously typed
channels~\cite{DBLP:conf/concur/Honda93,DBLP:conf/esop/HondaVK98,DBLP:conf/parle/TakeuchiHK94}.
%
Traditional session types are \emph{regular} in the sense that the
sequences of communication actions admitted by a type are in the union
of a regular language (for finite executions) and an $\omega$-regular
language (for infinite executions).
%
Introduced by Thiemann and Vasconcelos, context-free session types
liberate traditional session types from the shackles of tail
recursion, allowing, for example, the safe serialization of arbitrary
recursive datatypes~\cite{thiemann2016context}.

Session types are often used to discipline interactions in concurrent
programs. When associated to (bidirectional, heterogeneous) channels,
session types describe the permitted patterns of interaction. For
example, a type of the form
%
\begin{lstlisting}
  rec x. +{Leaf: Skip, Node: !Int;x;x}
\end{lstlisting}
%
which we abbreviate to \lstinline|TreeChannel|, may describe one end
of a session channel. A process holding such a channel end must first
\emph{select} between choices \lstinline|Leaf| and
\lstinline|Node|. If \lstinline|Leaf| is chosen, then interaction is
terminated, as indicated by the \lstinline|Skip| type without
continuation. Otherwise, the process must send an integer
(\lstinline|!Int|) followed by two complete trees, as witnessed by the
recursive calls occurring after the choice of \lstinline|Node|.
%to \lstinline|TreeChannel|.

A concurrent process holding the other end of the channel 
interacts via a \emph{dual} type:
%
\begin{lstlisting}
  rec y. &{Leaf: Skip, Node: ?Int;y;y}
\end{lstlisting}
%
In this case the process must be ready to offer both choices,
\lstinline|Leaf| and \lstinline|Node|. For the latter option, the
process must further receive an integer (\lstinline|?Int|), followed
by two complete trees.

Regular languages cannot capture such behaviour. The best one can do
with regular session types (and without resorting to channel passing)
is to use a regular type that allows transmitting trees, as well as
many other non tree-like structures. The correct behaviour of
processes interacting on such a channel would need to be checked at
runtime~\cite{almeida.etal_freest-functional-language,thiemann2016context}.

If the algorithmic aspects of type equivalence for regular session
types are well known (Gay and Hole propose an algorithm to decide
subtyting~\cite{DBLP:journals/acta/GayH05}, from which type
equivalence can be derived), the same does not apply to context-free
session types.
%
Thiemann and Vasconcelos~\cite{thiemann2016context} show that the
equivalence of context-free session types is decidable, by reducing
the problem to the verification of bisimulation for Basic Process
Algebra (BPA) which, in turn, was proved decidable by Christensen,
H{\"{u}}ttel, and Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}.
%
Even if the equivalence problem for context-free session types is
known to be decidable, no algorithm has been proposed.
%
Padovani~\cite{DBLP:conf/esop/Padovani17} introduces a language with
context-free session types that avoids the problem of checking the
equivalence of types by requiring annotations in the source
code. Annotations result in the structural alignment between code and
types. This alignment---enforced by an explicit resumption process
operator that breaks sequential composition in types---sidesteps the
problem central to this paper: that of checking type equivalence.
% Instead, the programmer has the additional effort of 
% annotating the types with a resumption operator. 
Furthermore, there are some basic equivalences on types that the
compiler is not able to identify~\cite{DBLP:conf/esop/Padovani17}.

After the breakthrough by Christensen, H\"uttel, and Stirling---a
result that provides no immediate practical algorithm---the problem of
deciding the equivalence of BPA terms has been addressed by several
researchers~\cite{DBLP:conf/mfcs/BurkartCS95,DBLP:journals/iandc/ChristensenHS95,czerwinski2010fast,janvcar1999techniques}.
Most of these papers provide no practical algorithm that can be
readily used, except the one by Czerwinski and Lasota where a
polynomial time algorithm is presented that decides the bisimilarity
of normed context-free processes in
$\mathcal{O}(n^5)$~\cite{czerwinski2010fast}.
%
However, context-free session types are not necessarily normed, which
precludes resorting to this algorithm, or using the original result by
Baeten, Bergstra, and Klop~\cite{baeten1993decidability}, as well as
improvements by Hirshfeld, Jerrum, and
Moller~\cite{DBLP:journals/tcs/HirshfeldJM96,DBLP:conf/concur/HirshfeldM94}.
Moreover, the complexity estimates for deciding bisimilarity in BPA
process are not promising. Kiefer provided an EXPTIME lower bound for
BPA bisimilarity by proving this problem is
EXPTIME-hard~\cite{kiefer2013bpa}, whereas Jan\v car has provided a
double exponential upper bound for this problem and proved that its
complexity is
$\mathcal{O}(2^{2^{\mathsf{pol}(n)}})$~\cite{jancar2012bisimilarity}.

% The three stages

The decidability of deterministic pushdown automata has also been
subject of much
study~\cite{janvcar2008selected,senizergues1997equivalence,stirling2001decidability}.
Several techniques have been proposed to solve the problem, but no
immediate practical algorithm was available until Henry and
SÃ©nizergues provide an algorithm for this
problem~\cite{henry2013lalblc}. Its poor performance however precludes
its incorporation in a compiler.

Our algorithm to decide the equivalence of context-free session types
also allows deciding the bisimilarity of simple grammars (i.e.\
deterministic grammars in Greibach Normal Formal).  It proceeds in
three stages.
%
The \emph{first stage} builds a context-free grammar in Greibach
Normal Formal (GNF)---in fact a simple grammar---from a context-free
session type in a way that bisimulation is preserved.  A basic result
from Baeten, Bergstra, and Klop states that any guarded BPA system can
be transformed into Greibach Normal Formal (GNF) while preserving
bisimulation equivalence, but unfortunately no procedure is
presented~\cite{baeten1993decidability}.
%
The \emph{second stage} prunes the grammar by removing unreachable
symbols in unnormed sequences of non-terminal symbols. This stage
builds on the result of Christensen, H\"uttel, and 
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}.
%
The \emph{third stage} constructs an expansion tree, by alternating
between expansion and simplification steps.  This last stage uses
ideas on the expansion operations proposed by Jan\v car, Moller, and
Hirshfeld~\cite{hirshfeld1996bisimulation,janvcar1999techniques}, and
ideas on the simplification rules proposed by Caucal, Christensen,
H\"uttel, Stirling, Jan\v car, and Moller
~\cite{caucal1986decidabilite,DBLP:journals/iandc/ChristensenHS95,janvcar1999techniques}.
The finite representation of bisimulations of \BPA\ transition
graphs~\cite{caucal1986decidabilite,DBLP:journals/iandc/ChristensenHS95}
is paramount for our results of soundness and completeness.

% Evaluation

The branching nature of the expansion tree confers (at least) an
exponential complexity to the algorithm.
%
However, our experiments with a concrete implementation---both as a
stand-alone tool and incorporated in a
compiler~\cite{almeida.etal_freest-functional-language}---are very
promising: deciding the bisimilarity of two types with a total of 132
nodes in their abstract syntax trees takes on average 3.3
milliseconds and uses less than 8 Mb in a conventional desktop
computer (see Section~\ref{sec:evaluation}).

% However, we propose heuristics that allow constructing the relation
% in a reasonable time.

% Contributions

We present an algorithm to decide the equivalence of context-free
session types, practical to the point that it may be readily included
in any compiler, an exercise that we conducted in
parallel~\cite{almeida.etal_freest-functional-language}.
%
The main contributions of this work are:
%
\begin{itemize}
\item The proposal and implementation of an algorithm to decide type
  equivalence of context-free session types;
\item A proof of its soundness and completeness against the
  declarative definition;
% \item The exploration of several optimizations that make the running
%   time 10,000 times faster.
\item The empirical study of the runtime behaviour of the
  implementation; and
\item The proposal and implementation of an algorithm to decide
  the bisimilarity of simple grammars.
\end{itemize}

% Outline

The rest of the paper is organized as follows: context-free session
types can be found in Section~\ref{sec:contextfreesession}, the
algorithm in Section~\ref{sec:algorithm}, the main results in
Section~\ref{sec:correctness},
% optimizations in Section~\ref{sec:optimisations},
evaluation in Section~\ref{sec:evaluation}, and conclusions in
Section~\ref{sec:conclusion}.

The complete source code for the Haskell implementation is available
at \url{http://rss.di.fc.ul.pt/tools/freest/}.
%
Type bisimulation can be exercised from a browser at
\url{http://rss.di.fc.ul.pt/tryit/CFSTEquiv} and the bisimilarity of
simple grammars at \url{http://rss.di.fc.ul.pt/tryit/SGEquiv}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
