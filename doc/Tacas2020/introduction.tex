\section{Introduction}
\label{sec:introduction}

Session types enhance the expressivity of traditional types for
programming languages by allowing the description of structured
communication on heterogeneously typed
channels~\cite{DBLP:conf/concur/Honda93,DBLP:conf/esop/HondaVK98,DBLP:conf/parle/TakeuchiHK94}.
%
Traditional session types are \emph{regular} in the sense that the
sequences of communication actions admitted by a type are in the union
of a regular language (for finite executions) and an $\omega$-regular
language (for infinite executions).
%
Introduced by Thiemann and Vasconcelos, context-free session types
liberate traditional session types from the shackles of tail
recursion, allowing for example, the safe serialization of arbitrary
recursive datatypes~\cite{thiemann2016context}.

Session types are often used to discipline interactions in concurrent
programs. When associated to (bidirectional, heterogeneous) channels,
session types describe the permitted patterns of interaction. For
example, a type of the form
%
\begin{lstlisting}
  rec x. +{Leaf: Skip, Node: !Int;x;x}
\end{lstlisting}
%
which we abbreviate to \lstinline|TreeChannel|, may describe one end
of a session channel. A process holding such a channel end must first
\emph{select} between choices \lstinline|Leaf| and
\lstinline|Node|. If \lstinline|Leaf| is chosen, then interaction is
terminated, as indicated by \lstinline|Skip|. Otherwise, the process
must send an integer (\lstinline|!Int|) followed by two complete trees,
as witnessed by the recursive calls to \lstinline|TreeChannel|.

A concurrent process holding the other end of the channel 
interacts via a \emph{dual} type:
%
\begin{lstlisting}
  rec y. &{Leaf: Skip, Node: ?Int;y;y}
\end{lstlisting}
%
In this case the process must be ready to offer both choices,
\lstinline|Leaf| and \lstinline|Node|. For the latter option, the
process must further receive an integer (\lstinline|?Int|), followed
by two complete trees.

Regular languages cannot capture such behaviour. The best one can do
with regular session types (and without resorting to channel passing)
is to come up with a regular type that allows transmitting trees, as
well as many other non tree-like structures. Tree behaviour would need
to be checked at runtime~\cite{almeida.etal_freest-functional-language,thiemann2016context}.

If the algorithmic aspects of type equivalence for regular session
types are well known (Gay and Hole authored an algorithm to decide
subtyting~\cite{DBLP:journals/acta/GayH05}, from which type
equivalence can be derived), the same does not apply to context-free
session types.
%
In~\cite{thiemann2016context}, Thiemann and Vasconcelos show that the
equivalence of context-free session types is decidable, by reducing
the problem to the verification of bisimulation for Basic Process
Algebra (BPA) which, in turn, was proved decidable by Christensen,
H{\"{u}}ttel, and Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}.
%
Even if the equivalence problem for context-free session types is
known to be decidable, the only implementation we are aware of is that of
Padovani~\cite{DBLP:conf/esop/Padovani17}, included in a programming
language that requires a structural alignment between code and types
(enforced by an explicit resumption process operator that breaks
sequential composition), thus sidestepping the problem central to this
paper: that of checking type equivalence.

After the breakthrough by Christensen, H\"uttel, and Stirling---a
result that provides no immediate practical algorithm---the problem of
deciding the equivalence of BPA terms has been addressed by several
researchers~\cite{DBLP:conf/mfcs/BurkartCS95,DBLP:journals/iandc/ChristensenHS95,czerwinski2010fast,janvcar1999techniques}.
Most of these papers provide no practical algorithm that can be
readily used, except the one by Czerwinski and Lasota where a
polynomial time algorithm is presented that decides the bisimilarity
of normed context-free processes in
$\mathcal{O}(n^5)$~\cite{czerwinski2010fast}.
%
However, context-free session types are not necessarily normed, which
precludes reducing to this algorithm, or using the original result by
Baeten, Bergstra, and Klop~\cite{baeten1993decidability}, as well as
improvements by Hirshfeld, Jerrum, and
Moller~\cite{DBLP:journals/tcs/HirshfeldJM96,DBLP:conf/concur/HirshfeldM94}.
On the other hand, the complexity estimates for deciding bisimilarity
in BPA process are not promising. Kiefer provided an EXPTIME lower
bound for BPA bisimilarity by proving this problem is
EXPTIME-hard~\cite{kiefer2013bpa}, whereas Jan\v car has provided a
double exponential upper bound for this problem and proved that its
complexity is
$\mathcal{O}(2^{2^{\mathsf{pol}(n)}})$~\cite{jancar2012bisimilarity}.

The decidability of deterministic pushdown automata has
also been a subject of much
study~\cite{janvcar2008selected,senizergues1997equivalence,stirling2001decidability}.
Several techniques have been proposed to solve the problem, however no
immediate practical algorithm was available until Henry and
S{\'e}nizergues provide an implementation of a correct algorithm for
this problem~\cite{henry2013lalblc}. Its poor performance precludes
the incorporation in a compiler.

Our algorithm to decide the equivalence of context-free session types
can also be seen as an algorithm to decide the equivalence of simple
grammars (i.e. deterministic grammars in Greibach Normal Formal). 
It follows three distinct stages.
%
The \emph{first stage} builds a context-free grammar in Greibach
Normal Formal (GNF)---in fact a simple grammar---from a context-free
session type in a way that bisimulation is preserved.  A basic result
from Baeten, Bergstra, and Klop states that any guarded BPA system can
be transformed in Greibach Normal Formal (GNF) while preserving
bisimulation equivalence, but unfortunately no procedure is
presented~\cite{baeten1993decidability}.
%
The \emph{second stage} prunes the grammar by removing unreachable
symbols in unnormed sequences of non-terminal symbols. This stage
builds on the result of Christensen, H\"uttel, and 
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}.
%
The \emph{third stage} constructs an expansion tree, by alternating
between expansion and simplification steps.  This last stage uses
ideas on the expansion operations proposed by Jan\v car, Moller, and
Hirshfeld~\cite{hirshfeld1996bisimulation,janvcar1999techniques}, and
ideas on the simplification rules proposed by Caucal, Christensen,
H\"uttel, Stirling, Jan\v car, and Moller
~\cite{caucal1986decidabilite,
  DBLP:journals/iandc/ChristensenHS95,janvcar1999techniques}.  The
finite representation of bisimulations of \BPA\ transition
graphs~\cite{caucal1986decidabilite,
  DBLP:journals/iandc/ChristensenHS95} is paramount for our results of
soundness and completeness. The branching nature of the expansion tree
confers (at least) an exponential complexity to the 
algorithm. However,
we propose heuristics that allow constructing the relation in a
reasonable time.

% Contributions
We present an algorithm to decide the equivalence of context-free
session types, practical to the point that it may be readily included
in any compiler, an exercise that we conducted in
parallel~\cite{almeida.etal_freest-functional-language}.
%
The main contributions of this work are:
%
\begin{itemize}
\item The proposal and implementation of an algorithm to decide type
  equivalence of context-free session types and that of simple
  grammars (in 300 lines of Haskell code),
\item A proof of its soundness and completeness against the
  declarative definition,
\item The exploration of several optimizations that make the running
  time 10,000 times faster.
%\item validation of the algorithm on several meaningful examples.
\end{itemize}

% Outline

The rest of the paper is organized as follows: context-free session
types can be found in Section~\ref{sec:contextfreesession}, the
algorithm in Section~\ref{sec:algorithm}, the main results in
Section~\ref{sec:soundness}, optimizations in
Section~\ref{sec:optimisations}, evaluation in
Section~\ref{sec:evaluation}, and conclusions in
Section~\ref{sec:conclusion}.
%
The complete source code for the Haskell implementation is available
at \url{http://rss.di.fc.ul.pt/tools/freest/} 
%(and partially in the Appendix).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
