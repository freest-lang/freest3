A Brief Overview of FreeST 1.0.1

FreeST is a concurrent functional language where processes communicate via message passing on bidirectional channels.

Communication on channels is governed by types that describe protocols. Basic types describe the output or the input of some value. Such types may then be composed via a conventional sequential composition operator. Further types include internal and external choice allowing processes to select a choice from a menu or to offer a menu of choices.

Channels are assigned a type at creation time. Processes that read or write (or select or offer choices) on channel ends are guaranteed to follow the protocol as described by the type. This simple fact ensures that programs do not face runtime errors due to unfulfilled expectations on what to find on channels. The compliance of programs againts communication protocols is guaranteed at compile time.

Traditional session types are known to be capable of describing complex protocols in a typeful way. These are essentially regular expressions, even if they may potentially express infinite protocols. The context-free dimension goes one step forward by introducing the sequential composition of types, allowing writing protocols that stream tree-like structures on channels, in a typeful way.

FreeST is a core call-by-value functional language featuring polymorphism, type, datatype and function declarations, in the spirit of languages such as Haskell or OCaml. The syntax is inspired in that of Haskell.

The current compiler, written in Haskell, type checks a source file and interprets the program if validation succeeds. Processes in a FreeST program are mapped into threads in the Haskell language.

FreeST 1.0.1 is minimalist but already allows writing programs that manipulate complex protocols, guaranteeing the absence of runtime errors. Future improvements include primitive syntax for lists, local inference for type application, polymorphism at the level of type and datatype declaration, the ability to exchange structured data on channels (as opposed to scalars only), better error messages, the incorporation of shared channels (channels whose ends may be held by more than one process), and the interface with other programming languages.
