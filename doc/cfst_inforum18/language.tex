\section{A linguagem de programação}
\lstset{language=CFST, style=eclipse}

Esta secção introduz a linguagem apresentando exemplos, a sua sintaxe e semântica e o sistema de tipos. 

A linguagem que propomos é funcional e, como tal, apresenta uma sintaxe bastante semelhante à do Haskell acrescida com primitivas para criação de canais e de envio e receção de dados nos mesmos. Vamos considerar como exemplo ao longo desta secção, o envio de um tipo de dados estruturado em forma de árvore num canal.

A única primitiva de comunicação que a linguagem disponibiliza é troca de mensagens. As mensagens são trocadas em canais de comunicação síncronos e bidirecionais. Cada canal pode ser descrito pelas suas duas extremidades (\textit{endpoints}) e são caracterizados por tipos que descrevem a sequência de mensagens que passam no canal.
Os processos podem escrever numa das pontas do canal ou ler na outra.

Na seguinte figura \ref{fig:types} estão presentes os tipos que estão disponíveis na linguagem.

\input{fig-types}

Os tipos básicos representados na figura \ref{fig:types} são alguns dos existentes no Haskell, inteiros, caracteres, booleanos e ainda o tipo Unit (``()''). Os restantes tipos são compostos pelo operador de sequenciação $\tSemi{\_}{\_}$, pela sua unidade $\tskip$, pelos tipos que representam o envio $\tOut{B}$, a receção $\tIn{B}$, escolhas internas e externas, $\tIChoice{\{l_i\colon T_i\}}_{i\in I}$ e $\tEChoice{\{l_i\colon T_i\}}_{i\in I}$ respetivamente, funções lineares e \textit{unrestricted}, $\tLinFun{T}{T}$ e $\tUnFun{T}{T}$ e ainda pares $\tPair{T}{T}$, tipos de dados $\tDatatype{l_i\colon T_i}_{i\in I}$, tipos recursivos $\tRecK{x}{T}$ e variáveis \textit{x}.

Deste modo, um tipo \lstinline"!Int;?Bool" é um tipo que descreve uma ponta de um canal que espera fazer sequencialmente as operações de enviar um inteiro, receber um booleano e de seguida termina sem mais nenhuma interação.

\subsection{Exemplo: Transmitir uma árvore binária num canal}
\label{sec:example}
Para realizar este exemplo, vamos definir o tipo de dados que representa uma árvore binária:

\begin{lstlisting}
  data Tree = Leaf | Node Int Tree Tree
\end{lstlisting}

O tipo de sessão que descreve o envio da árvore é \lstinline"rec x . +{Leaf: Skip, Node: !Int;x;x}". Este, apresenta uma escolha interna ($\tIChoice{\{l_i\colon T_i\}}_{i\in I}$) que contempla duas opções: \lstinline"Leaf" e \lstinline"Node". No ramo \lstinline"Leaf: Skip" temos o valor \lstinline"Skip" que representa a unidade (não há comunicação). No ramo \lstinline"Node: !Int;x;x" podemos observar a chamada recursiva (\lstinline"rec") do tipo para que seja possível enviar as duas subárvores que este define.

Assim sendo, a função que envia árvores binárias num canal tem o seguinte tipo:

\begin{lstlisting}
  sendTree :: forall a => Tree -> (rec x . +{LeafC : Skip, NodeC: !Int;x;x}); a -> a
\end{lstlisting}


No caso em que se envia uma \lstinline"Leaf", é necessário escolher o ramo através da operação \lstinline"select Leaf" que espera um canal que tenha tipo na forma $\tIChoice{\{l_i\colon T_i\}}_{i\in I}$.
Por outro lado, quando se envia um \lstinline"Node", selecionamos o ramo certo: \lstinline"select Node" e ficamos com o tipo $\tSemi{\tOut{\inte}}{\tSemi{x}{x}}$, assim sendo, primeiro enviamos o inteiro v no canal c ($\sende{v}{c}$) de seguida, é necessário fazer uma chamada recursiva à função para as duas subárvores.

\begin{lstlisting}
  sendTree[rec x . +{LeafC : Skip, NodeC: !Int;x;x}] l c1
  sendTree[Skip] r c2
\end{lstlisting}

O polimorfismo, presente no tipo da função raramente é considerado com tipos de sessão. No entanto, como se pode observar no exemplo, este aparece de forma bastante natural, visto que, o envio de uma árvore generaliza o envio de um único valor, que é polimórfico.

As chamadas a funções polimórficas, são na forma \lstinline"sendTree [Skip]" porque nesta linguagem é necessário especificar o tipo de que as variáveis (neste caso \textit{a}) vão adotar na chamada recursiva.

A função que recebe a árvore binária é análoga mas com o tipo de sessão dual \lstinline"rec x . &{Leaf: Skip, Node: ?Int;x;x}" que, em vez de impor a seleção de um dos ramos (\lstinline"select"), oferece uma escolha $\matche{tree}{\{l_i\,\to\,S_i\}_{i\in I}}$ dos mesmos.
\begin{lstlisting}  
  receiveTree c =
    match c with
      LeafC c1 -> (Leaf, c1)
      NodeC c1 ->
        let x, c2 = receive c1 in
        let left, c3 = receiveTree [rec x.&{LeafC: Skip, NodeC: ?Int;x;x}] c2 in
        let right, c4 = receiveTree [Skip] c3 in
        (Node x left right, c4)
\end{lstlisting}


\subsection{Expressões}
A figura \ref{fig:expressions} apresenta a sintaxe para as expressões da linguagem. As expressões básicas (para os tipos básicos) são inteiros (ex: 1), caracteres (ex: 'a'), booleanos (True e False) e ainda o tipo Unit (``()'').
As aplicações, operações de envio e receção em canais e expressões para escolhas foram brevemente descritas na secção \ref{sec:example}

Das restantes expressões, é importante realçar as operações de criação de canais e de fios de execução (\textit{threads}).
A operação de criação de canais \lstinline"new T", devolve um par com as duas extremidades do canal que são descritas pelo tipo T. Mais precisamente, a primeira extremidade (primeiro elemento do par) é descrita pelo tipo T e a segunda extremidade (segundo elemento) pelo seu dual (\textbf{dualof} T).
A expressão \lstinline"fork e" é responsável por criar um novo fio de execução onde a expressão e vai ser executada, esta operação devolve $\unite$.

\input{fig-expressions}
\subsection{Validação}

Para garantir que o sistema está isento de erros a nossa fase de validação contempla com um sistema de \textit{kinding} para assegurar a boa formação dos tipos, uma verificação de tipos onde se verifica se todas as expressões têm o tipo esperado e uma parte que define quando é que dois tipos são equivalentes.

\subsubsection{Sistema de \textit{kinding}}
O sistema de \textit{kinding} tem como objetivo assegurar a boa formação dos tipos. Para além de verificar se os tipos são bem formados classifica-os nas categorias de tipos de sessão ou tipos gerais. Associa ainda multiplicidades aos tipos (linear ou \textit{unrestricted}).
Por exemplo, o tipo $\tOut{\inte}$ é bem formado e é um tipo de sessão linear, isto é, só pode ser utilizado uma vez. Por outro lado o tipo $\tRec{x}{\tSemi{a}{x}}$ é mal formado se a variável \textit{a} não estiver no ambiente de \textit{kinding} (onde estão todas as associações de variáveis com os respetivos \textit{kinds}).

\subsubsection{Verificação de tipos}
\label{sec:typecheck}
Para fazermos a verificação de tipos utilizámos um sistema bidirecional, isto é, distinguimos duas relações:
\begin{itemize}
\item Dado um contexto e uma expressão, sintetizar o tipo T: \input{fig-synthesize}
\item Dado um contexto, uma expressão e um tipo verificar o tipo da expressão de encontro ao tipo esperado:
\input{fig-checkAgainst}
\end{itemize}

\subsubsection{Equivalencia de tipos}

Determinar se dois tipos são equivalentes apresenta diversos desafios. O artigo apresentado por Christensen et. al \cite{decidable-CFP-bisimilarity} procura mostrar que a equivalência de tipos é decidível para processos independentes do contexto, contudo não define diretamente um algoritmo.

O algoritmo que utilizamos está baseado nas ideias de Jančar et. al \cite{bisimilarity} em que traduzimos um tipo de sessão numa gramática independente do contexto e onde geramos uma árvore de expansão. Este algoritmo, tal como está implementado ainda não é completo, visto que, há tipos que sabemos equivalentes mas que o algoritmo diz não serem. Este algoritmo é ainda trabalho que está em progresso.

% que o algoritmo tal como implementado ainda nao é completo (há tipos de sabemos equivalentes, mas q o algoritmo diz nao serem); que estamos a trabalhar no assunto. 

\subsection{Geração de código}

A linguagem que apresentamos é \textit{call-by-value} e o Haskell (código gerado) é \textit{call-by-name}, isto é, apenas computa as expressões que são passadas como argumento quando esta são utilizadas em vez de computar antes de chamar a função. Para resolver esta questão, tirámos partido da extensão da linguagem Haskell \textit{BangPatterns} que, se usar-mos um sinal de ! antes de cada parâmetro força a avaliação do mesmo. Uma função \lstinline"fun x = e" quando traduzida fica \lstinline"fun !x = e".

O código gerado relativo às operações de comunicação presentes na figura \ref{fig:expressions} foi implementado recorrendo a uma \textit{MVar} que é uma zona de memória mutável que apenas tem dois estados, ou vazio ou um valor do tipo t. Tem duas operações fundamentais \textit{putMVar} para escrever nessa zona de memória (operação de \lstinline"send") e \textit{takeMVar} para ler dessa zona (operação de \lstinline"receive").

Uma \textit{MVar} t têm um tipo associado (t) que é sempre o mesmo para cada \textit{MVar}. Como esta é utilizada para a implementação dos canais de comunicação necessitamos que o seu tipo possa variar para que seja possível enviar, por exemplo, um valor inteiro seguido de um booleano (\lstinline"!Int;!Bool"). Para que o sistema de tipos do Haskell não verifique os tipos que circulam nos canais utilizámos uma primitiva do Haskell que converte um valor de um tipo noutro. Apesar de insegura, esta primitiva não apresenta qualquer problema porque fazemos a nossa própria verificação de tipos (secção \ref{sec:typecheck}).

O código gerado está escrito na linguagem Haskell e derivado disso, as operações de envio ($\sende{v}{c}$), receção ($\recve{c}$), criação de canais ($\newe{T}$) e criação de fios de execução ($\forke{e}$) são forçosamente operações sobre um mónade, mais precisamente, são operações de IO.

Este facto representa uma dificuldade que é decidir quando traduzir as expressões para código de um mónade ou não. A cada momento da tradução ($[\![e]\!]$) apenas temos disponível uma expressão, que sabemos se é monádica ou não, mas não temos qualquer informação acerca das expressões anteriores (na mesma função). Se, num dado momento, encontramos uma expressão que origina código monádico, teríamos de retraduzir o código anterior para estar também na forma monádica.

A nossa aproximação foi resolver este problema antes de aplicar a função de tradução, isto é, anotar a árvore sintática com valores booleanos que representam o estado que é esperado de cada expressão. Antes disso, é necessário percorrer as expressões para saber que funções são monádicas (têm alguma expressão monádica), isto porque, as chamadas a funções são apenas aplicações de variáveis.

Assim sendo, geramos código para cada expressão com base na tabela \ref{tab:monad} que contempla o valor esperado e o encontrado pela função de tradução a cada momento da geração de código.

% Assim sendo, após a primeira iteração obtemos uma estrutura com as funções e um valor booleano associado que indica se são monádicas. Após esta fase, vamos anotar a árvore sintática e terminamos este processo com os valores esperados para cada nó da árvore.

% Neste momento, a função de tradução, para cada expressão, tem informação acerca do valor monádico esperado e do encontrado (na própria função de tradução).

% A tabela \ref{tab:monad} contempla as combinações dos valores monádicos encontrados e esperados assim como o código que deve ser gerado em cada um dos casos.

\begin{table}
\begin{center}
  \begin{tabular}[ht!]{| c | c | c |}
    \hline  
    \quad Valor esperado \quad&\quad Valor encontrado \quad&\quad Código gerado \quad\\\hline
    False & False & e \\
    True & False & \lstinline"return e" \\
    True & True & e \\
    False & True & \lstinline"e >>= x -> x" \\
    \hline
  \end{tabular}
  \vspace{0.2cm}
  \caption{Tabela para geração de código monádico}
  \label{tab:monad}
\end{center}
\end{table}

% Nos casos em o valor esperado e o valor encontrado são iguais a tradução deve ser literal, no caso em que o valor esperado é true e o valor encontrado é false a tradução deve ser \lstinline"return e" para tornar o valor que é suposto ser monádico num valor monádico. No último caso, em que o valor esperado é false e o valor encontrado é true devemos, ao traduzir, retirar o valor do monad: \lstinline"e >>= x -> x".
Por exemplo, o código fonte para o envio de uma árvore seria:

\begin{lstlisting}
  case tree of
    Node x l r ->
      let w1 = select NodeC tree in
      let w2 = send x w1 in
      let w3 = sendTree[rec x . +{LeafC : Skip, NodeC: !Int;x;x}] l w2 in
      let w4 = sendTree[Skip] r w3 in
      w4
\end{lstlisting}

e o código gerado:
\begin{lstlisting}
  case tree of
   Node x l r ->
    _send "NodeC" tree >>=
    \w1 -> _send x w1 >>=
    \w2 -> ((sendTree l) w2) >>=
    \w3 -> ((sendTree r) w3) >>=
    \w4 -> return w4 
\end{lstlisting}

Note-se que, como são enviados e recebidos valores o código encontra-se num monáde de IO. 


\subsection{Testes}

Foram realizados diversos tipos de testes, com diversas ferramentas para aferir a robustez do compilador. As ferramentas que utilizámos foram o \textit{HSpec}\footnote{\url{http://hspec.github.io/}} e o \textit{HUnit}\footnote{\url{https://github.com/hspec/HUnit}} para desenvolver os testes e o \textit{HPC}\footnote{\url{https://wiki.haskell.org/Haskell_program_coverage}} para aferir a cobertura dos testes. Foram feitos testes unitários para testar diversas funções isoladamente e ainda testes com programas, nos quais escrevemos um programa na linguagem apresentada e verificamos se o seu resultado é o esperado.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "cfst-inforum18"
%%% End:
