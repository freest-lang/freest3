\section{A Linguagem}
\lstset{language=CFST}
Esta secção introduz a linguagem apresentando exemplos, a sua sintaxe e semântica e o sistema de tipos. 

A linguagem que propomos é funcional e, como tal, apresenta uma sintaxe bastante semelhante à do Haskell acrescida com primitivas para criação de canais e de envio e receção de dados nos mesmos. Vamos considerar como exemplo ao longo desta secção, o envio de um tipo de dados estruturado em forma de árvore num canal.

A única primitiva de comunicação que a linguagem disponibiliza é troca de mensagens. As mensagens são trocadas em canais de comunicação síncronos e bidirecionais. Cada canal pode ser descrito pelas suas duas extremidades (\textit{endpoints}) e são caracterizados por tipos que descrevem a sequência de mensagens que passam no canal.
Os processos podem escrever numa das pontas do canal ou ler na outra.

Na seguinte figura \ref{fig:types} estão presentes os tipos que estão disponíveis na linguagem.

\input{fig-types}

Os tipos básicos representados na figura \ref{fig:types} são alguns dos existentes no Haskell, inteiros, caracteres, booleanos e ainda o tipo Unit (``()''). Os restantes tipos são compostos pelo operador de sequenciação $\tSemi{\_}{\_}$, pela sua unidade $\tskip$, pelos tipos que representam o envio $\tOut{B}$, a receção $\tIn{B}$, escolhas internas e externas, $\tIChoice{\{l_i\colon T_i\}}_{i\in I}$ e $\tEChoice{\{l_i\colon T_i\}}_{i\in I}$ respetivamente, funções lineares e \textit{unrestricted}, $\tLinFun{T}{T}$ e $\tUnFun{T}{T}$ e ainda pares $\tPair{T}{T}$, tipos de dados $\tDatatype{l_i\colon T_i}_{i\in I}$, tipos recursivos $\tRecK{x}{T}$ e variáveis \textit{x}.

Deste modo, um tipo \lstinline"!Int;?Bool;Skip" é um tipo que descreve uma ponta de um canal que espera fazer sequencialmente as operações de enviar um inteiro, receber um booleano e de seguida termina sem mais nenhuma interação.

\subsection{Exemplo: Enviar uma árvore binária num canal}
\label{sec:example}
Para realizar este exemplo, vamos definir o tipo de dados que representa uma árvore binária:

\begin{lstlisting}
  data Tree = Leaf | Node Int Tree Tree
\end{lstlisting}

O tipo de sessão que descreve o envio da árvore é \lstinline"rec x . +{Leaf: Skip, Node: !Int;x;x}". Este, apresenta uma escolha interna ($\tIChoice{\{l_i\colon T_i\}}_{i\in I}$) que contempla duas opções: \lstinline"Leaf" e \lstinline"Node". No ramo \lstinline"Leaf: Skip" temos o valor \lstinline"Skip" que representa a unidade (não há comunicação). No ramo \lstinline"Node: !Int;x;x" podemos observar a chamada recursiva (\lstinline"rec") do tipo para que seja possível enviar as duas subárvores que este define.

Assim sendo, a função que envia árvores binárias num canal tem o seguinte tipo:

\begin{lstlisting}
  sendTree :: forall a => Tree -> (rec x . +{LeafC : Skip, NodeC: !Int;x;x}); a -> a
\end{lstlisting}


No caso em que se envia uma \lstinline"Leaf", é necessário escolher o ramo através da operação \lstinline"select Leaf" que espera um canal que tenha tipo na forma $\tIChoice{\{l_i\colon T_i\}}_{i\in I}$.
Por outro lado, quando se envia um \lstinline"Node", selecionamos o ramo certo: \lstinline"select Node" e ficamos com o tipo $\tSemi{\tOut{\inte}}{\tSemi{x}{x}}$, assim sendo, primeiro enviamos o inteiro v no canal c ($\sende{v}{c}$) de seguida, é necessário fazer uma chamada recursiva à função para as duas subárvores.

\begin{lstlisting}
  sendTree[rec x . +{LeafC : Skip, NodeC: !Int;x;x}] l c1
  sendTree[Skip] r c2
\end{lstlisting}

O polimorfismo, presente no tipo da função raramente é considerado com tipos de sessão. No entanto, como se pode observar no exemplo, este aparece de forma bastante natural, visto que, o envio de uma árvore generaliza o envio de um único valor, que é polimórfico.

As chamadas a funções polimórficas, são na forma \lstinline"sendTree [Skip]" porque nesta linguagem é necessário especificar o tipo de que as variáveis (neste caso \textit{a}) vão adotar na chamada recursiva.

A função que recebe a árvore binária é análoga mas com o tipo de sessão dual \lstinline"rec x . &{Leaf: Skip, Node: ?Int;x;x}" que, em vez de impor a seleção de um dos ramos (\lstinline"select"), oferece uma escolha $\matche{tree}{\{l_i\,\to\,S_i\}_{i\in I}}$ dos mesmos.
\begin{lstlisting}  
  receiveTree c =
    match c with
      LeafC c1 -> (Leaf, c1)
      NodeC c1 ->
        let x, c2 = receive c1 in
        let left, c3 = receiveTree [rec x.&{LeafC: Skip, NodeC: ?Int;x;x}] c2 in
        let right, c4 = receiveTree [Skip] c3 in
        (Node x left right, c4)
\end{lstlisting}


\subsection{Expressões}
A figura \ref{fig:expressions} apresenta a sintaxe para as expressões da linguagem. As expressões básicas (para os tipos básicos) são inteiros (ex: 1), caracteres (ex: 'a'), booleanos (True e False) e ainda o tipo Unit (``()'').
As aplicações, operações de envio e receção em canais e expressões para escolhas foram brevemente descritas na secção \ref{sec:example}

Das restantes expressões, é importante realçar as operações de criação de canais e de fios de execução (\textit{threads}).
A operação de criação de canais \lstinline"new T", devolve um par com as duas extremidades do canal que são descritas pelo tipo T. Mais precisamente, a primeira extremidade (primeiro elemento do par) é descrita pelo tipo T e a segunda extremidade (segundo elemento) pelo seu dual (\textbf{dualof} T).
A expressão \lstinline"fork e" é responsável por criar um novo fio de execução onde a expressão e vai ser executada, esta operação devolve $\unite$.

\input{fig-expressions}
\todo{Kinding + typechecking + type equiv}\\
\subsection{Validação}

Para garantir que o sistema está isento de erros a nossa fase de validação contempla com um sistema de kinding para assegurar a boa formação dos tipos, uma verificação de tipos onde se verifica se todas as expressões têm o tipo esperado e uma parte que define quando é que dois tipos são equivalentes.

\subsubsection{Sistema de kinding}
O sistema de \textit{kinding} tem como objetivo assegurar a boa formação dos tipos. Para além de verificar se os tipos são bem formados classifica-os nas categorias de tipos de sessão ou tipos gerais. Associa ainda multiplicidades aos tipos (linear ou \textit{unrestricted}).
Por exemplo, o tipo $\tOut{Int}$ é bem formado e é um tipo de sessão linear, isto é, só pode ser utilizado uma vez. Por outro lado o tipo $\tRec{x}{\tSemi{a}{x}}$ é mal formado se a variável \textit{a} não estiver no ambiente de kinding (onde estão todas as associações de variáveis com os respetivos kinds).

\subsubsection{Verificação de tipos}
Para fazermos a verificação de tipos utilizámos um sistema bidirecional, isto é, distinguimos duas relações:
\begin{itemize}
\item Dado um contexto e uma expressão, sintetizar o tipo T: \input{fig-synthesize}
\item Dado um contexto, uma expressão e um tipo verificar o tipo da expressão de encontro ao tipo esperado:
\input{fig-checkAgainst}
\end{itemize}

\subsubsection{Equivalencia de tipos}
\todo{TODO: Type equivalence}    \\

\subsection{Geração de código}
A linguagem foi implementada na linguagem Haskell e derivado disso, as operações de envio ($\sende{v}{c}$), receção ($\recve{c}$), criação de canais ($\newe{T}$) e criação de fios de execução ($\forke{e}$) são forçosamente monádicas, mais precisamente, são operações de IO.

Este facto representa uma dificuldade que é decidir quando traduzir as expressões para código monádico. A cada momento da tradução ($[\![e]\!]$) apenas temos disponível uma expressão, que sabemos se é monádica ou não, mas não temos qualquer informação acerca das expressões anteriores (na mesma função). Se, num dado momento, encontramos uma expressão que origina código monádico, teriamos de retraduzir o código anterior para estar também na forma monádica.

A nossa aproximação foi resolver este problema antes de aplicar a função de tradução, isto é, anotar a árvore sintática com valores booleanos que representam o estado que é esperado de cada expressão. Antes disso, é necessário percorrer as expressões para saber que funções são monadicas (têm alguma expressão monádica), isto porque, as chamadas a funções são apenas aplicações de variáveis.

Assim sendo, após a primeira iteração obtemos uma estrutura com as funções e um valor booleano associado que indica se são monádicas. Após esta fase, vamos anotar a árvore sintática e terminamos este processo com os valores esperados para cada nó da árvore.

Neste momento, a função de tradução, para cada expressão, tem informação acerca do valor momádico esperado e do encontrado (na própria função de tradução).

A tabela \ref{tab:monad} contempla as combinações dos valores monádicos encontrados e esperados assim como o código que deve ser gerado em cada um dos casos.

\begin{table}
\begin{center}
  \begin{tabular}[h!]{| c | c | c |}
    \hline  
    \quad Valor esperado \quad&\quad Valor encontrado \quad&\quad Código gerado \quad\\\hline
    False & False & e \\
    True & False & \lstinline"return e" \\
    True & True & e \\
    False & True & \lstinline"e >>= x -> x" \\
    \hline
  \end{tabular}
  \vspace{0.2cm}
  \caption{Tabela para geração de código monádico}
  \label{tab:monad}
\end{center}
\end{table}

Nos casos em o valor esperado e o valor encontrado são iguais a tradução deve ser literal, no caso em que o valor esperado é true e o valor encontrado é false a tradução deve ser \lstinline"return e" para tornar o valor que é suposto ser monádico num valor monádico. No último caso, em que o valor esperado é false e o valor encontrado é true devemos, ao traduzir, retirar o valor do monad: \lstinline"e >>= x -> x".

\subsection{Testes}

 % Foram realizados testes para aferir a robustez do compilador.
\todo{hspec + hunit}\\
\todo{hpc}\\
\todo{testes unitários e programas}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "cfst-inforum18"
%%% End:
