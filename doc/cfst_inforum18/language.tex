\section{A linguagem de programação}
\lstset{language=CFST, style=eclipse}

Esta secção introduz a linguagem apresentando exemplos, a sua sintaxe e semântica e o sistema de tipos. 

A linguagem que propomos é funcional apresentando uma sintaxe bastante semelhante à do Haskell acrescida de primitivas para criação de canais e de envio e receção de dados nos mesmos. Vamos considerar como exemplo ao longo desta secção, o envio num canal de valores de um tipo de dados estruturado em forma de árvore.

As primitivas de comunicação disponibilizadas pela linguagem são a troca de mensagens e as escolhas. As mensagens são trocadas em canais de comunicação síncronos e bidirecionais. Cada canal pode ser descrito pelas suas duas extremidades (\textit{endpoints}) e são caracterizados por tipos que descrevem a sequência de mensagens que passam no canal.
Os processos podem escrever numa das pontas do canal ou ler na outra.

Na seguinte figura \ref{fig:types} estão presentes os tipos que estão disponíveis na linguagem.

\input{fig-types}

Os tipos básicos são parte daqueles existentes no Haskell: inteiros, caracteres, booleanos e ainda o tipo \lstinline"Unit". Os restantes tipos são compostos pelo operador de sequenciação $\tSemi{\_}{\_}$, pela sua unidade $\tskip$, pelos tipos que representam o envio $\tOut{B}$, a receção $\tIn{B}$, escolhas internas e externas, $\tIChoice{\{l_i\colon T_i\}}_{i\in I}$ e $\tEChoice{\{l_i\colon T_i\}}_{i\in I}$ respetivamente, funções lineares e convencionais (\textit{unrestricted}), $\tLinFun{T}{T}$ e $\tUnFun{T}{T}$ e ainda pares $\tPair{T}{T}$, tipos de dados $\tDatatype{l_i\colon T_i}_{i\in I}$, tipos recursivos $\tRecK{x}{T}$ e variáveis \textit{x}.

Deste modo, um tipo \lstinline"!Int;?Bool" é um tipo que descreve uma extremidade de um canal que espera primeiro enviar um inteiro, depois receber um booleano e de seguida termina sem mais nenhuma interação.

\subsection{Exemplo: Transmitir uma árvore binária num canal}
\label{sec:example}
Para realizar este exemplo, vamos definir o tipo de dados que representa uma árvore binária:

\begin{lstlisting}
  data Tree = Leaf | Node Int Tree Tree
\end{lstlisting}

O tipo de sessão que descreve o envio da árvore é \lstinline"rec x . +{Leaf: Skip, Node: !Int;x;x}". Este, apresenta uma escolha interna ($\tIChoice{\{l_i\colon T_i\}}_{i\in I}$) que contempla duas opções: \lstinline"Leaf" e \lstinline"Node". No ramo \lstinline"Leaf: Skip" temos o valor \lstinline"Skip" que representa a unidade (não há comunicação). No ramo \lstinline"Node: !Int;x;x" podemos observar a chamada recursiva (\lstinline"x") do tipo para que seja possível enviar as duas subárvores que este define.

Assim sendo, a função que envia árvores binárias num canal tem o seguinte tipo:

\begin{lstlisting}
  sendTree :: forall a => Tree -> (rec x . +{LeafC : Skip, NodeC: !Int;x;x}); a -> a
\end{lstlisting}


No caso em que se envia uma \lstinline"Leaf", é necessário escolher o ramo através da operação \lstinline"select Leaf" que espera um canal que tenha tipo na forma $\tIChoice{\{l_i\colon T_i\}}_{i\in I}$.
Por outro lado, quando se envia um \lstinline"Node", selecionamos o ramo certo: \lstinline"select Node" e ficamos com o tipo $\tSemi{\tOut{\inte}}{\tSemi{x}{x}}$, assim sendo, primeiro enviamos o inteiro v no canal c ($\sende{v}{c}$) de seguida, é necessário fazer uma chamada recursiva à função para as duas subárvores.

As chamadas a funções recursivas são na forma \lstinline"e[T]" porque nesta linguagem é necessário especificar o tipo que as variáveis vão adotar em cada chamada recursiva.
Neste exemplo, as chamadas recursivas à função \lstinline"sendTree" especificam os tipos que variável \lstinline"a" vai adotar: \lstinline"rec x . +{LeafC : Skip, NodeC: !Int;x;x}" e \lstinline"Skip" respetivamente.
%As chamadas a funções polimórficas, são na forma \lstinline"sendTree [Skip]" porque nesta linguagem é necessário especificar o tipo de que as variáveis (neste caso \textit{a}) vão adotar na chamada recursiva.

\begin{lstlisting}
sendTree t c =
 case t of
   Leaf -> select LeafC c
   Node x l r ->
     let c1 = select NodeC c in
     let c2 = send x c1 in
     let c3 = sendTree[(rec x.+{LeafC : Skip, NodeC: !Int;x;x});a] l c2 in
     let c4 = sendTree[a] r c3 in
     c4

\end{lstlisting}

O polimorfismo presente no tipo da função raramente é considerado com tipos de sessão. No entanto, como se pode observar no exemplo, este aparece de forma bastante natural.%, visto que, o envio de uma árvore generaliza o envio de um único valor, que é polimórfico.

A função que recebe a árvore binária é análoga mas com o tipo de sessão dual \lstinline"rec x . &{Leaf: Skip, Node: ?Int;x;x}" que, em vez de impor a seleção de um dos ramos (\lstinline"select"), oferece uma escolha $\matche{tree}{\{l_i\,\to\,S_i\}_{i\in I}}$ dos mesmos.
\begin{lstlisting}
  receiveTree :: forall a => (rec x.&{LeafC: Skip, NodeC: ?Int;x;x}); a -> (Tree, a)
  receiveTree c =
    match c with
      LeafC c1 -> (Leaf, c1)
      NodeC c1 ->
        let x, c2 = receive c1 in
        let left, c3 = receiveTree [(rec x.&{LeafC: Skip, NodeC: ?Int;x;x});a] c2 in
        let right, c4 = receiveTree [a] c3 in
        (Node x left right, c4)
\end{lstlisting}


\subsection{Expressões}
A figura \ref{fig:expressions} apresenta a sintaxe para as expressões da linguagem. As expressões básicas (para os tipos básicos) são inteiros (ex: \lstinline"1"), caracteres (ex: \lstinline"a"), booleanos (\lstinline"True" e \lstinline"False") e ainda o tipo Unit (\lstinline|()|).
As aplicações, operações de envio e receção em canais e expressões para escolhas foram brevemente descritas na secção \ref{sec:example}

Das restantes expressões, é importante realçar as operações de criação de canais e de fios de execução (\textit{threads}).
A operação de criação de canais \lstinline"new T", devolve um par com as duas extremidades do canal que são descritas pelo tipo T. Mais precisamente, a primeira extremidade (primeiro elemento do par) é descrita pelo tipo T e a segunda extremidade (segundo elemento) pelo seu dual (\textbf{dualof} T), isto é, o tipo com as operações inversas. Por exemplo, o tipo dual de \lstinline|?Int;!Bool| é \lstinline|!Int;?Bool|.
A expressão \lstinline"fork e" é responsável por criar um novo fio de execução onde a expressão e vai ser executada, esta operação devolve $\unite$.

\input{fig-expressions}
\subsection{Validação}

Para garantir que o sistema está isento de erros a nossa fase de validação contempla com um sistema de \textit{kinding} para assegurar a boa formação dos tipos, uma verificação de tipos para assegurar que todas as expressões têm o tipo esperado e uma parte que define quando é que dois tipos são equivalentes.

\subsubsection{Sistema de \textit{kinding}}
O sistema de \textit{kinding} tem como objetivo assegurar a boa formação dos tipos. Para além de verificar se os tipos são bem formados classifica-os nas categorias de tipos de sessão ou tipos gerais. Associa ainda multiplicidades aos tipos (linear ou tradicional).
Por exemplo, o tipo \lstinline|!Int| é bem formado e é um tipo de sessão linear, isto é, só pode ser utilizado uma vez. O seguinte tipo \lstinline|(Int->Bool);Int| não é bem formado porque mistura tipos funcionais com tipos de sessão. Por outro lado o tipo \lstinline|rec x . a;x| é mal formado se a variável \lstinline|a| não estiver no ambiente de \textit{kinding} (onde estão todas as associações de variáveis com os respetivos \textit{kinds}) ou se estiver no ambiente e o seu \textit{kind} não indicar que é um tipo de sessão.

\subsubsection{Verificação de tipos}
Para fazermos a verificação de tipos utilizámos um sistema bidirecional, isto é, distinguimos duas relações:
\begin{itemize}
\item Dado um contexto e uma expressão, sintetizar o tipo T: \input{fig-synthesize}
\item Dado um contexto, uma expressão e um tipo esperado (T), verificar se o tipo da expressão (U) é equivalente ao tipo esperado (através da relação de equivalência $\thicksim$):%, neste caso verifica se U e T são equivalentes ($\Equiv{U}{T}$):
  \input{fig-checkAgainst}  
\end{itemize}

\subsubsection{Equivalência de tipos}

Determinar se dois tipos são equivalentes apresenta diversos desafios. O artigo apresentado por Christensen et al. \cite{decidable-CFP-bisimilarity} mostra que a equivalência de tipos é decidível para processos independentes do contexto, contudo não define diretamente um algoritmo.

O algoritmo que utilizamos está baseado nas ideias de Jančar et al. \cite{bisimilarity} em que traduzimos um tipo de sessão numa gramática independente do contexto e onde geramos uma árvore de expansão. Este algoritmo, tal como está implementado ainda não é completo, visto que, há tipos que sabemos equivalentes mas que o algoritmo diz não serem. Este algoritmo é ainda trabalho que está em progresso.

% que o algoritmo tal como implementado ainda nao é completo (há tipos de sabemos equivalentes, mas q o algoritmo diz nao serem); que estamos a trabalhar no assunto. 

\subsection{Geração de código}
A linguagem alvo da geração de código é Haskell que apresenta quatro desafios principais:

\begin{itemize}
\item  A linguagem que apresentamos é \textit{call-by-value} e o Haskell (código gerado) é \textit{call-by-name}, isto é, apenas computa as expressões que são passadas como argumento quando estas são utilizadas em vez de computar antes de chamar a função. Para resolver esta questão, tirámos partido da extensão da linguagem Haskell \textit{BangPatterns} que, permite a utilização de um ponto de exclamação antes de cada parâmetro força a avaliação do mesmo. Uma função \lstinline"fun x = e" quando traduzida fica \lstinline"fun !x = e".
\newline
\item O código gerado relativo às operações de comunicação presentes na figura \ref{fig:expressions} foi implementado recorrendo a uma \textit{MVar} que é uma zona de memória mutável que apenas tem dois estados, ou vazio ou um valor do tipo t. Tem duas operações fundamentais \textit{putMVar} para escrever nessa zona de memória (operação de \lstinline"send") e \textit{takeMVar} para ler dessa zona (operação de \lstinline"receive").
\newline
\item Uma \textit{MVar} t têm um tipo associado (t) que é sempre o mesmo para cada \textit{MVar}. Como esta é utilizada para a implementação dos canais de comunicação necessitamos que o seu tipo possa variar para que seja possível enviar, por exemplo, um valor inteiro seguido de um booleano (\lstinline"!Int;!Bool"). Para que o sistema de tipos do Haskell não verifique os tipos que circulam nos canais utilizámos uma primitiva do Haskell que converte um valor de um tipo noutro. Apesar de insegura, esta primitiva não apresenta qualquer problema porque fazemos a nossa própria verificação de tipos2.
  As funções que concretizam o envio e a receção de valores em canais, mostram o uso desta primitiva (\lstinline|unsafeCoerce|) e ainda das \textit{MVar} cuja criação está representada pela função \lstinline|_new|:
\begin{lstlisting}[language=Haskell]
  _new = do
    m1 <- newEmptyMVar
    m2 <- newEmptyMVar
    return ((m1, m2), (m2, m1))

  _send x (m1, m2) = do
    putMVar m2 (unsafeCoerce x)
    return (m1, m2)

  _receive (m1, m2) = do
    a <- takeMVar m1
    return ((unsafeCoerce a), (m1, m2))
\end{lstlisting}

\item Como a linguagem alvo da geração de código é Haskell, as operações de envio ($\sende{v}{c}$), de receção ($\recve{c}$), de criação de canais ($\newe{T}$) e de fios de execução ($\forke{e}$) são forçosamente operações sobre um mónade, mais precisamente, são operações de IO.

Este facto representa uma dificuldade que é decidir quando traduzir as expressões para código de um mónade ou não. % A cada momento da tradução ($[\![e]\!]$) apenas temos disponível uma expressão, que sabemos se é monádica ou não, mas não temos qualquer informação acerca das expressões anteriores (na mesma função). Se, num dado momento, encontramos uma expressão que origina código monádico, teríamos de retraduzir o código anterior para estar também na forma monádica.

Para resolver este problema, antes de aplicar a função de tradução, anotámos a árvore sintática com valores booleanos que representam o estado que é esperado de cada expressão. Antes disso, é necessário percorrer as expressões para saber que funções são sobre um mónade, isto é, se têm alguma expressão de IO. Esta fase é necessária porque as chamadas a funções são apenas aplicações de variáveis.

Assim sendo, geramos código para cada expressão com base na tabela \ref{tab:monad} que contempla o valor esperado e o encontrado pela função de tradução a cada momento da geração de código.

% Assim sendo, após a primeira iteração obtemos uma estrutura com as funções e um valor booleano associado que indica se são monádicas. Após esta fase, vamos anotar a árvore sintática e terminamos este processo com os valores esperados para cada nó da árvore.

% Neste momento, a função de tradução, para cada expressão, tem informação acerca do valor monádico esperado e do encontrado (na própria função de tradução).

% A tabela \ref{tab:monad} contempla as combinações dos valores monádicos encontrados e esperados assim como o código que deve ser gerado em cada um dos casos.

\begin{table}
\begin{center}
  \begin{tabular}[ht!]{| c | c | c |}
    \hline  
    \quad Valor esperado \quad&\quad Valor encontrado \quad&\quad Código gerado \quad\\
    \quad (anotação na árvore sintática) \quad&\quad (na função de tradução) \quad& (Haskell) \quad\\\hline
    False & False & \lstinline|e| \\
    True & False & \lstinline|return e| \\
    True & True & \lstinline|e| \\
    False & True & \lstinline|e >>= x -> x| \\
    \hline
  \end{tabular}
  \vspace{0.2cm}
  \caption{Tabela para geração de código}
  \label{tab:monad}
\end{center}
\end{table}

%  
%  
% Nos casos em o valor esperado e o valor encontrado são iguais a tradução deve ser literal, no caso em que o valor esperado é true e o valor encontrado é false a tradução deve ser \lstinline"return e" para tornar o valor que é suposto ser monádico num valor monádico. No último caso, em que o valor esperado é false e o valor encontrado é true devemos, ao traduzir, retirar o valor do monad: \lstinline"e >>= x -> x".
Por exemplo, o código fonte para o envio de uma árvore seria:

\begin{lstlisting}
  sendTree :: forall a => Tree -> (rec x . +{LeafC : Skip, NodeC: !Int;x;x}); a -> a
  sendTree t c =
    case t of
      Leaf -> select LeafC c
      Node x l r ->
        let c1 = select NodeC c in
        let c2 = send x c1 in
        let c3 = sendTree[rec x . +{LeafC : Skip, NodeC: !Int;x;x}] l c2 in
        let c4 = sendTree[Skip] r c3 in
        c4
\end{lstlisting}

e o código gerado:
\begin{lstlisting}[language=Haskell]
  sendTree !t !c =
    case t of 
      Leaf -> _send "LeafC" c 
      Node x l r ->
        _send "NodeC" c >>=
        \c1 -> _send x c1 >>=
        \c2 -> sendTree l c2 >>=
        \c3 -> sendTree r c3 >>=
        \c4 -> return c4 
\end{lstlisting}

Note-se que, como são enviados e recebidos valores o código encontra-se num monáde de IO. 

\end{itemize}

\subsection{Testes}

Foram realizados diversos tipos de testes, com diversas ferramentas para aferir a robustez do compilador. As ferramentas que utilizámos foram o \textit{HSpec}\footnote{\url{http://hspec.github.io/}} e o \textit{HUnit}\footnote{\url{https://github.com/hspec/HUnit}} para desenvolver os testes e o \textit{HPC}\footnote{\url{https://wiki.haskell.org/Haskell_program_coverage}} para aferir a cobertura dos testes. Foram feitos testes unitários para testar diversas funções isoladamente e ainda testes com programas, nos quais escrevemos um programa na linguagem apresentada e verificamos se o seu resultado é o esperado.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "cfst-inforum18"
%%% End:
