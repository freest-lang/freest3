\section{A linguagem de programação}
\lstset{language=CFST, style=eclipse}

Esta secção introduz a linguagem apresentando exemplos, a sua sintaxe e semântica e o sistema de tipos. 

A linguagem que propomos é funcional apresentando uma sintaxe bastante semelhante à do Haskell acrescida de primitivas para criação de canais e de envio e receção de dados nos mesmos. Vamos considerar como exemplo ao longo desta secção, o envio num canal de valores de um tipo de dados estruturado em forma de árvore.

As primitivas de comunicação disponibilizadas pela linguagem são a troca de mensagens e as escolhas. As mensagens são trocadas em canais de comunicação síncronos e bidirecionais. Cada canal pode ser descrito pelas suas duas extremidades (\textit{endpoints}) e são caracterizados por tipos que descrevem a sequência de mensagens que passam no canal.
Os processos podem escrever numa das pontas do canal ou ler na outra.

Na seguinte figura \ref{fig:types} estão presentes os tipos que estão disponíveis na linguagem.

\input{fig-types}

Os tipos básicos são parte daqueles existentes no Haskell: inteiros, caracteres, booleanos e ainda o tipo \lstinline"Unit". Os restantes tipos são compostos pelo operador de sequenciação $\tSemi{\_}{\_}$, pela sua unidade $\tskip$, pelos tipos que representam o envio $\tOut{B}$, a receção $\tIn{B}$, escolhas internas e externas, $\tIChoice{\{l_i\colon T_i\}}_{i\in I}$ e $\tEChoice{\{l_i\colon T_i\}}_{i\in I}$ respetivamente, funções lineares e convencionais (\textit{unrestricted}), $\tLinFun{T}{T}$ e $\tUnFun{T}{T}$ e ainda pares $\tPair{T}{T}$, tipos de dados $\tDatatype{l_i\colon T_i}_{i\in I}$, tipos recursivos $\tRecK{x}{T}$ e variáveis \textit{x}.

Deste modo, um tipo \lstinline"!Int;?Bool" é um tipo que descreve uma extremidade de um canal que espera primeiro enviar um inteiro, depois receber um booleano e de seguida termina sem mais nenhuma interação.

\subsection{Exemplo: Transmitir uma árvore binária num canal}
\label{sec:example}
Para realizar este exemplo, vamos definir o tipo de dados que representa uma árvore binária:

\begin{lstlisting}
  data Tree = Leaf | Node Int Tree Tree
\end{lstlisting}

O tipo de sessão que descreve o envio da árvore é \lstinline"rec x . +{Leaf: Skip, Node: !Int;x;x}". Este, apresenta uma escolha interna ($\tIChoice{\{l_i\colon T_i\}}_{i\in I}$) que contempla duas opções: \lstinline"Leaf" e \lstinline"Node". No ramo \lstinline"Leaf: Skip" temos o valor \lstinline"Skip" que representa a unidade (não há comunicação). No ramo \lstinline"Node: !Int;x;x" podemos observar a chamada recursiva (\lstinline"x") do tipo para que seja possível enviar as duas subárvores que este define.

Assim sendo, a função que envia árvores binárias num canal tem o seguinte tipo:

\begin{lstlisting}
  sendTree :: forall a => Tree -> (rec x . +{LeafC : Skip, NodeC: !Int;x;x}); a -> a
\end{lstlisting}

Neste tipo feita uma abstração sobre o tipo \lstinline|a|. A função recebe uma \lstinline|Tree| e um canal que primeiro corre o protocolo recursivo \lstinline|rec x . +{LeafC : Skip, NodeC: !Int;x;x}| e de seguida o protocolo especificado por \lstinline|a|. O canal especificado por \lstinline|a| é retornado o que deixa o seu processamento para a continuação. Esta abstração é necessária porque com um tipo na forma \lstinline|Tree -> rec x . +{LeafC : Skip, NodeC: !Int;x;x} -> Skip| não é possível continuar após a primeira chamada recursiva.

No caso em que se envia uma \lstinline"Leaf", é necessário escolher o ramo através da operação \lstinline"select Leaf" que espera um canal que tenha tipo na forma $\tIChoice{\{l_i\colon T_i\}}_{i\in I}$.
Por outro lado, quando se envia um \lstinline"Node", selecionamos o ramo certo: \lstinline"select Node" e ficamos com o tipo $\tSemi{\tOut{\inte}}{\tSemi{x}{x}}$, assim sendo, primeiro enviamos o inteiro v no canal c ($\sende{v}{c}$) de seguida, é necessário fazer uma chamada recursiva à função para as duas subárvores.

As chamadas a funções polimórficas são na forma \lstinline"e[T]" porque nesta linguagem é necessário especificar o tipo que as variáveis vão adotar em cada chamada à função. Neste exemplo, as chamadas recursivas à função \lstinline"sendTree" especificam os tipos que variável \lstinline"a" vai adotar: \lstinline|(rec x.+{LeafC : Skip, NodeC: !Int;x;x});a| e \lstinline|a| respetivamente.


\begin{lstlisting}
sendTree t c =
 case t of
   Leaf -> select LeafC c
   Node x l r ->
     let c1 = select NodeC c in
     let c2 = send x c1 in
     let c3 = sendTree[(rec x.+{LeafC : Skip, NodeC: !Int;x;x});a] l c2 in
     let c4 = sendTree[a] r c3 in
     c4

\end{lstlisting}

A função que recebe a árvore binária é análoga mas com o tipo de sessão dual \lstinline"rec x . &{Leaf: Skip, Node: ?Int;x;x}" que, em vez de impor a seleção de um dos ramos (\lstinline"select"), oferece uma escolha $\matche{tree}{\{l_i\,\to\,S_i\}_{i\in I}}$ dos mesmos.
\begin{lstlisting}
  receiveTree :: forall a => (rec x.&{LeafC: Skip, NodeC: ?Int;x;x}); a -> (Tree, a)
  receiveTree c =
    match c with
      LeafC c1 -> (Leaf, c1)
      NodeC c1 ->
        let x, c2 = receive c1 in
        let left, c3 = receiveTree [(rec x.&{LeafC: Skip, NodeC: ?Int;x;x});a] c2 in
        let right, c4 = receiveTree [a] c3 in
        (Node x left right, c4)
\end{lstlisting}


\subsection{Expressões}
A figura \ref{fig:expressions} apresenta a sintaxe para as expressões da linguagem. As expressões básicas (para os tipos básicos) são inteiros (ex: \lstinline"1"), caracteres (ex: \lstinline"a"), booleanos (\lstinline"True" e \lstinline"False") e ainda o tipo Unit (\lstinline|()|).
As aplicações, operações de envio e receção em canais e expressões para escolhas foram brevemente descritas na secção \ref{sec:example}

Das restantes expressões, é importante realçar as operações de criação de canais e de fios de execução (\textit{threads}).
A operação de criação de canais \lstinline"new T", devolve um par com as duas extremidades do canal que são descritas pelo tipo T. Mais precisamente, a primeira extremidade (primeiro elemento do par) é descrita pelo tipo T e a segunda extremidade (segundo elemento) pelo seu dual (\textbf{dualof} T), isto é, o tipo com as operações inversas. Por exemplo, o tipo dual de \lstinline|?Int;!Bool| é \lstinline|!Int;?Bool|.
A expressão \lstinline"fork e" é responsável por criar um novo fio de execução onde a expressão e vai ser executada, esta operação devolve $\unite$.

\input{fig-expressions}
\subsection{Validação}

Para garantir que o sistema está isento de erros a nossa fase de validação contempla com um sistema de \textit{kinding} para assegurar a boa formação dos tipos, uma verificação de tipos para assegurar que todas as expressões têm o tipo esperado e uma parte que define quando é que dois tipos são equivalentes.

\subsubsection{Sistema de \textit{kinding}}
O sistema de \textit{kinding} tem como objetivo assegurar a boa formação dos tipos. Para além de verificar se os tipos são bem formados classifica-os nas categorias de tipos de sessão ou tipos gerais. Associa ainda multiplicidades aos tipos (linear ou tradicional).
Por exemplo, o tipo \lstinline|!Int| é bem formado e é um tipo de sessão linear, isto é, só pode ser utilizado uma vez. O seguinte tipo \lstinline|(Int->Bool);Int| não é bem formado porque mistura tipos funcionais com tipos de sessão. Por outro lado o tipo \lstinline|rec x . a;x| é mal formado se a variável \lstinline|a| não estiver no ambiente de \textit{kinding} (onde estão todas as associações de variáveis com os respetivos \textit{kinds}) ou se estiver no ambiente e o seu \textit{kind} não indicar que é um tipo de sessão.

\subsubsection{Verificação de tipos}
Para fazermos a verificação de tipos utilizámos um sistema bidirecional, isto é, distinguimos duas relações:
\begin{itemize}
\item Dado um contexto e uma expressão, sintetizar o tipo T: \input{fig-synthesize}
\item Dado um contexto, uma expressão e um tipo esperado (T), verificar se o tipo da expressão (U) é equivalente ao tipo esperado (através da relação de equivalência $\thicksim$):%, neste caso verifica se U e T são equivalentes ($\Equiv{U}{T}$):
  \input{fig-checkAgainst}  
\end{itemize}

\subsubsection{Equivalência de tipos}

Determinar se dois tipos são equivalentes apresenta diversos desafios. O artigo apresentado por Christensen et al. \cite{decidable-CFP-bisimilarity} mostra que a equivalência de tipos é decidível para processos independentes do contexto, contudo não define diretamente um algoritmo.

O algoritmo que utilizamos está baseado nas ideias de Jančar et al. \cite{bisimilarity} em que traduzimos um tipo de sessão numa gramática independente do contexto e onde geramos uma árvore de expansão. Este algoritmo, tal como está implementado ainda não é completo, visto que, há tipos que sabemos equivalentes mas que o algoritmo diz não serem. Este algoritmo é ainda trabalho que está em progresso.

% que o algoritmo tal como implementado ainda nao é completo (há tipos de sabemos equivalentes, mas q o algoritmo diz nao serem); que estamos a trabalhar no assunto. 

\subsection{Geração de código}
A linguagem alvo da geração de código é Haskell que apresenta quatro desafios principais:

\begin{itemize}
\item  A linguagem que apresentamos é \textit{call-by-value} e o Haskell (linguagem alvo da geração de código) é \textit{call-by-name}, isto é, apenas computa as expressões que são passadas como argumento quando estas são utilizadas em vez de computar antes de chamar a função. Para resolver esta questão, tirámos partido da extensão da linguagem Haskell \textit{BangPatterns} que, permite a utilização de um ponto de exclamação antes de cada parâmetro forçando assim a avaliação do mesmo. Uma função \lstinline"fun x = e" quando traduzida fica \lstinline"fun !x = e".
\newline
\item O código gerado relativo às operações de comunicação presentes na figura \ref{fig:expressions} foi implementado recorrendo a duas \textit{MVar} que são zonas de memória mutável que apenas tem dois estados, ou vazio ou um valor do tipo t. Tem duas operações fundamentais \textit{putMVar} para escrever nessa zona de memória (operação de \lstinline"send") e \textit{takeMVar} para ler dessa zona (operação de \lstinline"receive").
\newline
\item Uma \textit{MVar} t têm um tipo associado (t) que é sempre o mesmo para cada \textit{MVar}. Como esta é utilizada para a implementação dos canais de comunicação necessitamos que o seu tipo possa variar para que seja possível enviar, por exemplo, um valor inteiro seguido de um booleano (\lstinline"!Int;!Bool"). Para que o sistema de tipos do Haskell não verifique os tipos que circulam nos canais utilizámos uma primitiva que converte um valor de um tipo noutro. Apesar de insegura, esta primitiva não apresenta qualquer problema porque fazemos a nossa própria verificação de tipos.
  As funções que concretizam o envio e a receção de valores em canais, mostram o uso desta primitiva (\lstinline|unsafeCoerce|) e ainda das \textit{MVar} cuja criação está representada pela função \lstinline|_new|:
\begin{lstlisting}[language=Haskell, style=eclipse]
  _new = do
    m1 <- newEmptyMVar
    m2 <- newEmptyMVar
    return ((m1, m2), (m2, m1))

  _send x (m1, m2) = do
    putMVar m2 (unsafeCoerce x)
    return (m1, m2)

  _receive (m1, m2) = do
    a <- takeMVar m1
    return ((unsafeCoerce a), (m1, m2))
\end{lstlisting}

\item Como a linguagem alvo da geração de código é Haskell, as operações de envio ($\sende{v}{c}$), de receção ($\recve{c}$), de criação de canais ($\newe{T}$) e de fios de execução ($\forke{e}$) são forçosamente operações sobre um mónade, mais precisamente, são operações de IO.

Este facto representa uma dificuldade que é decidir quando traduzir as expressões para código de um mónade ou não. 
Para resolver este problema, antes de aplicar a função de tradução, anotámos a árvore sintática com valores booleanos que representam o estado que é esperado de cada expressão, isto é, se é expectável que uma dada expressão seja uma operação sobre um monáde.
Para cada função, é necessário percorrer as suas expressões para determinar as que são operações sobre um mónade, ou seja, as que têm alguma expressão de IO. Esta fase é necessária porque as chamadas a funções são apenas aplicações de variáveis e podem por sua vez, também estar na forma de um monáde.

Assim sendo, geramos código para cada expressão com base na tabela \ref{tab:monad} que contempla o valor esperado (anotado na árvore sintática) e o encontrado pela função de tradução a cada momento da geração de código.

\begin{table}
\begin{center}
  \begin{tabular}[ht!]{| c | c | c |}
    \hline  
    \quad Valor esperado \quad&\quad Valor encontrado \quad&\quad Código gerado \quad\\
    \quad (anotação da árvore sintática) \quad&\quad (na função de tradução) \quad& (Haskell) \quad\\\hline
    \lstinline|False| & \lstinline|False| & \lstinline|e| \\
    \lstinline|True| & \lstinline|False| & \lstinline|return e| \\
    \lstinline|True| & \lstinline|True| & \lstinline|e| \\
    \lstinline|False| & \lstinline|True| & \lstinline|e >>= x -> x| \\
    \hline
  \end{tabular}
  \vspace{0.2cm}
  \caption{Tabela para geração de código}
  \label{tab:monad}
\end{center}
\end{table}

Nos casos em que o valor esperado e o valor encontrado são iguais a tradução deve ser literal. Quando é esperado que uma expressão \lstinline|e| seja uma operação sobre um monáde (valor esperado é \lstinline|True|) e esta não o é (valor encontrado é \lstinline|False|) a tradução deve ser \lstinline"return e" para que a operação passe a ser sobre um monáde. No último caso, em que o valor esperado é \lstinline|False| e o valor encontrado é \lstinline|True| devemos, ao traduzir, retirar a expressão do monáde: \lstinline"e >>= x -> x".

% Nos casos em o valor esperado e o valor encontrado são iguais a tradução deve ser literal, no caso em que o valor esperado é true e o valor encontrado é false a tradução deve ser \lstinline"return e" para tornar o valor que é suposto ser monádico num valor monádico. No último caso, em que o valor esperado é false e o valor encontrado é true devemos, ao traduzir, retirar o valor do monad: \lstinline"e >>= x -> x".
Por exemplo, o código fonte para o envio de uma árvore seria:

\begin{lstlisting}
  sendTree :: forall a => Tree -> (rec x . +{LeafC : Skip, NodeC: !Int;x;x}); a -> a
  sendTree t c =
    case t of
      Leaf -> select LeafC c
      Node x l r ->
        let c1 = select NodeC c in
        let c2 = send x c1 in
        let c3 = sendTree[(rec x . +{LeafC : Skip, NodeC: !Int;x;x});a] l c2 in
        let c4 = sendTree[a] r c3 in
        c4
\end{lstlisting}

e o código gerado:
\begin{lstlisting}[language=Haskell, style=eclipse]
  sendTree !t !c =
    case t of 
      Leaf -> _send "LeafC" c 
      Node x l r ->
        _send "NodeC" c >>=
        \c1 -> _send x c1 >>=
        \c2 -> sendTree l c2 >>=
        \c3 -> sendTree r c3 >>=
        \c4 -> return c4 
\end{lstlisting}

Note-se que, como são enviados e recebidos valores, o código traduzido se encontra num monáde de IO. É ainda importante realçar que após a tradução, os parâmetros (\lstinline|t| e \lstinline|c|) são precedidos do operador \lstinline|!| que devido à extensão \textit{BangPatterns} torna a função \textit{call-by-value}.

\end{itemize}

\subsection{Testes}

Foram realizados diversos tipos de testes para aferir a robustez do compilador. As ferramentas que utilizámos foram o \textit{HSpec}\footnote{\url{http://hspec.github.io/}} e o \textit{HUnit}\footnote{\url{https://github.com/hspec/HUnit}} para desenvolver os testes e o \textit{HPC}\footnote{\url{https://wiki.haskell.org/Haskell_program_coverage}} para aferir a cobertura dos testes.

Foram feitos testes unitários com o intuito de verificar diversas funções isoladamente. Estes permitiram verificar diversas propriedades da linguagem, como por exemplo, se os tipos depois de interpretados têm a representação interna correta, se dois tipos são equivalentes (e vice-versa), se o \textit{kinding} de um tipo é o esperado, entre outras. Deste modo, foi possível verificar se as diversas partes da linguagem têm o comportamento esperado e detetar possíveis erros de implementação.

Foram ainda feitos testes com programas, nos quais escrevemos um programa na linguagem apresentada e verificamos se o seu resultado é o esperado. Nestes testes, o compilador é testado de um modo mais global, uma vez que, para testar um programa é necessário passar por todas as fases do compilador.

% Para além destes testes, foi utilizada a ferramenta \textit{QuickCheck}\footnote{\url{https://github.com/nick8325/quickcheck}} que permitiu testar alguma propriedades do compilador. Para que o resultado do uso desta ferramenta seja significativo, foi necessário garantir que os tipos gerados são tipos bem formados o que é garantido pelo sistema de \textit{kinding}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "cfst-inforum18"
%%% End:

% LocalWords:  classifica-os
