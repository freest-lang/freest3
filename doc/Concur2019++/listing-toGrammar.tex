\begin{lstlisting}[
  caption={Haskell code for stage 1: the conversion of types into grammars},
  label={lst:toGrammar},
  captionpos=b]
type Transitions = Map.Map LTSLabel [TypeVar]
type Productions = Map.Map TypeVar Transitions
type TransState = State (Productions, Int)

toGrammar :: Type -> TransState Word
toGrammar (Skip _) =
  return []
toGrammar (Semi _ t u) = do
  xs <- toGrammar t
  ys <- toGrammar u
  return $ xs ++ ys
toGrammar (Message _ p b) = do
  y <- getProd $ Map.singleton (MessageLabel p b) []
  return [y]
toGrammar (Choice _ p m) = do
  ms <- tMapM toGrammar m
  y <- getProd $ Map.mapKeys (ChoiceLabel p) ms
  return [y]
toGrammar (TypeVar _ x) = do      
  y <- getProd $ Map.singleton (VarLabel x) []
  return [y]
toGrammar (Rec _ (TypeVarBind _ x _) _) =
  return [x]
\end{lstlisting}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

% Old version:
% toGrammar (Rec x t) =
%   | isChecked (Rec x t) = return []
%   | otherwise = do
%     zs <- toGrammar t
%     m <- getTransitions (head zs)
%     addProductions x (Map.map (++ tail zs) m)
%     return [x]
