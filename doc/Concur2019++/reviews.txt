Dear Vasco,

The 30th International Conference on CONCURRENCY THEORY (CONCUR 2019) program committee is sorry to inform you that your submission 83 was rejected, and will not appear in the conference.

Title:  Deciding the bisimilarity of context-free session types

37 papers were accepted out of 93 submissions.

You can find the reviews and scores below.

We'd like to thank you for your submission and still hope that you will participate. Registration for the conference is open, the early bird registration ends at July 7. See

https://event.cwi.nl/concur2019/

Kind regards,

Wan Fokkink & Rob van Glabbeek  (CONCUR 2019 PC chairs)

SUBMISSION: 83
TITLE: Deciding the bisimilarity of context-free session types


----------------------- REVIEW 1 ---------------------
SUBMISSION: 83
TITLE: Deciding the bisimilarity of context-free session types
AUTHORS: Bernardo Almeida, Andreia Mordido and Vasco T. Vasconcelos

----------- Overall evaluation -----------
SCORE: 1 (weak accept)
----- TEXT:
SUMMARY.  This paper presents a sound and complete algorithm to check
whether two context-free session types are bisimilar. Context-free
session types are an extension of (finite-state / tail recursion only)
session types, hence they can specify more complex protocols, e.g., to
transfer a serialised tree-like data structure.

The algorithm is based on a series of earlier work on the decidability
of context-free processes. It is formally shown to be sound and
complete, and has been implemented in Haskell. The authors have also
performed a basic empirical evaluation.


EVALUATION. I think this a generally good paper. I describe a few
pros/cons below.

*Pro*

- This paper proposes a practical solution for a problem that would
otherwise prevent the integration of context-free session types in any
usable programming language. The authors ingeniously combine a series
of techniques used in earlier decidability proofs to conceive a
practical algorithm (they also use some (conceptually simple)
optimisation techniques).

- The theory looks solid, the proofs given in Section 4 are convincing
(from my POV, with limited expertise), and the paper is
self-contained.

- The paper comes with a complete implementation, which is also
 described in details in the paper.



*Cons*

- My main criticism is related the usage of Haskell code to present
 the different steps of the algorithm. Although, I appreciate it is
 convenient for the author as they have implemented this in Haskell,
 it makes it difficult to get a high(er)-level understanding of the
 algorithms. I would have preferred some pseudo-code (or at least
 simplify things a bit so that, e.g., fully qualified names and the
 State monad don't appear).

- The evaluation section doesn't say anything about the size of the
 session types that were used, which makes it difficult to assess the
 exact practical relevance of the algorithm.

- The presentation needs to be improved in some parts, see below.


DETAILED SUGGESTIONS. A few detailed suggestions, typos etc follow.

l76: "Jancar have" -> has

l78: "In its turn" -> ?

l84: what is a simple grammar?

l122-123: what are these polymorphic variables?

l125: I wondered what the mathcal{T} was referring to till I notice
the transition relation for mathcal{P}. It might be worth clarifying
that these are just "dummy" subscript?

l130, rightmost rule: "i in I" and "j in I" missing?

l144 and l152: the P in (X,P) is not the same mathcal{P} in X->aZ in
matcal{P}?

l148: simple grammars are enough because context-free session types
are "deterministic"?

l162: "retrives" -> retrieves

Listing 1: I am not sure how readable this is for readers who don't
know Haskell. What about using pseudo-code? Or at least add some
comments in the code?

l217: what is a (un)normed word?

Example 2: please explain/highlight that the only difference is in X4

l261: adding new branches in a tree doesn't sound like a
"simplification step" to me. Find a better phrasing?

l268: what is a minimal path to X0?

l285: "Upcoming nodes" -> nodes to be processed?

l320: the fact that only one branch needs to be successful should be
clearly stated around l260.

l331-336: this should be said before Listing 1 already.

Section 4.1: toGrammar adds a "!unit" production to each type (hence
certainly not preserving bisimulation), yet this section doesn't treat
this particularity. Am I missing something?

l348: what about putting this in a Definition environment?

Theorem 9: "is a bisimulation"? Also, I'd expect to use coinduction in
this proof, not induction. Can you explain why induction on the
structure of S is ok?

l472: just say 1h40?

l534: where are these tests? How large are they? What sort of
patterns? etc

l548: "circumvents" -> "mitigates"?
----------- Reviewer's confidence -----------
SCORE: 4 ((high))



----------------------- REVIEW 2 ---------------------
SUBMISSION: 83
TITLE: Deciding the bisimilarity of context-free session types
AUTHORS: Bernardo Almeida, Andreia Mordido and Vasco T. Vasconcelos

----------- Overall evaluation -----------
SCORE: -2 (reject)
----- TEXT:
# SUMMARY

The authors discuss an algorithm to decide equivalence of context-free session types, a variant of session types that enables the description of protocols with non-regular but context-free (finite) traces. Typical instances of such protocols arise in the serialization of inductively defined data types such as (syntax) trees and the like. The problem of context-free session types bisimilarity was shown to be decidable in previous work [26]. In this new contribution the authors present an algorithm and a corresponding Haskell implementation that incorporates heuristics reducing the running time significantly, despite the algorithm being exponential in theory.

# EVALUATION

This paper addresses a problem in between theory and practice. Its added value, compared to related ones, comes from (1) the discussion of the equivalence algorithm in a real programming language and (2) a range of heuristics that may dramatically reduce its running time and memory footprint.

The core of the algorithm hinges on expansion trees and two key properties, namely the existence of finite successful branches (when the compared session types are equivalent) and the finiteness of every branch (when the compared session types are not equivalent). These properties are clearly discussed and used in the proofs that the algorithm is correct and complete.

Unfortunately, the algorithm crucially relies on a function to translate session-types into context-free grammars that sometimes produces a grammar that is not bisimilar to the initial session type, even when applied to session types that satisfy all the contractiveness and name-uniqueness assumptions given in Section 2. I'm giving two examples below, the first one being the most serious one.

The session types

$S_1 = \mu X.!int; X$

$S_2 = \mu Y.!int; \mu Z.Y$

are obviously bisimilar, but the toGrammar function is defined in such a way that, when the subterm $\mu Z.Y$ is translated, it results into the empty string [] of variables, because $Y$ is a recursive variable with no associated productions at the time toGrammar analyzes the $\mu Z.Y$ subterm. So, toGrammar produces the following grammar for $S_1$

	X -> !Int X
	#X2 -> !() X
	#X1 -> !Int

and the following grammar for $S_2$

	Y -> !Int
	#X2 -> !() Y
	#X1 -> !Int

where we note that there is no recursion for $Y$ in the second grammar, whereas there is a recursion for $X$ in the first one. As a consequence, $S_2$ turns out to be equivalent to $!int$, while $S_1$ obviously is not. This counterexample has been double-checked using the implementation of the authors, and the above notation for the grammars is the one resulting directly from the tool. It should be noted that the problem is not caused by the fact that the subterm $\mu Z.Y$ does not use $Z$. Indeed, the same issue arises by considering the type

$S_3 = \mu Y.!int; \mu Z.Y; !int; Z$

and, in general, every type where a recursive subterm begins with a variable. Note that both $S_2$ and $S_3$ are contractive according to the definition on page 3. Speaking of contractiveness, there is another problem with toGrammar. If we consider the type

$S_4 = \mu X.skip;X$

this type is contractive according to the definition of the authors, but the algorithm claims that $S_4$ is equivalent to $skip$, which is incorrect because $skip$ is terminated whereas $S_4$ is not.

In summary, the notion of contractiveness and the definition of toGrammar  should be amended, possibly along with the proof of Lemma 5.

A minor complaint I have is that the paper gives too few details to assess the actual impact of the presented heuristics to context-free session types "in the wild", for a number of reasons:
* The improvement in running time refers to a whole test suite for which no details are given, except that it consists of "carefully crafted" pairs of types. I appreciated the availability of the source code, but the test suite is not included.
* If example (2) (page 2) is part of the test suite (as it seems to be, reading between the lines), then it accounts for 4398 seconds of running time out of a grand total of 4624. Does that mean that the remaining examples run on average 1.6 seconds each? With these differences in running times, it is not clear whether the heuristics work well for one single example only, or if they impact evenly all tests. Wouldn't it make more sense to plot the distribution of the achieved speedups for the whole test suite?
* It would have been interesting to see in Figure 1 the impact of each optimization in isolation, in addition to the aggregate values provided. It seems that cleaning up the grammar is by far the most effective optimization, but it is not clear whether that is the case in general or only when combined with the other optimizations.

In general, I think that the authors should provide the reader all the information to understand and possibly reproduce the presented results. To do this, I recommend a more fine-grained presentation of the running times for the test suite and also the publication of the test suite along with the implementation.

In summary, this looks like a potentially nice and valuable contribution, but the technical issues with the toGrammar function require some technical work and it seems risky to accept the paper without having the chance of another round of review.

# DETAILS

* page 3: "...optimizations that cut the running time by 1000000%". This is ambiguous at best. If one says that the running time is cut (= reduced?) by 100% my interpretation is that it goes down to 0, so I don't know whether the sentence makes any sense. What the authors really mean is that the optimized algorithm is 10000x faster than the non-optimized version (beware, on the test suite as a whole).

* page 9, proof of lemma 4: "follows by"

* page 12: "redundant terminal symbols" I'm not sure "redundant" is the appropriate qualification for these symbols, as it suggests the idea that they can be removed without altering the language generated by the grammar. By reading the description in the following page (lines 513-518) it seems like the idea is rather to generate only one production for each terminal symbol, and to reuse the head nonterminal each time the terminal symbol is found instead of generating a new production for each occurrence of the terminal symbol (line 174).

* page 14: "incorporation of subtyping" Note that subtyping for context-free session types is known to be undecidable (see the journal version of [20]).
----------- Reviewer's confidence -----------
SCORE: 5 ((expert))



----------------------- REVIEW 3 ---------------------
SUBMISSION: 83
TITLE: Deciding the bisimilarity of context-free session types
AUTHORS: Bernardo Almeida, Andreia Mordido and Vasco T. Vasconcelos

----------- Overall evaluation -----------
SCORE: -2 (reject)
----- TEXT:
SUMMARY OF THE PAPER

Context-free session types were recently (2016) introduced in [26]
to overcome the limitations of standard (i.e. regular) session types.

The problem of deciding type equivalence over these novel types is
still open, and addressed in this paper.

Section 2 introduces the grammar and the operational semantics of types
(roughly speaking, a subset of the variant of CCS studied by Aceto and
Hennessy in [1]).

Although not stated in the paper, it should be the case that type equivalence
(which is usually defined in a syntactic-oriented way) should coincide with
bisimilarity (which is defined in a semantics oriented way) on the LTS of types.
This is indeed the case for standard binary session types, and it justifies
the study of decision procedures for bisimilarity instead of type equivalence.

Section 3 presents the main parts of the code to check _bisimilarity_
of context-free session types. The main function - named "bisimilar" -
is presented on lines 296 - 298 of page 7.

Section 4 discusses the soundness and the completeness of the function
bisimilar. The main results (Theorem 14 and Theorem 15, page 12) are
obtained via a property of the function "toGrammar" proven in Theorem 9,
page 10. In turns, the more technical results of Section 4 rely on existing
results of [5,6,18].

Section 5 ad Section 6 dwells on the optimisations of the algorithm and
on the benchmarks.


OVERALL EVALUATION

As it stands, the paper has a series of issues:

1) It is not clear why deciding type equivalence is important, as Padovani [20]
  seems to have an implementation that avoids the problem altogether.
  While this is rightfully remarked in the paper, the prose does not offer much
  material to counterbalance this and justify the study of the problem.

2) I think that there are errors in the proofs of the main results.
  The part on major issues in the detailed comments below spell out exactly
  which properties not proven in the paper are currently used in the proofs.


I thus propose to

REJECT THE PAPER


However, I do encourage the authors to fix the issues reported in this review,
and submit an amended version of the paper to future conferences, for I think
it could indeed provide an interesting story.



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




DETAILED COMMENTS


=======================================================================


MAJOR ISSUES


NOTATION: this paper deals with two LTS, one over session types,
and one over sequences of non-terminal symbols (of productions of GNF grammars).
Here I'll denote these LTS as LTS_T and LTS_P.

There are thus two natural bisimilarity, \sim_T and \sim_P, respectively
over types and over non-terminating symbols. The paper tries to establish
a connection between these two relations, but it proceeds in a manner
that leads to problems.

In section 4.1 (lines 354 - 355) the prose tries (failing) to introduce a
bisimulation __between the two different LTS__ that should bridge the gap
between the relations \sim_T and \sim_P.

Let's denote \sim_AH (AH from "ad-hoc") the binary relation that is
_the_ bisimilarity between the states of the two LTS:

\sim_AH \subseteq (LTS_T \cup LTS_P) \times (LTS_T \cup \LTS_P)

Note that in the set inclusion above I used the unions of the LTS
because \sim_AH must be a symmetric relation.


Now we have three bisimilarities, \sim_T, \sim_P, and \sim_AH,
which is the notation sufficient to spell out the solutions to
the major (technical) problems of the paper.


page 10


line 374 "{\mathcal R} is a bisimilarity"


The theorem must be false, because bisimilarities
are symmetric relation, while {\mathcal R} is not symmetric.
Not to mention that a bisimilarity is __the greatest__ bisimulation
of a given kind, and there is no discussion at all about this
in the proof.
In the best case the current proof shows that {\mathcal R}
is a __simulation__ .


------------------------------------------------------------------------------------------------


page 11

(ERR1)
line 440. "If S \sim_T T then, by Theorem 9, we have X_S \sim_P X_T".

No.

If S \sim_T T, then Theorem 9 implies that

S \sim_AH X_S and T \sim_AH X_T

(i.e. the LTS of the types T and S are bisimilar to the LTS of the symbols generated by toGrammar).

These facts alone are not enough to state that X_S \sim_P X_T.

What is missing to make the proof go through is the following property
of the three bisimilarities at hand:


(A) (\sim_AH)^{-1} \cdot \sim_T \cdot \sim_AH \subseteq \sim_P


If we prove (A), then indeed  S \sim_T and Theorem 9 let us prove X_S \sim_P X_T,
because

X_S (\sim_AH)^{-1} S	By Theorem 9
S \sim_T T	   	By hypothesis
T \sim_AH X_T 		By Theorem 9

and thus (A) implies	X_S \sim_P X_T.


------------------------------------------------------------------------------------------------


(ERR2)
line 446. " X_S \sim_P S_T and we would have S \sim_T T, by Theorem 9".

No. In this case we need an analogous of (A) above, namely

(B)  \sim_AH \cdot \sim_P \cdot (\sim_AH)^{-1} \subseteq \sim_T

Using (B) the proof would go indeed through,
because 


S \sim_AH X_S \sim_T X_T (\sim_AH)^{-1} T


would imply the required S \sim_T T.
The reasoning is analogous to the one used in the previous case.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 12

line 455. Same error discussed in (ERR2) above.

line 461. Same error discussed in (ERR1) above.



=======================================================================
=======================================================================



MEDIUM ISSUES


page 2

line 64 "thus sidestepping the problem central to this paper: that of checking type equivalence".

If the problem central to this paper has already been side stepped in implementations
(i.e. it is not necessary to address it to deal with practical issues), then why should
we care about the problem at all?

I think the authors should justify much better the importance of checking type equivalence
for context-free session types.

Is it just a theoretical matter ?
Padovani seems to have already shown in practice it is not necessary.

Are there broader implications ?
For instance, the prose says very little about the impact deciding the equivalence of simple grammars.

Are there limitations in [20] that can be overcome by deciding type equivalence ?

Do the performances obtained via the optimised algorithm
in this paper lead to faster implementations than the one in [20] ?


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 9


(BIS)
line 347 "Consider the relation {\mathcal R} given by".

This is not how to present a new bisimilarity relation. At all.
Plus here the bisimilarity must relate states in different LTS,
and this should be stated clearly.

A clearer way to proceed is to introduce a bisimilarity \sim_AH 
that is _the greatest relation_ such that the expected conditions are true.
Note that bisimilarities are equivalence relations, thus \sim_AH must be
symmetric.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 10


line 374 "{\mathcal R} is a bisimilarity"

2) The notion of bisimilarity used in the theorem is not even defined
  in the paper. See remark (BIS) above.

3) Who cares about a theorem about some relation {\mathcal R} ?? This notation \ phrasing
  hides the actual meaning of the theorem!

  The correct way to spell out the result is by stating that any session type S
  is in the bisimilarity \sim_AH with the grammar toGrammar S:

  \forall S . S \sim_AH toGrammar S.

  In the proof of the theorem then we can use the relation {\mathcal R} defined
  now in the prose, to show that it is indeed a bisimulation (as per the definition of \sim_AH).


====================================================================
====================================================================


MINOR ISSUES

pag. 1

line 34 "for example, the safe serialization of arbitrary recursive datatypes [26]"

What do you mean?
Whichever point the prose tries to make, it should give an example to make it.


------------------------------------------------------------------------------------------------


line 35 "Session types are often used to discipline interactions ..."

Omit "often" or add some info on the other applications of session types in PL.
In fact the whole sentence could we omitted with no loss of useful information,
as the sentences afterwards ("When... interaction. ... form ...)" are much more informative.


------------------------------------------------------------------------------------------------

line 41 "one end of a channel"

One end of a __session__, that is a channel.


------------------------------------------------------------------------------------------------


line 45 same remark as above ("the other end of the channel").


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 2

line 57 "In the aforementioned work"

There is more than one "aforementioned work", so this is ambiguous,
plus it is verbose. It suffices to write "In [26] Thiemann and Vasconcelos".


------------------------------------------------------------------------------------------------


lines 66 - 82

The two paragraph seems more fit for a related works section than an introduction.
Indeed by omitting them the Introduction remains readable. I suggest to move them
elsewhere.


------------------------------------------------------------------------------------------------


line 84 "simple grammars"

What is a simple grammar ?
The definition is given only on page page 4 line 148, and the prose
does not explain anything (not even intuitions), and thus it is not clear
what the Introduction talks about.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 3

line 103 "simple grammars"

Same remark as above.


------------------------------------------------------------------------------------------------


line 133 "Type bisimulation, \sim_T,  is defined in the usual way from the labelled transition system [21]".

As one of the main theorems of the paper (Theorem 15) is about the relation \sim_T,
this relation should be defined in the paper. Currently it is not.

Omit "in the usual way",
1) a reader may have no idea about the usual way
2) such a reader won't be helped anyway by this phrasing

Rationale: just give the definition of \sim_T.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 4

line 145 "\vect{Z}"

The notation is used before being introduced (on line 147).


------------------------------------------------------------------------------------------------


line 152 "The associated bisimulation is denoted by \sim_P".

The relation \sim_P is paramount in Section 4.2, i.e. to
prove the correctness of the function "bisimilar", thus its definition
should be emphasised more.

For example, if the definition of \sim_T was given, then \sim_P
could be introduced by stating that it is defined analogously to \sim_T,
but on the LTS of GNF grammars.


------------------------------------------------------------------------------------------------


line 155 "of the form X_S \rightarrow ..."

How is "X_S" defined ? Is it just a syntactic place holder?


------------------------------------------------------------------------------------------------


line 156 "Function toGrammar"

--> The function toGrammar


------------------------------------------------------------------------------------------------


line 156 "returns a sequence of ..., while computing the remaining productions"

1) sequence -> list
2) I do not understand what the prose means exactly by "while computing the remaining productions"


------------------------------------------------------------------------------------------------


line 180 "Semi t u"

What does "Semi" stand for ?



------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------

page 5


line 185

Apparently the function toGrammar takes as input a context-free session type.
In fact though in the recursive call for the case of recursive types, toGrammar
is applied to a term t that may contain open variables (notably x), and that
therefore is not a session type.
I think the names of types in the code should mirror this more faithfully,
i.e. the function should take as input a "TypeExpr" or "Term" rather
than a "Type".


------------------------------------------------------------------------------------------------


line 205 "due to the deterministic nature of the LTS"

Which LTS ? The one of types or the one of grammars in GNF ?

If it is the one of types, then why is it deterministic ?
Usually this is the case for session types because of the
syntactic restrictions on the __pair-wise different__
labels in branch and choice types.

I do not see this requirement being stated in page 2 (lines 112 - 127).

Anyways, if that's what the authors meant then they should add
the requirement, and replace "deterministic nature of the LTS"
via "syntactic restrictions on branch and choice types".


------------------------------------------------------------------------------------------------


lines 205 - 207 "One can obtain a unique set of ... both types".

1) I am not sure what the sentence means. An example would help.
2) So what ?
  Why is the sentence useful in this part of the prose ?

If I omit the sentence the prose reads just as well.


------------------------------------------------------------------------------------------------


line 210 "produces ... productions"

Repetition.



------------------------------------------------------------------------------------------------


line 213 "[...], write \vect{Y} "

--> we write \vect{Y}



------------------------------------------------------------------------------------------------


line 217 "Christensen Huttel, and Stirling [6]"

--> Christensen, Huttel (Add the coma)

It would be clearer to reference not just the paper but
also the result, for instance [Theorem X, 6].


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 6

line 241 "We can easily see that the last ... is unreachable."


--> "The last ... is unreachable".

Also, explain why this is the case.


------------------------------------------------------------------------------------------------


line 243 - 244 "by pruning" "Pruned productions for the type S"

This is vague. How do we prune ? By hand ? By using the function in Listing 2?

If the example shows the result of applying the function pruneWord,
the prose should say it.


------------------------------------------------------------------------------------------------


line 248 "a node N' is an expansion of N if N' is a minimal set"

1) --> if __the label of N'__ is a minimal set

2) "minimal set" with respect to which order ? Set inclusion ?


------------------------------------------------------------------------------------------------


lines 252 - 253 "An expansion tree ... into a grammar"

The sentence is incomprehensible. I think that the sentence after the ":" is not even English.
Rewrite, and possibly give an example to make your point.


------------------------------------------------------------------------------------------------


line 256 "case in which we decide equivalence positively"

I am lost here.

Surely it is an algorithm that decides, not the authors ("we"),
moreover I do not understand which "equivalence" the prose talks about.
In fact it is not clear at all even which part of the code is being
discussed here.

I suggest to rewrite the paragraph giving explicit pointers to
the lines of code being discussed.


------------------------------------------------------------------------------------------------


line 262 "reflexive pair"

What is a reflexive pair?
I know what a reflexive relation over a set is, but not a pair.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 7

line 276 "Notice that the sibling node ... successive expansions."

Why should a reader notice this? Where is this information used in the rest of the paper ?


------------------------------------------------------------------------------------------------


line 285 "we use a breadth-first search on the expansion tree."

Which are the lines of code that implement the breadth-first search ?
The prose should talk about the code rather than the authors.


------------------------------------------------------------------------------------------------


Section 3.4

There is no text at all that states which is the main function in the code.
It is only much later via the technical results that
a reader realises that the prose aims at proving the correctness of
the function bisimilar.
This is confusing. It should be clear from the beginning which is the
function to be proven sound and complete.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 8

line 320 "the algorithm in Listing 3 decides that S \sim_T T."

1) Vague. Which algorithm in Listing 3 ?
2) The function bisimilar returns a boolean, and the prose should
  stick to what the code does, for example

  " the function bisimilar in Listing 3 applied to S T returns True".


------------------------------------------------------------------------------------------------


Section 4.1 "The two bisimulations coincide"

The title is misleading: it suggests that the  main result of the
(sub)section is that

\sim_T = \sim_P

whereas in fact this subsection
1) implicitly / clumsily introduces _a third_ bisimulation, let's denote it \sim_AH (where AH means ad-hoc),
  between the LTS of types and the LTS of grammars
2) shows in Theorem 9 a property of the function toGrammar, namely that

  for every type S, S \sim_AH toGrammar S


The title of the subsection should reflect the content of the subsection.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 9

line 339  "terminated types"

Terminology: thus far the paper talked about terminated "states" (page 3, line 128)


------------------------------------------------------------------------------------------------

line 344 "induction and the fact that \varepsilon ++ \varepsilon = \varepsilon".

I am not sure why in the case of recursive types the property on empty sequences and ++
is necessary (is it because of line 192 on page 5?).

------------------------------------------------------------------------------------------------

line 345 "To prove that the bisimulations ... coincide,"

This is proven nowhere in the main body of the paper.


------------------------------------------------------------------------------------------------


line 352 "To show that {\mathcal R} is a bisimilarity"

The paper does not even define the notion of bisimilarity necessary for the
statement to be true. As to how to proceed, see remark (BIS) above.


------------------------------------------------------------------------------------------------

line 353 "is not a recursive type"

What do you mean? That it has no top-most \mu binder ?
Then the latter phrasing is clearer.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


-----------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 11

lines 411 -- 414 "For that, we only need ... from {\mathcal R}."

In which cases do we need the analysis on the variable X ?


------------------------------------------------------------------------------------------------


line 416

line 416 "We now focus on the correctness of the algorithm in Listing 3"

Vague. Which algorithm ?


------------------------------------------------------------------------------------------------


line 424 "the bisimulation on a child node implies the bisimulation of its parent node."

What does this mean?
In particular, what is a bisimulation on a (child) node ?


------------------------------------------------------------------------------------------------


line 435 "The results in these two papers also allow unravelling the reason for the distinction,"

1) Which two papers ?
2) Verbose --> "The results in [??, ??] also explain the distinction in the simplification phase "


------------------------------------------------------------------------------------------------


line 437 "These properties ensure the termination ... "

Which properties ?

In fact I suspect that the properties are used in the proofs,
making this sentence redundant. Omit it.


------------------------------------------------------------------------------------------------


line 443 "When S \not\sim_T T, we easily conclude that all branches in the expansion tree are finite"

Omit "easily".


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------

page 12


line 463. "Our algorithm traverses"

Vague. Which algorithm ??


------------------------------------------------------------------------------------------------


line 464. "it will, eventually, reach the empty"

--> it reaches the empty


------------------------------------------------------------------------------------------------


line 469. "carefully crafted pair of types"

pair --> pairS

Vague. "Carefully crafted" is as informative as "not randomly chosen".
State which are the interesting properties of each pair of types,
or omit the whole thing.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------


page 13

line 532. "Carefully crafted"

Same remark as above.


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------

page 14

line 533 "tests comprise valid and invalid equivalence."

I do not understand. What is a "valid equivalence" ??
Moreover, I thought the test cases were just pairs of types, not
equivalences.


------------------------------------------------------------------------------------------------


line 546 "we run example (2)"

I do not understand which example the prose refers to.


------------------------------------------------------------------------------------------------


line 548 "The heuristics we proposed actually circumvents"

--> The heuristics we proposed circumvents
----------- Reviewer's confidence -----------
SCORE: 4 ((high))
