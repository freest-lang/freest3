\lstset{language=freest, numbers=none, escapeinside=||}

\begin{frame}[fragile]{Motivação}
%\vspace*{5mm}

  Os tipos de sessão:
  \begin{itemize}
  \item Foram propostos para responder à necessidade de formalização de trocas de mensagens.
    \pause
  \item Permitem definir protocolos na forma de tipos que representam interações corretas do sistema.
    \pause
  \item Garantem propriedades tais como a inexistência de erros na comunicação e de situações de impasse.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Motivação}
  Contudo, a expressividade dos tipos de sessão está ainda aquém de todos os desafios de comunicação que encontramos em sistemas concorrentes:
  \vspace{3mm}
  \begin{itemize}
  \item Não permitem, em particular, misturar \textit{input} e \textit{output} na mesma escolha.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Exemplo -- Introdução}
%\vspace*{5mm}

  Considere-se o seguinte problema:
  
  Dado $k \in \mathbb{Z}$, qual o maior inteiro $n$ tal que, $\sum_{i=1}^{n} i < k$?
  \pause
  
  Imaginem-se dois processadores:
  \begin{itemize}
  \item Um capaz de gerar sequências de números inteiros, mas sem a capacidade de os somar.
    \pause
  \item Outro capaz de somar números inteiros, mas incapaz de os gerar.
  \end{itemize}  
\end{frame}

\begin{frame}{Exemplo -- Considerações}
  \begin{itemize}
  \item Ambos os processadores estão aptos para comunicar através de canais.
    \vspace*{2mm}
    \pause
  \item Este exemplo simplista retrata o caso em que a interação entre os processos se dá necessariamente nos dois sentidos.
    \vspace*{5mm}
    \pause
  \item Os dois processos deverão estar corretamente tipados e responder às necessidades da comunicação.
  \end{itemize}
\end{frame}

\begin{frame}{Exemplo -- Solução \hfill \color{mLightBrown}Produtor}

  Tirando partido das restrições computacionais dos dois processadores, podemos tentar resolver o problema do seguinte modo:\\
  \pause
  \vspace*{3mm}
 O processo \textbf{produtor}:
  \begin{enumerate}
  \item Gera a sequência de números: 1,2,3,...
    \pause
  \item Envia-a num canal de comunicação.
    \pause
  \item Pára quando receber, no mesmo canal, uma notificação para terminar o envio.
    \pause
  \item A notificação vem na forma de uma marca: \textbf{EOS} (\textit{end-of-stream})
  \end{enumerate}

\end{frame}


\begin{frame}{Exemplo -- Solução \hfill \color{mLightBrown}Consumidor}

  O outro processo, o \textbf{consumidor}:
  \vspace{2mm}
  \begin{enumerate}
  \item Vai somando os números que recebe enquanto a sua soma for menor do que $n$.
    \pause
    \vspace{5mm}
  \item Neste ponto, envia a marca \textbf{EOS}.
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Exemplo -- Implementação}
%  \vspace*{-1cm}
  O canal de comunicação, do lado do \textbf{produtor}, tem o tipo:
  \vspace*{4mm}
  \begin{lstlisting}
        type CanalInt = |\tikzmark{ineos}|?EOS + |\tikzmark{sendInt}|!Int;CanalInt|\tikzmark{recCall}|
\end{lstlisting} 
 
\input{tikz-example-type} 

\onslide<5-> Do lado do \textbf{consumidor} o canal tem o tipo obtido por troca das operações de leitura pelas de escrita, e vice-versa.
\vspace*{4mm} 
\onslide<6->
\begin{lstlisting}
|\hspace{0.1\linewidth}|type CanalIntDual = |\tikzmark{out}|!EOS + |\tikzmark{in}|?Int;CanalIntDual
\end{lstlisting}
\input{tikz-example-type-dual}

\onslide<9->
\centering
\begin{tcolorbox}
  O tipo acima é \textbf{dual} de \lstinline|CanalInt|.

  Abreviamos esse tipo para \lstinline|dualof CanalInt|.
\end{tcolorbox}

\end{frame}

\begin{frame}[fragile]{Exemplo -- Implementação  \hfill \color{mLightBrown}Produtor}
  % \vspace*{-1cm}
  \begin{lstlisting}[xleftmargin=.15\textwidth, xrightmargin=.15\textwidth]
type CanalInt = ?EOS + !Int;CanalInt

    
produtor : CanalInt -> Int -> ()
produtor c i = |\tikzmark{choice}|choice {
  |\tikzmark{pattern}|(c, EOS) = |\tikzmark{receive}|receive -> (),
  c = |\tikzmark{send}|send c i -> produtor c (i+1)
}
  \end{lstlisting}

\input{tikz-example-produtor}
  
\end{frame}


\begin{frame}[fragile]{Exemplo -- Implementação  \hfill \color{mLightBrown}Consumidor}
  % \vspace*{-1cm}
  \begin{lstlisting}[xleftmargin=-.04\textwidth]

dualof CanalInt = !EOS + ?Int;CanalInt
    
consumidor : dualof CanalInt -> Int -> Int -> Int -> Int
consumidor c s n k = if n >= s
  then choice { c = |\tikzmark{eos}|send EOS -> n|$-$|1 }
  else choice { (c, m) = |\tikzmark{rcv}|receive c -> consumidor c (s+m) (n+1) k}
\end{lstlisting}

\input{tikz-example-consumidor}
 
\onslide<4-4>
% %\centering
\begin{tcolorbox}
  As escolhas dos ramos \lstinline|then| e \lstinline|else| são degeneradas (constituídas apenas por um componente).\\
  Poderíamos, neste caso, eliminar a palavra reservada \lstinline|choice|.
\end{tcolorbox}

\end{frame}

\begin{frame}[fragile]{Exemplo -- Implementação  \hfill \color{mLightBrown}Programa principal}
  % \vspace*{-1cm}
  \begin{lstlisting}[xleftmargin=.2\textwidth, xrightmargin=.15\textwidth]
main : Int
main = let
  k = 1000
  (p, c) = |\tikzmark{new}|new CanalInt in
  |\tikzmark{fork}|fork produtor p 1;
  consumidor c 0 0 k|\tikzmark{consumer}|
\end{lstlisting}

\input{tikz-example-main}

\end{frame}

% <- 0
% v 90
% -> 180
% ^ 270

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
 