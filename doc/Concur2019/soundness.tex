\section{Correctness of the algorithm}
\label{sec:soundness}

In this section we prove that our algorithm is sound and complete
with respect to the meta-theory of context-free session types proposed
by Thiemann and Vasconcelos~\cite{thiemann2016context}.

We start by showing that the bisimulation relation on context-free
session types, $\TypeEquiv$, is equivalent to the bisimulation
relation obtained from the productions, $\ProdEquiv$.  Then, based on
results from Caucal~\cite{caucal1986decidabilite}, Christensen,
H{\"{u}}ttel, and Stirling~\cite{DBLP:journals/iandc/ChristensenHS95},
Jan{\v{c}}ar and Moller~\cite{janvcar1999techniques}, we conclude that
our algorithm is sound and complete.

\subsection{The two bisimulations coincide}

Function $\toGrammark$ runs under a monadic context,
\lstinline|TransState|, suitably initialised.
%
The monadic state comprises the productions, the set of visited nodes,
and an integer to generate the fresh variables. At the end of the run,
we are interested on the productions $P$ only.
%
We hence allow ourselves a slight abuse of notation and write
$\vec Y,P = \toGrammarf S$ to denote the result of running function
$\toGrammark$ on input~$S$, under a suitable monadic context.
%
Empty lists are denoted in Haskell by \lstinline|[]|;
in formal languages symbol $\varepsilon$ is used to denote the empty
word; we use both symbols interchangeably.

% Given a $\transStatek$ state $T$, expression $\evalStatek (\toGrammarf
% S)\: T$ runs function function $\toGrammark$ on input~$S$ and
% state~$T$, returns the result of the call (and discards the state).
% In the sequel, we write $\toGrammarf S$ to mean the result of running
% function $\toGrammarf$ on input $S$ under an appropriate state.

For the purpose of providing a bisimulation between context-free
session types and their corresponding symbols in the grammar, we start
with a lemma that relates terminated types~$S$ to the result of a call
to $\toGrammarf S$.

\begin{lemma}
  \label{lem:terminated-togrammar}
  If $\DONE S$, then $\varepsilon,P=\toGrammarf S$.
\end{lemma}

\begin{proof}
  By rule induction on the definition of $\DONE S$. Cases $\skipk$ and
  $\reck$ follow directly from the respective cases in function
  $\toGrammark$ in Listing~\ref{lst:toGrammar}. The case for
  sequential composition follows by induction and the fact that
  $\varepsilon+\!\!+\,\varepsilon=\varepsilon$.
  % Given that all variables in a type are under some $\mu$-binder,
  % there is a simple inductive characterization of $\DONE S$, namely,
  % $\DONE \skipk$, $\DONE{(S;T)}$ if $\DONE S$ and $\DONE T$,
  % $\DONE{(\mu X.S)}$ if $\DONE S$, $\DONE X$, and false in all other
  % cases. The proof then follows by a simple induction on this
  % characterization for the ``if'' direction, and induction on
  % \lstinline|toGrammar| for the ``only if'' direction
\end{proof}

To conclude that the bisimulations on context-free session types and
those on productions coincide, we present a bisimilarity between
context-free session types and the result of \lstinline|toGrammar|.
%
As the implementation of \isCheckedf is not shown, we assume that
$\isCheckedf S$ always terminates and that it returns \lstinline|True|
if and only if $\DONE S$.
%
%% new from here
Consider the relation $\mathcal{R}$ given by:
\[\begin{array}{lll}
	\mathcal{R} = & \{ (\skipk, (\varepsilon, \emptyset))\} \,\cup\\
	& \{(\sharp B,(X,\{X \rightarrow \sharp B\})) \mid \text{$B$ is any base type}\} 
	   \,\cup\\
	& \{ (\star\{l_i\colon S_i\}_{i\in I}, (X, \{X \rightarrow \star l_i
    \vec Y_i\}_{i\in I} \cup (\cup  P_i)_{i\in I})) \mid 
    \begin{array}[t]{l}
    	\!\!\text{$S_i$ is any type, $l_i$ is any label,}\\
    	\!\!\text{$\vec Y_i, P_i = \toGrammarf{S_i}$, $i \in I$ }\\
    	\!\!\text{and $X$ does not occur in $P_i$}\} \,\cup\\
    \end{array}\\
    &\{(S_1;S_2, (\vec X_1\vec X_2,  P_1 \cup  P_2)) \mid
    \text{$S_i$ is any type, $\vec X_i, P_i = \toGrammarf{S_i}, i = 1,2$ } \}\,\cup\\
    & \{(\mu X.S, (\varepsilon, \emptyset)) \mid 
    \text{$S$ is any type and $\isCheckedf \mu X.S$}\}\,\cup\\
    & \{(\mu X.S, (X, \{X \rightarrow a_j \vec {Z_j}\vec Y\}_{j\in J} \cup  P)) \mid 
    \begin{array}[t]{l}
      \!\!\text{$S$ is any type, not } \isCheckedf \mu X.S,\\
      \!\! Y\vec Y, P = \toGrammarf{S}, \text{ $X$ does not}\\
      \!\!\text{occur in $P$ }\text{ and } \{Y \rightarrow a_j \vec {Z_j}\}_{j\in J} 
      \subseteq  P\\
      \!\!\text{are all the transitions from $Y$}\}
    \end{array}\\
\end{array}\]

\begin{lemma}
\label{lemma:bisim_unr}
	For any type $S$, if not $\isCheckedf \mu X.S$ and 
	$(\mu X.S, (X, \{X \rightarrow a_j \vec {Z_j}\vec Y\}_{j\in J} \cup  P))\in \mathcal{R}$
	with $\{Y \rightarrow a_j \vec {Z_j}\}_{j\in J}\subseteq P$, then
	$(\Unravel(\mu X.S), (X, \{X \rightarrow a_j \vec {Z_j}\vec Y\}_{j\in J} \cup  P))
	\in \mathcal{R}$.
\end{lemma}

\begin{proof}
	Notice that $\{Y \rightarrow a_j \vec {Z_j}\}_{j\in J}\subseteq P$ are 
	precisely the first 
	transitions from $\Unravel(\mu X.S)$. Furthermore, since 
	$\subs{\mu X.S}{X} S$ is obtained from $S$ by 
	replacing the occurrences of $X$ by $\mu X.S$, all the productions for
	$\subs{\mu X.S}{X} S$ 
	are given by the productions of $S$, as using $\mu X.S$
	instead of $X$ does not contribute with any new production on $S$.
\end{proof}

We remark that whenever a type $S$ has a transition, then $\isCheckedf S$
does not hold.

\begin{lemma}
\label{lemma:bisim_semi}
	$(S_1;S_2, (\vec X_1\vec X_2,  P_1 \cup  P_2))\in\mathcal{R}$ iff 
	$(S_i, (\vec X_i,  P_i))\in\mathcal{R}$, for $i=1,2$.
\end{lemma}
\begin{proof}
	Assume that $(S_1;S_2, (\vec X_1\vec X_2,  P_1 \cup  P_2))\in\mathcal{R}$
	and $(S_i, (\vec Y_i,  Q_i))\in\mathcal{R}$. Since 
	$ \vec X_i, P_i = \toGrammarf{S_i}$ and, by construction of $\mathcal{R}$,
	we necessarily have $ \vec Y_i, Q_i = \toGrammarf{S_i}$, it follows that
	$\vec Y_i = \vec X_i$ and $Q_i=P_i$. With a similar reasoning we prove the
	reciprocal implication.
\end{proof}

The same argument applies to the proof of the following lemma.

\begin{lemma}
\label{lemma:bisim_choice}
	$(\star\{l_i\colon S_i\}_{i\in I}, (X, \{X \rightarrow \star l_i
    \vec Y_i\}_{i\in I} \cup (\cup  P_i)_{i\in I}))\in\mathcal{R}$ iff 
	$(S_i, (\vec Y_i,  P_i))\in\mathcal{R}$, $i \in I$.
\end{lemma}

Now we prove that the relation $\mathcal{R}$ is a bisimilarity. We do it
by induction. For that, we use the unravelling function proposed 
in~\cite{thiemann2016context}:

\[\begin{aligned}
\Unravel(\mu x . S) &= \Unravel(\subs{\mu X.S}{X} S)\\
\Unravel(S_1;S_2) &= 
\begin{cases}
	\Unravel(S_2) & \Unravel(S_1)=\skipk\\
	\Unravel(S_1);S_2 & \Unravel(S_1)\neq\skipk\\
\end{cases} \\
\Unravel(S)&= S \text{  for all other cases}
\end{aligned}\]
%
Notice that for any recursive type 
$\mu X.S$, $\Unravel(\mu X.S)$ is not a recursive type and preserves the 
transitions from $\mu X.S$.

\begin{theorem}
\label{thm:cfst_vs_grammar}
	$\mathcal{R}$ is a bisimilarity.
\end{theorem}

\begin{proof}
	We prove that for each $(S, (\vec X, P))\in \mathcal{R}$	, if
	$S \LTSderives[a] T$ then $\vec X \rightarrow a \vec Y\in P$
	and $(T, (\vec Y, P'))\in \mathcal{R}$ for some $P'$. The proof is by
	induction on the structure of $S$. With this purpose, whenever $S$ is a 
	recursive type, we reduce the analysis to $\Unravel(S)$, that
	is not recursive. Indeed, without loss of generality, 
	we can always reduce the analysis of $S$
	to the analysis of $\Unravel(S)$
	because when $S$ is not recursive we have
	$\Unravel(S)=S$.
	\begin{itemize}
		\item $(\skipk, (\varepsilon, \emptyset))$: $\skipk$ does not have any
		transition.
		\item $(\sharp B,(X,\{X \rightarrow \sharp B\}))$: by the \LTS,
		$\sharp B\LTSderives[\sharp B] \skipk$ and $X\rightarrow \sharp B$ with
		$(\skipk, (\varepsilon, \emptyset))\in \mathcal{R}$.
		\item $(\star\{l_i\colon S_i\}_{i\in I}, (X, \{X \rightarrow \star l_i
    	\vec Y_i\}_{i\in I} \cup (\cup  P_i)_{i\in I}))$: 
    	$\star\{l_i\colon S_i\}_{i\in I}\LTSderives[l_i] S_i$ and 
    	$X \rightarrow \star l_i \vec Y_i$ for each $i\in I$. By 
    	Lemma~\ref{lemma:bisim_choice}, $(S_i, (\vec Y_i,  P_i))\in\mathcal{R}$
    	for each $i\in I$. 
    	\item $(S_1;S_2, (\vec X_1\vec X_2,  P_1 \cup  P_2))$: start noting
    	that, by Lemma~\ref{lemma:bisim_semi}, 
    	$(S_i, (\vec X_i, P_i))\in \mathcal{R}$ for $i=1,2$. 
    	\begin{itemize}
    	\item if 
    	$S_1;S_2\LTSderives[a] S_1'; S_2$ with $S_1\LTSderives[a] S_1'$, then 
    	$\Unravel(S_1)\LTSderives[a] S_1'$ (recall that $\Unravel(S_1)=S_1$ when
    	$S_1$ is not recursive). 
    	Since $(S_1,(\vec X_1, P_1))\in\mathcal{R}$, we have
    	$(\Unravel(S_1), (\vec X_1, P_1))\in \mathcal{R}$ 
    	(if $S_1$ is not a recursive type, $\Unravel(S_1)$ 
    	coincides with $S_1$, otherwise apply Lemma~\ref{lemma:bisim_unr}).
    	Hence, by induction hypothesis on $\Unravel(S_1)$, we know that 
    	$\vec X_1 \rightarrow a \vec Y_1$ and 
    	$(S_1', (\vec Y_1,P_1'))\in \mathcal{R}$. 
    	By Lemma~\ref{lemma:bisim_semi}, we conclude that 
    	$(S_1';S_2, (\vec Y_1 \vec X_2,P_1'\cup P_2))\in \mathcal{R}$. 
    	\item if $S_1;S_2\LTSderives[a] S_2'$, where $\DONE{S_1}$ and 
    	$S_2\LTSderives[a] S_2'$, it follows that 
    	$\Unravel(S_2)\LTSderives[a] S_2'$. 
    	Since $(S_2, (\vec X_2, P_2))\in \mathcal{R}$ we have 
    	$(\Unravel(S_2), (\vec X_2, P_2))\in \mathcal{R}$ (again, 
    	if $S_2$ is not a recursive type $\Unravel(S_2)=S_2$, 
    	otherwise use Lemma~\ref{lemma:bisim_unr}). 
    	By induction hypothesis on $\Unravel(S_2)$, we thus have
    	$\vec X_2 \rightarrow a \vec Y_2$ where 
    	$(S_2', (\vec Y_2,P_2'))\in \mathcal{R}$. Since $\DONE{S_1}$, by
    	Lemma~\ref{lem:terminated-togrammar} we have $\vec X_1 = \varepsilon$, 
    	hence $\vec X_1 \vec X_2 = \vec X_2 \rightarrow a \vec Y_2$.
    	\end{itemize}
    	\item $(\mu X.S, (\varepsilon, \emptyset))$: in this case, 
    	$\isCheckedf \mu X.S$, thus
    	we do not have any transition (Lemma~\ref{lem:terminated-togrammar}).
    	\item $(\mu X.S, (X, \{X \rightarrow a_j \vec {Z_j}\vec Y\}_{j\in J} \cup  P))$: 
    	if $\mu X.S\LTSderives[b] T$, then $\Unravel(\mu X.S)\LTSderives[b] T$.
    	Furthermore, by Lemma~\ref{lemma:bisim_unr} we know that 
    	$(\Unravel(\mu X.S), (X, \{X \rightarrow a_j \vec {Z_j}\vec Y\}_{j\in J} \cup  P))
    	\in\mathcal{R}$. By induction hypothesis on $\Unravel(\mu X.S)$, 
    	and since $X$ does not occur in $P$, it follows 
    	that $b=a_j$ for some $j\in J$ and $(T, (\vec Z_j \vec Y, P'))\in \mathcal{R}$.
	\end{itemize} 
	The proof that any transition in the productions leads to a transition in 
	the corresponding type is very similar and is also done by induction. 
	For that,
	we only need to recall that the variable $X$ is a fresh variable and, thus, 
	the transitions from $X$ are simply the ones explicitly detailed in each 
	pair from $\mathcal{R}$.
\end{proof}

\subsection{Correctness of the algorithm}

We now focus on the correctness of the algorithm in
Listing~\ref{lst:algorithm}.  Before proceeding to soundness, we
recall the \emph{safeness property} presented by Jan{\v{c}}ar and
Moller.

\begin{proposition} [Safeness Property \cite{janvcar1999techniques}]
  \label{prop:safeness}
  $\vec X \ProdEquiv \vec Y$ if and only if the expansion tree rooted
  at $\{(\vec X, \vec Y)\}$ has a successful branch.
\end{proposition}

Notice that function \lstinline|bisimilar|
(Listing~\ref{lst:algorithm}) builds an expansion tree by alternating
between expansion and simplification operations (reflexive,
congruence and \BPA\ rules), as proposed by Jan{\v{c}}ar and Moller.
%
These simplification rules are \emph{safe}~\cite{janvcar1999techniques}, in the sense that the
application of any rule preserves the bisimulation from a parent node
to at least one child node and, reciprocally, that bisimulation on a
child node implies the bisimulation of its parent node, thus proving
the safeness property.

While the safeness property will be instrumental in proving
soundness, the \emph{finite witness property} is of
utmost importance to prove completeness. This result follows
immediately from the analysis by Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques}, which capitalizes on results by
Caucal~\cite{caucal1986decidabilite}, and Christensen, H{\"{u}}ttel, and
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}:

\begin{proposition} [Finite Witness Property]
\label{finite_witness}
	If $\vec X \ProdEquiv \vec Y$, then the expansion tree rooted at
	$\{(\vec X, \vec Y)\}$ has a finite successful branch.
\end{proposition}

We refer to Caucal, Christensen, H{\"{u}}ttel, and Stirling for
details on the proof of existence of a finite witness, as stated in
Proposition~\ref{finite_witness}. This proof is particularly
interesting in that it highlights the importance of BPA rules and of
pruning productions on reaching such (finite) witness. The results in
these two papers also allows unravelling the reason for the
distinction, in the simplification phase, between the cases where all
the symbols in the grammar are and are not normed, as shown in
Listing~\ref{lst:algorithm}.

These properties ensure the termination of the algorithm, its soundness
and completeness.

\begin{lemma}
\label{lemma:terminates}
	The computation of $\bisimf S T$ always terminates.
\end{lemma}

\begin{proof}
	If $S\TypeEquiv T$ then, by Theorem~\ref{thm:cfst_vs_grammar},
	we have $X_S\ProdEquiv X_T$ and thus the existence of a finite
	successful branch is ensured by the finite witness property. 
	Hence, breadth-first search eventually terminates. 
	
	Case $S\not\TypeEquiv T$, we easily conclude that all branches 
	in the expansion tree are finite and thence $\bisimf S T$ terminates. 
	To conclude that all branches are finite, observe that 
	any infinite branch is successful by definition and thus the 
	safeness property would imply $X_S\ProdEquiv X_T$ and
	we would have $S\TypeEquiv T$.
\end{proof}

%\begin{proof}
%	On the other hand, as observed in~\cite{janvcar1999techniques},
%	the union of nodes along a successful branch is a relation $R$
%	such that $R\subseteq \ProdEquiv$. Hence, any pair $(\vec X, \vec Y)$
%	occurring along a successful branch is such that $\vec X \ProdEquiv \vec Y$,
%	which, by Lemma~\ref{lemma:filtering}, means that $|\vec X|=|\vec Y|$.
%	So, the filtering rule would node exclude any node in the successful branch
%	and, then, also preserved the safeness property.
%\end{proof}

\begin{lemma}
  \label{lem:bisimilar-to-prod}
  If $\bisimf S T$ returns \upshape{\lstinline|True|}, then
  $X_{S} \ProdEquiv X_{T}$.
	% Given two context-free session types $S$ and $T$, if the function
	% \lstinline|equivalent|, presented in Listing~\ref{lst:algorithm},
	% returns \lstinline|true|, then $X_{S} \ProdEquiv X_{T}$.
\end{lemma}

\begin{proof}
  Function \lstinline|bisimilar| returns \lstinline|True| for $S$ and
  $T$ whenever it reaches a (finite) successful branch in the expansion
  tree rooted at $\{(X_{S}, X_{T})\}$. Conclude with the safeness property,
  Proposition~\ref{prop:safeness}.
  % , whenever the expansion tree rooted
  % at $\{(X_{S}, X_{T})\}$ has a (finite) successful branch, we
  % kn that $X_{S} \ProdEquiv X_{T}$.
\end{proof}

From the previous results, the soundness of our algorithm is now
immediate: the algorithm to check the bisimulation of context-free
session types (Listing~\ref{lst:algorithm}) is sound with respect to
the meta-theory of context-free session types.

\begin{theorem}
\label{thm:soundness}
  If $\bisimf ST$ returns \upshape{\lstinline|True|} then $S\TypeEquiv T$.
\end{theorem}

\begin{proof}
  From Theorem~\ref{thm:cfst_vs_grammar} and
  Lemma~\ref{lem:bisimilar-to-prod}.
\end{proof}

\begin{corollary}
	If $S\not\TypeEquiv T$ then $\bisimf ST$ returns \upshape{\lstinline|False|}.
\end{corollary}

\begin{proof}
	From Theorem~\ref{thm:soundness} and Lemma~\ref{lemma:terminates}.
\end{proof}
 
We now prove that the algorithm to check the bisimulation of context-free session 
types is complete with respect to the meta-theory of context-free session
types. The finite witness property is paramount to achieve this result.

\begin{theorem}
\label{thm:completeness}
  If $S \TypeEquiv T$ then $\bisimf S T$ returns
  \upshape{\lstinline|True|}.
\end{theorem}

\begin{proof}
  Assuming that $S \TypeEquiv T$, by Theorem~\ref{thm:cfst_vs_grammar}
  we have $X_{S} \ProdEquiv X_{T}$.  Hence, the Proposition~\ref{finite_witness}
  ensures the existence of a finite successful branch on the
  expansion tree rooted at $\{(X_{S},X_{T})\}$, i.e., a branch
  terminating in an empty node.  Since our algorithm traverses the
  expansion tree using breadth-first search it will, eventually, reach
  the empty node and conclude the bisimulation positively.
\end{proof}

\begin{corollary}
	If $\bisimf ST$ returns \upshape{\lstinline|False|} then $S\not\TypeEquiv T$.
\end{corollary}

\begin{proof}
	From Theorem~\ref{thm:completeness}.
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
