\section{Optimizations}
\label{sec:optimisations}

Armed with the results in Section~\ref{sec:algorithm}, we decided to
benchmark the algorithm on a test suite of carefully crafted pair of
types (more on this in Section~\ref{sec:evaluation}). During this 
process we came across a pair of types,
\begin{equation}
\label{ex:chaotic}
\begin{aligned}
  S &\triangleq \mu x . \&\{ \mathsf{Add}\colon x;x; !\,\intk,
  \mathsf{Const}\colon ?\,\intk;!\intk,
  \mathsf{Mult}\colon x;x;!\,\intk\}
  \\
  T &\triangleq \mu x . \&\{ \mathsf{Add}\colon x;x,
  \mathsf{Const}\colon ?\,\intk,
  \mathsf{Mult}\colon x;x\}; !\,\intk
\end{aligned}
\end{equation}
%
on which function \lstinline|bisimilar| took 4379.98 seconds (that is
one hour and forty minutes) to terminate. This is certainly not a
reasonable running time for an algorithm to be included in a
compiler. Hence we looked into ways to improve the running time. Among
the different optimisations that we tried, three stand out:
\begin{enumerate}
\item Iterate the simplification stage until a fixed point is reached;
\item Use a double-ended queue where promising children are prepended
  rather than appended;
\item Clean redundant terminal symbols in the grammar.
\end{enumerate}

If, on the one hand, we believed that the computation of the expansion
tree could be speeded up by extending the simplification phase, on the
other hand we suspected that a double-ended queue would allow
prioritizing nodes with potential to reach an empty node faster.
%
Iterating the simplification procedure on a given node $N$, the
algorithm computes the simplest possible children nodes derived from
$N$. Of course, we need to make sure that a fixed-point exists, which
we do with Theorem~\ref{thm:fixed_point}.
%
Using a double-ended queue, the algorithm prepends (rather than
appends) nodes that are already empty or whose pairs $(\vec X, \vec Y)$
are such that $|\vec X|\leq 1$ and $|\vec Y| \leq 1$.
%
The revised \lstinline|simplify| function is in Listing~\ref
{lst:enhanced}.

% The next theorem shows that the simplification function that consists
% in applying the reflexive, congruence and \BPA\ rules has a fixed
% point.  The result applies regardless of whether all nonterminal
% symbols symbols are normed or not.

\begin{theorem}
  \label{thm:fixed_point}
  The simplification function that results from applying the
  reflexive, congruence, and \BPA\ rules, has a fixed point in the
  complete partial ordered set
  {\upshape\lstinline|Set (Node, Ancestors)|}, where the set of
  ancestors is supposed to be fixed. % and equal to $A$.
\end{theorem}
%
\begin{proof}
  See appendix.
\end{proof}

% Having proved that the fixed point exists, 
We can now adapt the
simplification phase to, on the one hand, iterate the simplification
rules until reaching a fixed point and, on the other hand, identify
and prepend promising nodes. An improved version of the
\lstinline|simplify| function (listing~\ref{lst:algorithm}) is in
listing~\ref{lst:enhanced}.

\begin{lstlisting}[
  caption={Haskell code for the improved simplification step (replaces
    function \lstinline|simplify| in listing~\ref{lst:algorithm})},
  label={lst:enhanced},
  captionpos=b]
simplify :: Productions -> Node -> Ancestors -> NodeQueue -> NodeQueue
simplify ps n a q = foldr enqueueNode (Queue.dequeue q) nas
  where nas = findFixedPoint ps (Set.singleton (n,a))

enqueueNode :: (Node,Ancestors) -> NodeQueue -> NodeQueue
enqueueNode (n,a) q
 | maxLength n <= 1 = Queue.prepend (n,a) q
 | otherwise        = Queue.append (n,a) q

findFixedPoint :: Productions -> Set.Set (Node,Ancestors) -> 
                    Set.Set (Node,Ancestors)
findFixedPoint ps nas
  | nas == nas' = nas
  | otherwise   = findFixedPoint ps nas'
  where nas' = if allNormed ps
               then foldr (apply ps) nas [reflex,congruence,bpa2]
               else foldr (apply ps) nas [reflex,congruence,bpa1,bpa2]
\end{lstlisting}

Recalling that the size of the expansion tree (also) depends on the 
number of productions in the grammar, the generation of grammars cleaned
of redundant terminal symbols is paramount to reduce the size of the
expansion tree and thus to enhance the performance. We define a 
function \lstinline|addBasicProd| that avoids the blind creation of 
fresh variables in \lstinline|toGrammar (Message p b)| 
(at listing~\ref{lst:toGrammar}) by a prior search for existing productions
with the respective terminal symbols.

The optimisations we propose aim at improving the performance of the
algorithm, however the branching nature of the expansion tree promotes
an exponential complexity: each simplification step (potentially)
generates a polynomial number of nodes, each of which with linear size
on the size of the input.  In turn, the same simplification phase may,
in the worst case, be iterated a linear number of times on the size of
the input.  For these reasons the complexity turns out to be (at least)
exponential.  Nevertheless, these heuristics seem to work quite well
in practice, as we show in the next section.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
