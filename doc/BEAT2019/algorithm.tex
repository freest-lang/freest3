
\section{Type equivalence algorithm}
\label{sec:algorithm}

The main purpose of this work is to present and implement an algorithm to decide the type equivalence problem. In this section, we briefly describe our proposed algorithm. We start by recalling the type equivalence problem.

\begin{definition}[Type equivalence problem]
	Given context-free session types $T_1$ and $T_2$, the type equivalence problem consists in deciding if types $T_1$ and $T_2$ are equivalent, i.e., $T_1\approx T_2$.
\end{definition}

Obviously, our algorithm builds upon a representation of the context-free session types we consider. For this purpose, we recall that Jan{\v{c}}ar and Moller~\cite{janvcar1999techniques} noted that any session type can be seen as a process algebra graph (PA graph). For context-free session types, by considering the finite set of productions $X \LTSderives S$ defined by the labelling transition system, where $X$ ranges over a set of variables $V$, $a$ ranges over the set of actions described above, and $S$ ranges over the terms of the free algebra over $V$ generated by the operators of context-free session types, we are able to represent our types as PA graphs. The vertices of the PA graph are then represented by terms of the algebra, whereas the edges are given by the production rules. We have implemented the construction that given two terms, $T_1$ and $T_2$, determines the underlying PA graph and normalizes it by cleaning terms preceded by unnormed terms, as proposed by~\cite{janvcar1999techniques}. We denote this construction by \texttt{PAGraph}($T_1,T_2$).

We notice that in context-free session types, the production rules are deterministic, meaning that given a variable $X$ and an action $a$, we cannot derive two distinct terms in the algebra. This justifies why we do not need to consider expansion trees, but only an expansion sequence of nodes.

In the following, we focus on how we propose to decide equivalence between two session types. This can easily be lifted to all types. Given two session types $T_1$ and $T_2$, we start by simplifying the PA graph, using the reflexivity, congruence, and BPA1 rules proposed by Jan{\v{c}}ar and Moller~\cite{janvcar1999techniques} (see Appendix~\ref{app:algorithm}). Then, we are left with the task of, recursively, expand the nodes until, either finding $(\varepsilon, \varepsilon)$ - case in which we decide equivalence positively, or failing to obtain new derived nodes - case in which we decide equivalence negatively. The implementation of this function can be found in Appendix~\ref{app:algorithm}. Given $T_1$ and $T_2$, we decide on its equivalence by providing the PA graph underlying these terms, an empty set of ancestors and the parent node of the graph:
\begin{lstlisting}
bisim PAGraph(T1,T2) Set.empty  (Set.singleton (xs, ys))
\end{lstlisting}

Our algorithm gathers the simplification rules presented in~\cite{janvcar1999techniques} and implements the derivation flow on a simplified version of PA graphs, where we consider a sequence of nodes rather than considering a derivation tree. For these reasons, we claim that our implementation is sound. Furthermore, we have tested our algorithm in more than one hundred examples and we have not obtained any false positive nor any true negative result. This reinforces our claim that this algorithm should be sound (and complete).