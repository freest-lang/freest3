\paragraph{Type equivalence algorithm}
\label{sec:algorithm}

% The main purpose of this work is to present and implement an algorithm to decide the type equivalence problem. In this section, we briefly describe our proposed algorithm.
We start by recalling the type equivalence problem.

\begin{quote}
  Given context-free session types $S$ and $T$, the type equivalence
  problem consists in deciding if types $S$ and $T$ are equivalent,
  i.e., $S\sim T$.
\end{quote}

Any algorithm must build upon some representation of the context-free
session types. For this purpose, we recall that Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques} noted that any process can be seen
as a (possible infinite) process algebra graph (PA graph).  Such a
graph can be finitely represented by a finite set of productions
$X \LTSderives \alpha$, where $X$ ranges over a finite set of
\emph{term variables} $V$, $a$ ranges over the set of actions
described above, and $\alpha$ ranges over the terms of the free
algebra over $V$ generated by the semi-colon operator.
The vertices of the PA graph are then represented by terms~$\alpha$ of
the algebra, whereas the edges are given by the production rules.

We build on the notion of expansion trees, only that in our case we
can work with \emph{expansion lists}, given the deterministic nature
of transitions in context-free session types.
% \footnote{PA-graphs for context-free session types are such that,
%   given a variable $X$ and an action $a$, we cannot derive two
%   distinct terms in the algebra.}
%
Nodes in this list are sets of pairs of terms~$\alpha$.
%
Given two session types $S$ and $T$, the first step of the algorithm
builds the PA-graph and the initial node $\{(X,Y)\}$, where~$X$ is the
term variable corresponding to~$S$ and~$Y$ to~$T$. This step further
normalizes $\alpha$-terms by removing terms preceded by unnormed
terms, given that $\alpha \sim \alpha\beta$ whenever $\alpha$ is
unnormed~\cite{janvcar1999techniques}.
%
The algorithm then alternates between simplification and expansion
operations, until either finding an empty node---case in which we
decide equivalence positively---or failing to expand a node---case in
which we decide equivalence negatively.

The simplification procedure builds on  Jan{\v{c}}ar and
Moller rules, namely reflexivity and BPA1.
%
The algorithm, written in Haskell, should be self explanatory.
%
\begin{lstlisting}
bisim :: Graph -> Ancestors -> Node -> Bool
bisim g a n
 | Set.null n' = True
 | otherwise   = case expandNode g n' of
    Nothing  -> False
    Just n'' -> bisim g (Set.union n' a) n''
 where n' = simplify g a n

simplify :: Graph -> Ancestors -> Node -> Node
simplify g a n = foldr (apply g a) n [reflex, bpa1]

apply :: Graph -> Ancestors -> NodeTransformation -> Node -> Node
apply g a trans = Set.foldr (\p n -> Set.union (trans g a p) n) Set.empty

type Graph = Map.Map TermVar (Map.Map Label [TermVar])
type Node = Set.Set ([TermVar], [TermVar])
type Ancestors = Node
type NodeTransformation = Grammar -> Ancestors -> ([TermVar],[TermVar]) -> Node
\end{lstlisting}

We showcase this procedure on a couple of examples. %Details can be
% found in the Appendix.
%
% \begin{example}
%   \label{ex:example1}
Consider two types $S$ and ~$T$.
%
\begin{align*}
  S &\triangleq \mu x. (\oplus\{\ell\colon !\,\intk; \&\{\ell\colon x,
      m\colon \skipk \} , m\colon !\, \boolk; \&\{\ell\colon x,
      m\colon \skipk \} \}); \mu x. (\&\{\ell\colon\skipk, m\colon
      ?\,\boolk; x \})
  \\
  T &\triangleq \mu x. (\oplus\{\ell\colon !\,\intk , m\colon !\,
      \boolk\}; \&\{\ell\colon x, m\colon \mu
      y. (\&\{\ell\colon\skipk, m\colon ?\,\boolk; y \})\})
\end{align*}
%
The associated PA-graph is (TODO).
%
We get the following expansion list for $S\sim T$.
\par\noindent
\begin{tikzcd}[cells={nodes={draw=black}}, column sep=large]
  \enspace (S,T) \enspace \ar[r,"expand"]
& \enspace  (S_1S_3S_5,T_1T_3), (S_2S_4S_5, T_2T_3) \enspace \ar[r,"expand"]
& \enspace  (S_3S_5,T_3), (S_4S_5, T_3) \enspace  
\end{tikzcd} 
$\xrightarrow{\mathit{expand}}$\\\\
\begin{tikzcd}[cells={nodes={draw=black}}, column sep=large]
& \enspace(SS_5,T),(SS_5,T),(S_5,T_4),(S_5,T_4)  \enspace\ar[r,dashed,"bpa1"]
&\enspace (S_5,\varepsilon),(S_5,T_4) \enspace 
\end{tikzcd} 
$\xrightarrow{\mathit{expand}}$ \\\\
\begin{tikzcd}[cells={nodes={draw=black}}, column sep=large]
&\enspace(S_6S_5,T_5T_4),(\varepsilon,\varepsilon) \enspace\ar[r,dashed,"reflex"] 
&\enspace (S_6S_5,T_5T_4)\enspace \ar[r,"expand"]
& \enspace(S_5,T_4)\enspace \ar[r,dashed,"bpa1"]
&\emptyset
\end{tikzcd}
\enspace  $\checkmark$

Now consider the types $R$ and $U$.
%
\begin{align*}
  R \triangleq \mu x.\&\{\ell\colon ?\,\boolk;x, m\colon ?\,\intk;x;x\}
      &&
  U \triangleq \mu x.\&\{\ell\colon ?\,\boolk, m\colon ?\,\intk;x;x\}
\end{align*}
%
The associated PA-graph is (TODO),
%
and the expansion list is as follows.
\par\noindent
\begin{tikzcd}[cells={nodes={draw=black}}, column sep=large]
  (R,U) \ar[r,"expand"]
& (R_1 R,U_1), (R_2 R R, U_2 U U) \ar[r,"expand"]
& (R,\varepsilon), (RR, UU) \ar[r,dashed,"bpa1"] 
& (R,\varepsilon), (U,\varepsilon) 
\end{tikzcd} 
\enspace  $\times$

Our algorithm uses the simplification rules of  Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques} and implements the derivation flow on
a simplified version of PA graphs. For these reasons, we
believe that our implementation is sound. Furthermore, we have tested
our algorithm in more than one hundred examples and we have not
obtained any false positive nor any true negative result. This
reinforces our conviction that this algorithm should be sound (and
possibly complete).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
