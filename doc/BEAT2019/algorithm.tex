
\section{Type equivalence algorithm}
\label{sec:algorithm}

The main purpose of this work is to present and implement an algorithm to decide the type equivalence problem. In this section, we briefly describe our proposed algorithm. We start by recalling the type equivalence problem.

\begin{definition}[Type equivalence problem]
	Given context-free session types $S$ and $T$, the type equivalence problem consists in deciding if types $S$ and $T$ are equivalent, i.e., $S\sim T$.
\end{definition}

Obviously, our algorithm builds upon a representation of the
context-free session types we consider. For this purpose, we recall
that Jan{\v{c}}ar and Moller~\cite{janvcar1999techniques} noted that
any process can be seen as a process algebra graph (PA graph). For
context-free session types, we consider the finite set of
productions $X \LTSderives \alpha$ defined by the labelling transition
system, where $X$ ranges over a finite set of variables $V$, $a$
ranges over the set of actions described above, and $\alpha$ ranges over
the terms of the free algebra over $V$ generated by the semi-colon
operator.
% operators of
% context-free session types, we are able to represent our types as PA
% graphs.
The vertices of the PA graph are then represented by terms~$\alpha$ of
the algebra, whereas the edges are given by the production rules.
%
We have implemented the construction of a PA-graph from two types, $S$
and $T$. The procedure further normalizes $\alpha$-terms by removing
terms preceded by unnormed terms, given that $\alpha \sim \alpha\beta$
whenever $\alpha$ is unnormed~\cite{janvcar1999techniques}.
% We denote this construction by \texttt{PAGraph}($T_1,T_2$).

We build on the notion of \emph{expansion trees}, only that in our
case we can work with expansion lists given the deterministic nature
of transitions in context-free session types.%
\footnote{PA-graphs for context-free session types are such that,
  given a variable $X$ and an action $a$, we cannot derive two
  distinct terms in the algebra.}
%
Given an initial vertex, the procedure alternates between
simplification and expansion operations as follows.
%
Given two session types $S$ and $T$, we start by simplifying the PA
graph, using the reflexivity, congruence, and BPA1 rules proposed by
Jan{\v{c}}ar and Moller~\cite{janvcar1999techniques}.
%
Then, we are left with the task of, recursively, expand the nodes
until, either finding an empty node---case in which we decide
equivalence positively---or failing to obtain new derived nodes---case
in which we decide equivalence negatively. The algorithm follows.
%
\begin{lstlisting}
bisim :: Graph -> Ancestors -> Node -> Bool
bisim g a n
 | Set.null n' = True
 | otherwise   = case expandNode g n' of
    Nothing  -> False
    Just n'' -> bisim g (Set.union n' a) n''
 where n' = simplify g a n

simplify :: Graph -> Ancestors -> Node -> Node
simplify g a n = foldr (apply g a) n [reflex, congruence, bpa1]

apply :: Graph -> Ancestors -> NodeTransformation -> Node -> Node
apply g a trans = Set.foldr (\p n -> Set.union (trans g a p) n) Set.empty

type Graph = Map.Map TermVar (Map.Map Label [TermVar])
type Node = Set.Set ([TermVar], [TermVar])
type Ancestors = Node
type NodeTransformation = Grammar -> Ancestors -> ([TermVar],[TermVar]) -> Node
\end{lstlisting}

% Given types $S$ and $T$, we decide on its equivalence by building the
% PA graph \lstinline|graph| underlying these terms, an empty set of
% ancestors and the parent node of the graph:
% What is xs and ys?
% \begin{lstlisting}
% bisim graph Set.empty (Set.singleton (xs, ys))
% \end{lstlisting}

We showcase this procedure on a couple of examples. Details can be found in the Appendix.

\begin{example}
\label{ex:example1}
	Let the base types $\intk$ and $\boolk$ represent integer and Boolean values, $\ell$ and $m$ denote labels for the internal and external choices on the branches, and consider the types:
	\[
	S\triangleq \mu x. (\oplus\{\ell\colon !\,\intk; \&\{\ell\colon x, m\colon \skipk \} , m\colon !\, \boolk; \&\{\ell\colon x, m\colon \skipk \} \}); \mu x. (\&\{\ell\colon\skipk, m\colon ?\,\boolk; x \})
	\]
	\[
	T\triangleq \mu x. (\oplus\{\ell\colon !\,\intk , m\colon !\, \boolk\}; \&\{\ell\colon x, m\colon \mu y. (\&\{\ell\colon\skipk, m\colon ?\,\boolk; y \})\})
	\]
	Using the proposed algorithm, we are able to derive the expansion tree as a sequence of nodes and conclude that $S\sim T$.\smallskip
	
	Using the same algorithm, we conclude that the following types are not equivalent:
	\[ R \triangleq \mu x.\&\{\ell\colon ?\,\boolk;x, m\colon ?\,\intk;x;x \} \text{ and }  U \triangleq \mu x.\&\{\ell\colon ?\,\boolk, m\colon ?\,\intk;x;x\} \enspace .\]
	We provide the expansion lists and further details in the Appendix. \hfill$\triangle$
\end{example}




Our algorithm gathers the simplification rules presented
in~\cite{janvcar1999techniques} and implements the derivation flow on
a simplified version of PA graphs, where we consider a sequence of
nodes rather than considering a derivation tree. For these reasons, we
believe that our implementation is sound. Furthermore, we have tested
our algorithm in more than one hundred examples and we have not
obtained any false positive nor any true negative result. This
reinforces our conviction that this algorithm should be sound (and
possibly complete).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
