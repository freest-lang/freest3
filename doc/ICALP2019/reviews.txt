Dear Vasco T. Vasconcelos,

I regret to inform you that your submission 

   Checking the equivalence of context-free session types

has not been selected for presentation at ICALP-B. The selection process was 
very competitive and we had to reject multiple strong papers. 

The reviews for your paper are attached. 

On behalf of the program committee, I thank you for your submission
to ICALP-B and hope you will attend ICALP in Patras, July 8-12, 2019.
Information on the program and the registration will be made available on
the ICALP website https://icalp2019.upatras.gr/.

Best regards,
 Christel Baier


----------------------- REVIEW 1 ---------------------
PAPER: 399
TITLE: Checking the equivalence of context-free session types
AUTHORS: Bernado Almeida, Andreia Mordido and Vasco T. Vasconcelos

Overall evaluation: -2 (reject)

----------- Overall evaluation -----------
SUMMARY

Context-free session types are a generalisation of session types
allowing for sequential composition of sub-protocols. This way, they
enhance the expressiveness of conventional session types beyond
(omega) regular protocols. In doing so, however, they also make it
more complicated to decide whether two (context-free) session types
are equivalent. The problem is known to be decidable and the authors
describe here a corresponding algorithm implemented in Haskell along
with some heuristics that reduce the running time dramatically.

ASSESSMENT

This work addresses an interesting problem but has several issues.
The key properties of the algorithm (correctness/completeness) seem
to be only partially addressed. Some technical results are
flawed. The code discussed contains obvious type errors (and no
download link is provided).  Comparison with related work and
evaluation are a bit thin. All in all, I find it difficult to
convince myself that the paper in its present form makes compelling
contributions. It seems that the work needs a rather substantial
revision.

COMMENTS

While the authors claim to present an algorithm that is correct and
complete, these properties appear to be only partially proved. With
respect to correctness, Theorem 8 states that if the algorithm
applied to two session types S and T returns True, then S and T are
bisimilar (hence equivalent). However, there is no statement
concerning the case when the algorithm returns False. With respect
to completeness, Theorem 10 states that if two session types S and T
are bisimilar, then the algorithm applied to S and T returns
True. Again, it doesn't say anything concerning the case in which S
and T are NOT bisimilar. So two questions remain unanswered: what
does it mean if the algorithm returns False? Is the algorithm
always guaranteed to terminate even when applied to session types
that are not bisimilar/equivalent? I couldn't convince myself that
the paper contains enough information to answer these
questions. Particularly, the authors themselves acknowledge (on page
5 and 6) that the expansion tree may be infinite (and possibly
non-regular?). Given that the algorithm proceeds breadth-first, this
is not an issue when the session types to be checked are bisimilar,
because Proposition 9 guarantees the existence of a finite
successful branch, but it is not said what happens if this is not
the case.

There seems to be an issue with Lemma 4, which relates termination
of a session type with a particular result of toGrammar. First of
all, note that the toGrammar function presented in the paper returns
an action of the State monad and not a pair. So, here the authors
are referring to another function (convertToGrammar maybe?) that
runs the monad and reveals the result of the computation. Also, it
is not said explicitly what the pair consists of, I suppose it is a
word and a set of productions. More importantly, in the proof of the
Lemma the authors provide an inductive characterisation of
terminated session types that appears to be flawed, because

  μX.skip;X

is terminated according to this inductive characterisation, but not
according to the one given on page 3. I suspect that part of the
problem is due to the notion of contractiveness given by the
authors. They deem contractive any session type not containing a
subterm of the form μX₁.μX₂...μXₙ.X₁, but while this definition is
fine for regular session types (those using only prefix), it falls
short at capturing a more robust notion of contractiveness when
general sequential composition is available.

I found comparison with related work and evaluation of the algorithm
not entirely satisfactory. It is not clear what is the relationship
between the presented algorithm and the decidability results in the
existing literature. In several places, the authors state that
previous works either do not present "practical algorithms" for
solving the problem at hand or that they suffer from "poor
performance" (page 2). Given that the presented algorithm seems to
remain exponential in complexity, I wonder if the actual
contribution of the paper is just the set of heuristics discussed in
Section 5, or if the algorithm as a whole has something new compared
to previously proposed procedures. In any case, it is not clear
whether the presented heuristics are always effective for dealing
with "real-world" session types, or if there are other examples of
sensible context-free session types for which the algorithm takes a
long time to decide equivalence. In relation to this, the results
shown in Figure 2 refer to 138 tests, but the figures appear to show
the cumulative times and memory occupation instead of breaking up
the numbers for each particular test, so it's not clear whether the
heuristics are effective overall or just in a few pathological cases
that were responsible for much of the overall inefficiency.

Finally, I would have appreciated at least a discussion of
higher-order session types which are not considered by the
algorithm. Are there substantial complications that would prevent
the adaptation of the presented algorithm to that case? Is it the
case that higher-order session types can be actually encoded into
first-order session types by taking advantage of context-free
features of grammars while preserving equivalence? (eg. !S could be
encoded as [!S] = !begin [S] end... )

MINOR COMMENTS

L15 "improve ... in ..." => "improve ... by..." ?

L28 "enabling describing" => "enabling the description of"

L78 "time in" => "time by"

L175 remove ? before skip

L210-215 please say that a node is a set of such pairs

L211 adaption

L221 children node

L260-263 the function expand is applied to 3 arguments (line 260)
but takes only 2 (line 263). This code does not type check!

L450 What does it mean "carefully crafted pair of types"? Are these
types real protocols? Are they randomly generated?

L467 "os"


----------------------- REVIEW 2 ---------------------
PAPER: 399
TITLE: Checking the equivalence of context-free session types
AUTHORS: Bernado Almeida, Andreia Mordido and Vasco T. Vasconcelos

Overall evaluation: 1 (weak accept)

----------- Overall evaluation -----------
The paper presents an algorithm to decide the equivalence of context-free
session types, proves its correctness, implements it and an optimization in
Haskell and presents some benchmarks on a number of examples.

The algorithm starts by converting context-free session types into context-free,
simple grammars. This part of the algorithm is mainly a syntactical rewriting
which results in an seemingly very efficient algorithm. The only explorative
part is the function 'isChecked' (implementation not included) that is used to
prune terminated recursions. What is the runtime of this part? I guess, it is
linear in the size of the session type modulo the time needed for 'isChecked'?

Then a pruning phase removes unreachable non-terminals. Finally, an expansion
tree is build by alternating expansion and simplification steps until a node
cannot be further expanded (algorithm returns false) or an empty node is
produced (algorithm returns true).

Although the paper presents parts of the Haskell implementation as well as some
benchmarks, the actual implementation of this algorithm in a compiler seems to
be done in another paper [2] that the authors submitted 'in parallel' somewhere
else. Since I cannot access this other paper, I can neither decide on how much
these two papers differ nor can I say much about the Haskell implementation that
is only partly given in the present paper. It would have been nice to be able to
see the complete Haskell implementation.

As I understand, only the first part of the algorithm (the translation into a
context-free, simple grammar) and the two presented optimisations (as well as
the Haskell implementation) are new, whereas the pruning and the generation of
the tree were taken from the literature. Indeed the section to prove the
correctness of the algorithm heavily relies on results from the literature.

The last two sections present two optimisations and some benchmarks. According
to the latter, the improvements that result from these two optimisations are
really impressive.

The paper is very well-written with carefully chosen examples that nicely convey
the intuition of the presented algorithm. Unfortunately, only the first part of
this algorithm seems to be new. This first part as well as the two optimisations
are interesting and not trivial but also not unnatural or very surprising.
Because of that, I am not convinced that the contribution is large enough for
ICALP.

Comments:
- Please define/explain your notion of substitution.
- Please remove the '?' before 'skip' in the type T of Example 1.


----------------------- REVIEW 3 ---------------------
PAPER: 399
TITLE: Checking the equivalence of context-free session types
AUTHORS: Bernado Almeida, Andreia Mordido and Vasco T. Vasconcelos

Overall evaluation: -1 (weak reject)

----------- Overall evaluation -----------
The paper deals with the problem of checking equivalence of context-free
session types. In general, type systems for session types allow to specify
communication on each channel between pairs of processes in a concurrent
system in a form of a type that describes a particular protocol for the
given channel. The type system then allows to check whether the messages
sent by the processes are in accordance with this protocol. The previous
type systems for session types typically allow to describe these protocols
as regular or omega-regular languages formed by sequences of messages sent
through a given channel. In paper [23] from 2016, where one of the authors
(Vasconcelos) is a co-author, a type system for session types allowing
to describe context-free languages was introduced. It was shown there that
the problem of checking equivalence on these types can be reduced to checking
(strong) bisimulation equivalence on Basic Process Algebra (BPA), a kind of
processes that basically correspond to context-free grammars in Greibach normal
form or to pushdown automata without a control state unit.

This paper now describes an implementation of this algorithm for deciding
equivalence of context-free session types in a compiler of a programming
language developed by the authors. The algorithm consists of three phases
--- a reduction to deciding bisimulation equivalence on (unnormed) BPA
(described in [23]), removing unreachable occurrences of variables in the
constructed BPA, and deciding bisimilarity on the constructed BPA.
The algorithm was implemented in Haskell and the paper presents its most
important parts in a form of Haskell code. This code is quite elegant but,
in fact, the presented algorithms are rather simple and straightforward. In
particular, the first two phases are very simple. The third phase is
an implementation of an algorithm proposed by Jančar and Moller [16], (which
was based on ideas from Hirshfeld [10]), improved by introducing two
optimizations, that can be viewed as the main new contribution of the paper.
These optimizations led to considerable decrease in the running time and the
memory consumption of the algorithm as illustrated by experimental results
presented at the end of the paper.

The paper has some merit, since it presents a practical implementation of
the algorithm usable in practice in a compiler. But in my opinion the
contribution of the paper is rather small because it consists mainly 
of a description of implementation of not very complicated known algorithms,
where one of these algorithms was improved by two new rather simple
optimizations. I suppose that this is probably not sufficient for ICALP.

The presentation was not bad but also not great. There are some typos and
I think motivation and context for the presented algorithm could be described
in more detail in the introduction (e.g., to describe shortly what session
types are for those readers that are not familiar with them).


 Detailed comments:
 ==================

- Some more recent results concerning deciding bisimulation equivalence
 on BPA could be mentioned in the introduction, e.g., Czerwinski, Lasota
 (FSTTCS 2010) --- a more efficient polynomial-time algorithm for normed
 BPA, Jančar (LMCS 2012) --- a new 2-EXPTIME algorithm for the general case,
 Kiefer (Information Processing Letters, 2013) --- EXPTIME-hardness of
 the problem.

- line 50: "Hirshfeld, Jančar, Moller" should be "Hirshfeld, Jerrum, Moller"

- lines 66 and 68: "Jancǎr" -> "Jančar"

- line 117: "We call words to sequences ... " probably should be
 "We call words the sequences ..." or "The sequences ... are called
 words".

- line 132: "non-terminal symbols" -> "terminal symbols"

- line 215: It would be useful to mention already here that nodes of
 an expansion tree are labelled with sets of pairs of states. It is not clear
 from the description, it only follows implicitly from the following discussion.

- line 230: Y_0 should be without the arrow

- line 233: X_0 should be without the arrow

- lines 441--442: "For these reasons the complexity turns out to be
 exponential." This is slightly misleading. The complexity of the presented
 algorithm is probably bigger than exponential. (The precise complexity
 is not analyzed in the paper. The best know algorithms for the problem are
 double exponential and it does not seem that the presented algorithm
 would be more efficient than them.)

- line 445: "skteched"

- lines 466--467: "in a battery os 100 runs"
