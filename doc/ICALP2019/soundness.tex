\section{Soundness and completeness of the algorithm}
\label{sec:soundness}

In this section we prove that our algorithm is sound and complete
with respect to the meta-theory of context-free session types proposed
by Thiemann and Vasconcelos~\cite{thiemann2016context}.

We start by showing that the bisimulation relation on context-free
session types, $\TypeEquiv$, is equivalent to the bisimulation
relation obtained from the productions, $\ProdEquiv$.  Then, based on
results from Caucal~\cite{caucal1986decidabilite}, Christensen,
H{\"{u}}ttel, and Stirling~\cite{DBLP:journals/iandc/ChristensenHS95},
Jan{\v{c}}ar and Moller~\cite{janvcar1999techniques}, we conclude that
our algorithm is sound and complete.

\subsection{The two bisimulations coincide}

We start by showing that the initial (dummy) production does not
affect bisimulation checking.
%
\begin{lemma}
  $X_S \TypeEquiv X_T$ if and only if
  $\toGrammarf S \ProdEquiv \toGrammarf T$.
	% Given two session types $S$ and $T$,
	% \[ X_{S} \sim X_{T}  \text{ if and only if }
	% \text{\lstinline{toGrammar S}} \sim \text{\lstinline{toGrammar T}}.\]
\end{lemma}

\begin{proof}
  We have $X_S \rightarrow\enspace \initialProd\,(\toGrammarf S)$
  and $X_T \rightarrow\enspace \initialProd\,(\toGrammarf T)$.
    %     By~\eqref{initial_prod}, we have:
    %     \[X_S \rightarrow \enspace \initialProd\enspace \text{(\lstinline{toGrammar S})}\]
    % \[X_T \rightarrow \enspace \initialProd\enspace \text{(\lstinline{toGrammar T})}\]
  Hence, $X_S \TypeEquiv X_T$ if and only if
  $\toGrammarf S \ProdEquiv \toGrammarf T$.
\end{proof}

Terminated session types do not originate new productions.

\begin{lemma}
  \label{lemma:terminated_session}
  If \DONE{S}, then \upshape{\lstinline|toGrammar |}$S$ adds no
  productions and returns \upshape{\lstinline|[]|}.
\end{lemma}

\begin{itemizeproof}
  By rule induction  on the hypothesis.
  \begin{itemize}
  \item If $S\triangleq \skipk$, then \lstinline{toGrammar} adds no
    productions and returns \lstinline{[]}.
  \item If $S\triangleq S;T$, then \DONE S and \DONE T. By induction,
    the recursive calls add no productions and return
    \lstinline|[]|. Then, function \lstinline|toGrammar| returns
    \lstinline|[]++[]|, which evaluates to \lstinline|[]|.
  \item If $S\triangleq \mu X. T$, then
    $\subs{S}{X}T \checkmark$.
    %
    Function \lstinline|toGrammar |$S$ adds the productions from
    \lstinline|toGrammar (subs (Var y) X t)|. But $\subs{S}{X} T$ is a
    terminated session, thus \lstinline{toGrammar }$T$ adds no
    productions and returns \lstinline{[]}. \vv{does not work:
      $\subs{S}{X} T$ is different from
      %
      \lstinline|toGrammar (subs (Var y) X t)|}.
  \end{itemize}
\end{itemizeproof}

Now we prove that any transition in the \LTS\ has a
corresponding transition derived from the set of productions.

\begin{lemma}
  If $S \LTSderives T$, then \upshape{\lstinline|toGrammar|}
  $S \LTSderivesP \vec X$ and \upshape{\lstinline|toGrammar|} $T$ is a
  prefix of~$\vec X$.
%
% Given context-free session types $S,S'$ and a label $\ell$,
% 	\[ \text{if } S \LTSderives[\ell] S' \text{ then }
% 	\text{\lstinline{toGrammar S}} \rightarrow \enspace
% 	\ell \enspace \vec Y, \]
% 	where \lstinline{toGrammar S'} is prefix of $\vec Y$.
\end{lemma}

\begin{itemizeproof}
By rule induction on the hypothesis.
\begin{itemize}
% \item If $S\triangleq \skipk$, then $S$ is a terminated
%   session type, with no further transition. Similarly,
%   \lstinline{toGrammar S} returns \lstinline{[]} and
%   does not add any production. % This case does not apply!
% \item If $S \triangleq \alpha$, then $S   \LTSderives[\alpha] \skipk$.
%   On the other hand, since $\alpha$ does not contain non-terminal
%   symbols, \lstinline{toGrammar S} returns a fresh variable $X$ and
%   inserts a production $X\rightarrow \alpha$. % This case in now
%   handled as in #B; not even part of the grammar.
\item If $S\triangleq \sharp B$, then
  $S \LTSderives[\sharp B] \skipk$. The call $\toGrammarf S$
  returns a fresh variable $Y$ and inserts a production
  $Y\rightarrow \sharp B$.
\item If $S\triangleq \star\{l_i\colon S_i\}_{i\in I}$ then,
  $S \LTSderives[\star l_j] S_j$, for each $j\in I$. Function
  $\toGrammarf S$ returns a fresh variable $Y$ and, recursively,
  inserts a production $Y\rightarrow \star l_j (\toGrammarf{S_j})$,
  for each $j\in I$.
\item If $S\triangleq \mu x.T$, then $\subs SXT \LTSderives T'$.
  % , then $\mu x.S \LTSderives[a] S'$.
  By induction, the corresponding production in
  %
  \lstinline{toGrammar (subs (Var y) x t)} is recursively added by
  $\toGrammarf S$ in the form $Y \rightarrow a (\toGrammarf{T'})$,
  where $Y$ is a fresh variable that is, then, returned by
  $\toGrammarf S$.
\item If $S\triangleq T;U$ and $T \LTSderives[a] T'$, then
  $S \LTSderives[a] T';U$.  By induction hypothesis, $\toGrammarf T$
  adds the production $Y\rightarrow a (\toGrammarf{T'})$, where $Y$
  is a fresh variable.  We notice that $\toGrammarf T$
  $= Y \vec Y_T$ for some sequence of non-terminal symbols
  $\vec Y_T$. By congruence, we have:
  \[\toGrammarf S = Y\vec Y_T(\toGrammarf U)
    \rightarrow a(\toGrammarf T')\vec Y_T(\toGrammarf U)
    .\]
\item If $S\triangleq T;U$, $T$ is a terminated session, with no further
  action, and $U \LTSderives[a] U'$ then, using the \LTS\ we have
  $T;U \LTSderives[a] U'$. On the other hand, by induction hypothesis and
  using Lemma~\ref{lemma:terminated_session}:
  \begin{itemize}
  \item $\toGrammarf T$  returns \lstinline{[]},
  \item $\toGrammarf U$ adds a production
    $Y \rightarrow a (\toGrammarf U')$, where $Y$ is a fresh
    variable.
  \end{itemize}
  We notice that $\toGrammarf U = Y\vec Y_U$ for some sequence of
  non-terminal symbols $\vec Y_U$. Hence, by congruence, we have a
  transition
  \[\toGrammarf S = \text{\lstinline{[]}} Y
    \vec Y_U \rightarrow a (\toGrammarf{U')} \vec Y_U.\]
\end{itemize}
\end{itemizeproof}

Conversely, we prove that any transition derived from the productions
has a corresponding labelled transition in the \LTS.

\begin{lemma}
  If $\toGrammarf S \LTSderivesP \vec Y$, then $S\LTSderives
  T$.\\ \vv{and there must be some relation on $\vec Y$ and $T$, for
    induction purposes}
% Given a context-free session type $S$ and a label $\ell$,
% 	\[ \text{if } \text{\lstinline{toGrammar S}} \rightarrow \enspace \ell \enspace
% 	 \vec Y \text{ then } S \LTSderives[\ell] S', \text{ for some context-free session type $S'$}.\]
\end{lemma}

\begin{itemizeproof}
  By induction on the structure of $S$:
  \begin{itemize}
  \item If $S \triangleq \skipk$, then $\toGrammarf S$ does not add
    any production, and \DONE{S}. \vv{Skip does not reduce; we're not
      in the hypothesis here!}
  \item If $S \triangleq \sharp B$, then $\toGrammarf S$ adds the
    production $Y\rightarrow \sharp B$ and we know that
    $S \LTSderivesP[\sharp B] \skipk$.
  \item If $S\triangleq \star \{\ell_i : S_i\}_{i\in I}$, then
    $\toGrammarf S$ recursively adds
    $\toGrammarf S \rightarrow \star \ell_j(\toGrammarf{Sj})$ for each
    $j\in I$. In the \LTS\ for productions we also have
    $S \LTSderivesP[\star\ell_j] S_j$ for each $j\in I$.
  \item If $S\triangleq \mu x.T$, then $\toGrammarf S$ adds,
    recursively, all productions from
    %
    \lstinline|toGrammar (subs (Var y) x t)|.  Analogously, in the
    \LTS\ for productions, any transition $\subs SXT \LTSderives T'$
    leads to a transition $S \LTSderives T'$. \vv{Why?}
  \item If $S \triangleq T;U$, then $\toGrammarf S$ recursively adds
    all productions from $\toGrammarf T$ and from $\toGrammarf
    U$. Hence, if $\toGrammarf S \LTSderivesP \vec Y$ then, either:
    \begin{itemize}
    \item $\toGrammarf T \LTSderivesP \vec Y$ and, in this case, by
      induction we know that $T \LTSderives T'$ and from the \LTS\ for
      productions we obtain $S \LTSderivesP T';U$;
    \item \DONE{T} and $\toGrammarf U \rightarrow a\vec Y$ and, by
      induction we know that $U \LTSderives[a] U'$ and from the \LTS\
      for productions we obtain $S \LTSderives U'$.
    \end{itemize}
  \end{itemize}
\end{itemizeproof}

Having proved that any labelled transition in the LTS has a corresponding
transition in the grammar and vice-versa, the following theorem is now
immediate.

\begin{theorem}
  \label{cfst_vs_grammar}
  $S\TypeEquiv T$  if and only if $ X_S \ProdEquiv X_T$.
	% Given two context-free session types $S_1, S_2$,
	% \[ S_1 \TypeEquiv S_2 \text{ if and only if } X_{S_1} \ProdEquiv X_{S_2}. \]
\end{theorem}

\subsection{Unnormedness is preserved by pruning}

To prove that the pruning stage is in accordance with the results from
Christensen et al.~\cite{DBLP:journals/iandc/ChristensenHS95}, we
observe that unnormed non-terminal symbols corresponding to (un)normed
types are (un)normed. These results follow immediately from the
previous results. \vv{from which results, exactly?}

\begin{corollary}
  Given a context-free session type $S$, $|S| = |\toGrammarf S|$.
\end{corollary}

\begin{corollary}
  A context-free session type $S$ is unnormed if and only if $X_S$ is
  unnormed.
\end{corollary}

\vv{these notions are not defined on session types}

%\subsection{The expansion tree is correct}
\subsection{Correctness of the algorithm}
%
%Let us start by proving a small lemma, whose ultimate purpose
%stands on proving that all nodes excluded by the filtering rule
%would lead to unsuccessful branches.
%
%\begin{lemma}
%\label{lemma:filtering}
%	Let $(\vec X, \vec Y)$ be a pair in node $N$ of the expansion tree.
%	If $|\vec X| \neq |\vec Y|$ then  $\vec X \not\ProdEquiv \vec Y$.
%\end{lemma}
%
%\begin{proof}
%	Assume that $n = |\vec X| < |\vec Y|$. This means that:
%	\begin{equation}
%	\label{pathX}
%		\vec X \rightarrow \ell_1 \vec X_1 \rightarrow \cdots
%		\rightarrow \ell_n \rightarrow \varepsilon.
%	\end{equation}
%	Now assume that $\vec Y$ has an expansion sequence whose
%	labels coincide with those from $\vec X$ (otherwise, we would immediately
%	have $\vec X \not\ProdEquiv \vec Y$). Since $\vec Y > n$, there should
%	exist a label $\ell_{n+1}$ such that:
%	\[\vec Y \rightarrow \ell_1 \vec Y_1 \rightarrow \cdots
%	\rightarrow \ell_n \vec Y_n\rightarrow \ell_{n+1} \vec Y_n
%	\rightarrow \cdots\]
%	Since our grammar is simple, \eqref{pathX} is the unique path from $\vec X$
%	through labels $\ell_1, \ldots, \ell_n$. Hence, the $(n+1)$-th expansion of
%	$\vec X$ with label $\ell_{n+1}$ would fail and we conclude that
%	$\vec X \not\ProdEquiv \vec Y$.
%\end{proof}

We now focus on the correctness of the algorithm in
Listing~\ref{lst:algorithm}.  Before proceeding to soundness, we
recall the \emph{safeness property} presented by Jan{\v{c}}ar and
Moller.

\begin{proposition} [Safeness Property \cite{janvcar1999techniques}]
  \label{prop:safeness}
  $\vec X \ProdEquiv \vec Y$ if and only if the expansion tree rooted
  at $\{(\vec X, \vec Y)\}$ has a successful branch.
\end{proposition}

Notice that function \lstinline|bisimilar|
(Listing~\ref{lst:algorithm}) builds an expansion tree by alternating
between expansion and simplification operations (reflexive,
congruence and \BPA\ rules), as proposed by Jan{\v{c}}ar and Moller.
%
These simplification rules are \emph{safe}, in the sense that the
application of any rule preserves the bisimulation from a parent node
to at least one child node and, reciprocally, that bisimulation on a
children node implies the bisimulation of its parent node, thus proving
the safeness property.

%\begin{proof}
%	On the other hand, as observed in~\cite{janvcar1999techniques},
%	the union of nodes along a successful branch is a relation $R$
%	such that $R\subseteq \ProdEquiv$. Hence, any pair $(\vec X, \vec Y)$
%	occurring along a successful branch is such that $\vec X \ProdEquiv \vec Y$,
%	which, by Lemma~\ref{lemma:filtering}, means that $|\vec X|=|\vec Y|$.
%	So, the filtering rule would node exclude any node in the successful branch
%	and, then, also preserved the safeness property.
%\end{proof}

\begin{theorem}
  If $\bisimf S T$ returns \upshape{\lstinline|True|}, then
  $X_{S} \ProdEquiv X_{T}$.
	% Given two context-free session types $S$ and $T$, if the function
	% \lstinline|equivalent|, presented in Listing~\ref{lst:algorithm},
	% returns \lstinline|true|, then $X_{S} \ProdEquiv X_{T}$.
\end{theorem}

\begin{proof}
  Function \lstinline|bisimilar| returns \lstinline|True| for $S$ and
  $T$ whenever it reaches a (finite) successful branch in the expansion
  tree rooted at $\{(X_{S}, X_{T})\}$. Conclude with the safeness property,
  proposition~\ref{prop:safeness}.
  % , whenever the expansion tree rooted
  % at $\{(X_{S}, X_{T})\}$ has a (finite) successful branch, we
  % kn that $X_{S} \ProdEquiv X_{T}$.
\end{proof}

From the previous results, and recalling
Theorem~\ref{cfst_vs_grammar}, the soundness of our algorithm is now
immediate.  The algorithm to check the bisimulation of context-free
session types (listing~\ref{lst:algorithm}) is sound with respect to
the meta-theory of context-free session types.

\begin{theorem}
  If $\bisimf ST$ returns \upshape{\lstinline|True|} then $S\TypeEquiv T$.
\end{theorem}

Having observed that the safeness property was paramount for
soundness, we now notice that the \emph{finite witness property} is of
utmost importance to prove completeness. This result follows
immediately from the analysis by Jan{\v{c}}ar and
Moller~\cite{janvcar1999techniques}, which capitalizes on results by
Caucal~\cite{caucal1986decidabilite}, Christensen, H{\"{u}}ttel, and
Stirling~\cite{DBLP:journals/iandc/ChristensenHS95}:

\begin{proposition} [Finite Witness Property]
\label{finite_witness}
	If $\vec X \ProdEquiv \vec Y$, then the expansion tree rooted at
	$\{(\vec X, \vec Y)\}$ has a finite successful branch.
\end{proposition}

The algorithm to check the bisimulation of context-free session types
is complete with respect to the meta-theory of context-free session
types.

\begin{theorem}
  If $S \TypeEquiv T$ then $\bisimf S T$ returns
  \upshape{\lstinline|True|}.
\end{theorem}

\begin{proof}
  Assuming that $S \TypeEquiv T$, by theorem~\ref{cfst_vs_grammar} we
  have $X_{S} \ProdEquiv X_{T}$.  Hence, the finite witness property
  ensures the existence of a finite successful branch on the expansion
  tree rooted at $\{(X_{S},X_{T})\}$, i.e., a branch terminating in an
  empty node.  Since our algorithm traverses the expansion tree using
  breadth-first search it will, eventually, reach the empty node and
  conclude the bisimulation positively.
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
