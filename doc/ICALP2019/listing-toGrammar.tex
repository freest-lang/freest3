\begin{lstlisting}[
  caption={Haskell code for stage 1: the conversion of types into grammars},
  label={lst:toGrammar},
  captionpos=b]
type Transitions = Map.Map LTSLabel [TypeVar]
type Productions = Map.Map TypeVar Transitions
type Visited = Set.Set TypeVar
type TransState = State (Productions, Visited, Int)

toGrammar :: Type -> TransState [TypeVar]
toGrammar Skip =
  return []
toGrammar (Message p b) = do
  y <- freshVar
  addProduction y (MessageLabel p b) []
  return [y]
toGrammar (Semi t u) = do
  xs <- toGrammar t
  ys <- toGrammar u
  return (xs ++ ys)
toGrammar (Var x) = do
  b <- memberVisited x
  if b
  then    -- This is a recursion variable
    return [x]
  else do -- This is a free variable
    y <- freshVar
    addProduction y (VarLabel x) []
    return [y]
toGrammar (Rec x t) = do
  y <- freshVar
  insertVisited y
  zs <- toGrammar (subs (Var y) x t) -- On-the-fly alpha-conversion
  if null zs
    then return []
  else do
    m <- getTransitions (head zs)
    addProductions y (Map.map (++ tail zs) m)
    return [y]
toGrammar (Choice c m) = do
  y <- freshVar
  mapM_ (assocsToGrm y c) (Map.assocs m)
  return [y]

assocsToGrm :: TypeVar -> ChoiceView -> (TypeLabel,Type) -> TransState()
assocsToGrm y c (l, t) = do
  xs <- toGrammar t
  addProduction y (ChoiceLabel c l) xs
\end{lstlisting}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
