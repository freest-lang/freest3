%\subsection{Soundness}

% \begin{lemma}[Strengthening]
%   \label{lem:strengthening}
%   If $\Delta;\Gamma,a\colon T \vdash p$ and~$a$ not free in~$p$ then
%   $\Delta;\Gamma \vdash p$ and~$\un(T)$.
% \end{lemma}
% %
% \begin{proof}
%   By rule induction on the first hypothesis.
% \end{proof}

% \begin{lemma}[Congruence]
%   \label{lem:congruence}
%   If $\Gamma \vdash p$ and $p\equiv q$ then $\Gamma \vdash q$.
% \end{lemma}
% %
% \begin{proof}
%   By rule induction on the first hypothesis, using strengthening
%   (Lemma~\ref{lem:strengthening}).
% \end{proof}

% \begin{lemma}[Substitution]
%   \label{lem:subs}
%   If $\Delta;\Gamma_1, a\colon T_2 \vdash e_1 : T_1$ and
%   $\Delta;\Gamma_2 \vdash e_2 : T_2$ then
%   $\Delta;\Gamma_1,\Gamma_2 \vdash e_1 \subs{e_2}{a} : T_1$.
% \end{lemma}
% %
% \begin{proof}
%   By rule induction on the first hypothesis.
% \end{proof}

% \begin{lemma}[Sub-derivation introduction]
%   \label{lem:derivation-intro}
%   If $\mathcal D_1$ is a derivation of
%   $\Delta;\Gamma \vdash E[e] : T_1$ then $\Gamma = \Gamma_1,\Gamma_2$
%   and $\mathcal D_1$ has a sub-derivation $\mathcal D_2$ concluding
%   $\Delta;\Gamma_2 \vdash e : T_2$ such that the position of
%   $\mathcal D_2$ in $\mathcal D_1$ corresponds to the hole in $E[]$.
% \end{lemma}

% \begin{lemma}[Sub-derivation  elimination]
%   \label{lem:derivation-elim}
%   If $\mathcal D_1$ is a derivation of
%   $\Delta;\Gamma_1,\Gamma_2 \vdash E[e_1] : T_1$ and $\mathcal D_2$ is a
%   sub-derivation of $\mathcal D_1$ concluding
%   $\Delta;\Gamma_2,\Gamma_3 \vdash e_1 : T_2$ and the position of
%   $\mathcal D_2$ in $\mathcal D_1$ corresponds to the hole in $E[]$
%   and $\Delta;\Gamma_2 \vdash e_2 : T_2$ then
%   $\Delta;\Gamma_1,\Gamma_2,\Gamma_2 \vdash E[e_2] : T_1$.
% \end{lemma}

% The structural type rules (weak, copy, and $\equiv$) commute. The
% following fat rule is admissible.
% %
% \begin{equation*}
%   \frac{
%     \Delta;\Gamma_1, \Gamma_2, \Gamma_2 \vdash e : T_1
%     \quad
%     \un(\Gamma_2,\Gamma_3)
%     \quad
%     \Delta \vdash T_1 \TypeEquiv T_2
%   }{
%     \Delta;\Gamma_1, \Gamma_2, \Gamma_3 \vdash e : T_2
%   }
% \end{equation*}
% %
% Notice that if we replace, in the weak rule, the proviso
% $a\notin\Gamma$ by $a:U\in\Gamma \Rightarrow U\equiv T$, then copy
% and weak do not commute anymore.  This fat rule forms the basis for
% inversion below.

% \begin{lemma}[Inversion]\
%   \label{lem:inversion}
%   \begin{itemize}
%   \item If $\Gamma \vdash e$ then
%     $\Gamma = \Gamma_1, \Gamma_2, \Gamma_3$ and
%     $\un(\Gamma_2,\Gamma_3)$ and
%     $\Gamma_1,\Gamma_2,\Gamma_2 \vdash e\colon \sigma$ and
%     $\un(\sigma)$.
%   % \item If $\Gamma \vdash \letk\,ab=(u,v)\,\ink\,e : \sigma$ then
%   %   $\Gamma = \Gamma_1, \Gamma_2, \Gamma_3$ and
%   %   $\Gamma_1,\Gamma_2,\Gamma_2 = \Gamma_4,\Gamma_5,\Gamma_6,\Gamma_7$
%   %   and $\Gamma_5,\Gamma_6,\Gamma_6 = \Gamma_7,\Gamma_8$ and
%   %   $\Gamma_4,a\colon T_1, b\colon T_2 \vdash e \colon \sigma_1 \equiv
%   %   \sigma$
%   %   and $\Gamma_7 \vdash u: \sigma_2 = T_1$ and
%   %   $\Gamma_8 \vdash : \sigma_3 = T_2$.
%   \item %let/2
%     If $\Gamma \vdash \letin{ab}{e_1}{e_2} : \sigma$ then
%     $\Gamma = \Gamma_1, \Gamma_2, \Gamma_3$ and
%     $\un(\Gamma_2,\Gamma_3)$ and
%     $\Gamma_4,\Gamma_5 = \Gamma_1, \Gamma_2,\Gamma_2$ and
%     $\Gamma_4 \vdash e_1: T_1 \otimes T_2$ and
%     $\Gamma_5,a\colon T_1,b\colon T_2 \vdash e_2: \tau = \sigma$.
%   \item % (e1,e2)
%     If $\Gamma \vdash (e_1, e_2) : T$ then
%     $\Gamma = \Gamma_1, \Gamma_2, \Gamma_3$ and
%     $\un(\Gamma_2,\Gamma_3)$ and
%     $\Gamma_4,\Gamma_5 = \Gamma_1, \Gamma_2,\Gamma_2$ and
%     $\Gamma_4 \vdash e_1: T_2$ and $\Gamma_5 \vdash e_2:T_2$ and
%     $T_1\otimes T_2 = \sigma$
%   \item If $\Gamma \vdash \fork\,e:\sigma$ then
%     $\Gamma = \Gamma_1,\Gamma_2,\Gamma_3$ and
%     $\Gamma_1,\Gamma_2,\Gamma_2 \vdash e : \unitk$ and $\un(\Gamma$)
%     and $\sigma \equiv \unitk$.
%   \item If $\Gamma \vdash \newk : \sigma$ then $\un(\Gamma)$ and
%     $\sigma \equiv S\otimes\dual S$.
%   \item If $\Gamma_1 \vdash \recvk\, a : \sigma_1$ then
%     $\sigma_1 \equiv T \otimes S$ and 
%     $\Gamma_1 = \Gamma_2, a\colon \sigma_2$ and $a\notin\Gamma_2$ and
%     $\sigma_2 \equiv \;?B;S$.
%   \item If $\Gamma \vdash \sendk\, e\, a : \sigma$ then
%     $\sigma \equiv S$ and
%     $\Gamma = \Gamma_1, \Gamma_2, \Gamma_3, a\colon \sigma_2$ and
%     $\un(\Gamma_2,\Gamma_3)$ and $\sigma_2 \equiv \;!B;S$ and
%     $\Gamma_1,\Gamma_2, \Gamma_2 \vdash e \colon \sigma_1$ and
%     $\sigma_1\equiv T$.
%   \end{itemize}
  
% \end{lemma}

% \begin{theorem}[Soundness]
%   \label{thm:soundness}
%   If $\Gamma \vdash p$ and $p \rightarrow q$ then $\Gamma \vdash q$.
% \end{theorem}
% %
% \begin{proof}
%   By rule induction on the second premise.

%   Case the derivation ends with the rule for communication: inversion
%   ($\newk$, par, proc twice), sub-derivation intro (twice), inversion
%   ($\sendk$, $\recvk$), rules var and $\equiv$, sub-derivation elim
%   (twice), rules proc (twice) and par and weak and copy, definition of
%   $\dual S$, rule $\newk$.

%   Case the derivation ends with the rule for branching: should be
%   similar to the above, but simpler (did not check).

%   Case the derivation ends with channel creation: inversion,
%   sub-derivation intro, inversion, var axiom, $\otimes$ intro,
%   sub-derivation elimination, rules proc and $\newk$.

%   Case the derivation ends with $\forkk$: sub-derivation intro,
%   inversion, copy, sub-derivation elimination, rules proc and par and
%   copy.

%   Case the derivation ends with par: inversion, induction, rule $\mid$.

%   Case the derivation ends with reduction under $\newk$: inversion,
%   induction, rule $\newk$.

%   Case the derivation ends with $\equiv$: congruence lemma, induction.

%   Case the derivation ends with context: derivation lemma, induction,
%   derivation lemma.

%   Case the derivation ends with $\beta$: inversion, substitution
%   lemma.

%   Case the derivation ends with $\letk$: rule proc, inversion,
%   substitution lemma (twice), rules weak and copy.

%   Case the derivation ends with $\matchk$: inversion, application
%   rule.

%   Case the derivation ends with $\fixk$: inversion, substitution
%   lemma, contraction (copy rule).
% \end{proof}

% \begin{theorem}[Type safety]
%   If $\Delta;\Gamma \vdash p$ then $p$ is not an error.
% \end{theorem}
% %
% \begin{proof}
%   A simple analysis of the typing derivation for the hypothesis. We
%   analyse one such case.
% %
%   If $(\new ab)(E_1[e_1] \mid E_2[e_2] \mid p)$ and $\subj(e_1)=a$ and
%   $\subj(e_2)=b$ where $E_1$ does not bind~$a$ and $E_2$ does not
%   bind~$b$, then it must be the case that $\agree^{ab}(e_1,e_2)$.
%   % 
%   In fact, the structural typing rules and those for $\newk$ and for
%   parallel composition guarantee that
%   $\Delta;\Gamma_1,a\colon S \vdash E_1[e_1]$ and
%   $\Delta;\Gamma_2,b\colon \dual S \vdash E_2[e_2]$, for some
%   $\Delta,\Gamma_1,\Gamma_2$. When $e_1$ is $\send{e'_1}a$,
%   sub-derivation introduction and inversion
%   (lemmas~\ref{lem:derivation-intro} and~\ref{lem:inversion}) allow to
%   conclude that $\Delta \vdash S \TypeEquiv \;!B.S'$,
%   hence~$\Delta \vdash \dual S \TypeEquiv \;?B.\dual{S'}$. Of all the
%   cases terms with subject~$b$ only $\recv b$ has a type of the form
%   $?B.\dual{S'}$, hence $\agree^{ab}(\send{e'_1}a,\recv b)$.
% \end{proof}

% \section{Conservative Extension}
% \label{sec:conservative-extension}

% Our system is a conservative extension of previous session type
% systems. In those systems, the session type language is restricted to
% tail recursion, the $\mu$ operator works with a much simpler notion
% of contractivity, and equivalence is defined modulo unfolding.
% We take the definitions from the functional session type
% calculus~\cite{DBLP:journals/jfp/GayV10} as a blueprint.
% The first-order part of the session type language from that paper may
% be defined by $S'$ in the following grammar. Henceforth, we call that
% language \emph{regular session types}.
% \begin{align*}
%   S'_X & \grmeq \End \grmor !B.S''_X \grmor ?B.S''_X \\
%        &\grmor \oplus\{l_i\colon {S_i}_X''\} \grmor
%          \&\{l_i\colon {S_i}_X''\}
%   \\
%   & \grmor \mu x. S'_{X\cup\{x\}} \\
%   S''_X & \grmeq x\in X \grmor S'_X
% \end{align*}
% The translation $\Embed{}$ into our system is defined as follows.
% \begin{align*}
%   \Embed{\End} & = \skipk \\
%   \Embed{!B.S''} & = (!B; \Embed{S''}) \\
%   \Embed{?B.S''} & = (?B; \Embed{S''}) \\
%   \Embed{\oplus\{l_i\colon S_i''\}} & = \oplus\{l_i\colon \Embed{S_i''}\} \\
%   \Embed{\&\{l_i\colon S_i''\}} & = \&\{l_i\colon  \Embed{S_i''}\} \\
%   \Embed{\mu x.S'} & = \mu x. \Embed{S'} \\
%   \Embed{x} & = x
% \end{align*}
% \begin{lemma}
%   For all $S'_\emptyset$, $\cdot \vdash \Embed{S'_\emptyset} :: \kinds^\Linear$.
% \end{lemma}
% \begin{proof}
%   We need to prove a more general property.
%   Define $\GEnv_X = x : \kinds^\Linear \mid x \in X$.
%   For all $S'_X$, $\GEnv_X \vdash \Embed{S'_X} :: \kinds^\Linear$. The
%   proof is by straightforward induction.
% \end{proof}
% \begin{lemma}
%   Let $\vdash_{\text{GV}}$ be the typing judgment for expressions from Gay and
%   Vasconcelos~\cite{DBLP:journals/jfp/GayV10}.
%   If $\Gamma \vdash_{\text{GV}} e : T$, then $\cdot, \Gamma \vdash e : \Embed{T}$.
% \end{lemma}

% \begin{proposition}
%   The trace language of a regular session type is an $\omega$-regular language.
% \end{proposition}
% \begin{proof}
%   To see this result, we consult the translation $\toCFG$ from session types to
%   context-free grammars from Theorem~\ref{theorem:tr-is-w-CFL}. It is
%   easy to see that the image of $\toCFG$
%   after eliminating chain productions is a right-linear grammar,
%   when restricted to the image of the embedding of regular session
%   types $\Embed{\_}$.

%   Examination of the transformation of the grammar to a DPDA in
%   Proposition~\ref{prop:trace-is-weak-wpda} shows that every run of the automaton resulting from
%   transforming a right-linear grammar has at most one symbol on its stack. Hence, the stack can
%   be eliminated, which transforms the DPDA to a finite state $\omega$-automaton. This class of
%   automata recognizes exactly the class of $\omega$-regular languages \cite{DBLP:books/el/leeuwen90/Thomas90}.
% \end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
