
\section{Introduction}
\label{sec:introduction}

Session types have been discovered by Kohei Honda as a means to describe the structured
interaction of processes via typed communication channels
\cite{DBLP:conf/concur/Honda93,DBLP:conf/parle/TakeuchiHK94}. While connections are homogeneously
typed in languages like Concurrent ML
\cite{DBLP:conf/pldi/Reppy91}, 
session types provide a heterogeneous type discipline for a
protocol on a bidirectional connection: each message has an individual direction
and type and there are choice points where a sender can make a choice and a receiver
has to follow. 
While session types have been conceived for process
calculi, they provide precise typings for communication
channels in any programming language. They fit particularly well with
strongly typed functional languages from the ML family.

The type structure of a functional language with session types
typically comes with two layers, regular types and session types:
\begin{align}
    \TY & ::=  \SE \mid \tUnit \mid \tBase \mid \tFun\TY\TY \mid \dots
    % \tNProd{\cgAlt\LL{\TY_\LL}} \mid \tNSum{\cgAlt\LL{\TY_\LL}} \mid
    %       \tVar \mid \tMu\tVar\TY
  \label{eq:3}\\\notag
    \SE & ::=  \End  \mid \sRecv\TY\SE \mid \sSend\TY\SE \mid
%    \sRecvChoice{\cgAlt{\LL_i}{\SE_i}}_{i\in I} \mid \sSendChoice{\cgAlt{\LL_i}{\SE_i}}_{i\in I} \mid 
    \sRecvChoice{\cgAlt{\LL_i}{\SE_i}} \mid \sSendChoice{\cgAlt{\LL_i}{\SE_i}} \mid 
    \sVar \mid \sMu\sVar\SE
\end{align}
A type $\TY$ is either a session type $\SE$, a unit type, a base type $\tBase$,
a function type, and so on. Session types $\SE$ are attached to
communication channels. They denote denote different states of the
channel. The type $\End$ indicates the end of a session,
$\sRecv\TY\SE$ ($\sSend\TY\SE$) indicates readiness to receive (send)
a value of type $\TY$ and continuing with $\SE$,  the branching
operators $\sRecvChoice{\cgAlt{\LL_i}{\SE_i}}_{i\in I}$ and
 $\sSendChoice{\cgAlt{\LL_i}{\SE_i}}_{i\in I}$ indicate receiving and sending
labels, where the label $\LL_i$ selects the 
protocol $\SE_i$ from a finite number of possibilities $i\in I$ for the
subsequent communication on the channel. For example, the session type
\begin{displaymath}
  \sRecvChoice{
    \cgAlt{\lbl{add}}{\sRecv{\intk}\sRecv{\intk}\sSend{\intk}\End}
    ,
    \cgAlt{\lbl{neg}}{\sRecv{\intk}\sSend{\intk}\End}
  }
\end{displaymath}
is the type of a server that accepts two commands \lbl{add} and \lbl{neg},
then reads the appropriate number of arguments and returns the result of the command.
The session variable $\sVar$ and the operator $\sMu\sVar\SE$ serve to
introduce recursive protocols, for example, to read a list of numbers:
\begin{displaymath}
  \sMu\sVar \sRecvChoice{
    \cgAlt{\lbl{stop}}\End
    ,
    \cgAlt{\lbl{more}}{\sRecv{\intk}\sVar}
  }
\end{displaymath}

Session types are well suited to document high-level communication
protocols and there is a whole range of extensions to make them
amenable to deal with realistic situations, for example, multi-party
session types~\cite{DBLP:conf/popl/HondaYC08}, session types for
distributed object-oriented
programming~\cite{DBLP:conf/popl/GayVRGC10}, or for programming web
services~\cite{DBLP:journals/toplas/CarboneHY12}. However, there is a
fundamental limitation in their structure that makes it impossible to
describe efficient low-level serialization (marshalling, pickling, \dots) of
tree structured data in a type-safe way, as we demonstrate with the
following example.

Let's assume that a single communication operation can only transmit a
label or a base type value to model the real-world restriction that
data structures need to be serialized to a wire format before they can
be sent over a network connection.  Formally, it is sufficient to
restrict the session type formation for sending and receiving data to
base types: $\sSend{B}\SE$ and $\sRecv{B}\SE$. Now suppose we want to
transmit binary trees where the internal nodes contain a number.  A
recursive type for such trees can be defined as follows:
\lstinputlisting{treedata.cfs}
% \begin{displaymath}
%   \mathit{Tree} = \tMu\tVar \mathit{Leaf} (\intk) + \mathit{Node} (\tPair\tVar\tVar)
% \end{displaymath}
To serialize such a structure, we traverse it in some order and transmit a sequence of
labels \lstinline|Leaf| and \lstinline|Node| and \lstinline|int|
values as they are visited by the traversal. The set of serialization
sequences corresponding to a pre-order traversal of a tree
may be described by the following context-free grammar.
\begin{equation}\label{eq:1}
  N ::= \mathsf{Leaf} \mid \mathsf{Node}\ \intk\ N\ N
\end{equation}
\begin{lstlisting}[float={t},captionpos={b},caption={Type-safe
    serialization of a binary tree},label={listing:serializing}]
sendTree : forallalpha.Tree -> TreeChannel;alpha -> alpha
sendTree Leaf c =
  select Leaf c
sendTree (Node x l r) c =
  let c1 = select Node c
      c2 = send x c1
      c3 = sendTree l c2
      c4 = sendTree r c3
  in  c4
\end{lstlisting}
Listing~\ref{listing:serializing}  contains a function \lstinline|sendTree| that
performs a pre-order traversal of a tree and sends correctly
serialized output on a channel.  The function relies on typical
operations in a functional session type calculus like
GV~\cite{DBLP:journals/jfp/GayV10}: the \lstinline|select| operation
takes a label and a channel, outputs the label, and returns the
(updated) channel. The \texttt{send} operation takes a value and a
channel, outputs the value, and returns the channel. Ignore the type
signature for a moment.

It turns out that the \lstinline|sendTree| function cannot be typed in existing
session-type calculi
\cite{DBLP:conf/concur/Honda93,DBLP:journals/acta/GayH05,DBLP:conf/esop/HondaVK98,DBLP:journals/jfp/GayV10,DBLP:conf/parle/TakeuchiHK94,DBLP:conf/esop/ToninhoCP13}. To
see this, we observe that the language generated by the nonterminal
$N$ in the grammar~\eqref{eq:1}
is context-free, but not regular.
In contrast, the language of communication actions described by a
traditional session type $S$ is regular. 
More precisely, taking infinite executions into account, 
each traditional session type is related to the union of a regular language and an
$\omega$-regular language that describe the finite and infinite sequences of communication actions
admitted by the type. A similar caveat applies to the language generated by a context-free grammar
like~\eqref{eq:1}, a point which we leave for future work. 

It turns out that we can type functions like \lstinline|sendTree| if we drop the
restriction of being tail recursive from the language of session
types. Here is an informal proposal for a revised session type structure
replacing the previous one~\eqref{eq:3}:
%
\begin{align*}
  \SE & ::=  \skipk \mid \scRecv\tBase \mid \scSend\tBase \mid
        \scCompose\SE\SE \mid
        \sRecvChoice{\cgAlt{\LL_i}{\SE_i}} \mid \sSendChoice{\cgAlt{\LL_i}{\SE_i}} \mid 
        \sVar \mid \sMu\sVar\SE
\end{align*}
%
That is, we remove the continuation from the primitive send and
receive types and adopt a general sequence operator $\scCompose\_\_$
with unit $\skipk$. This change removes the restriction to tail
recursion and enables a session type to express context-free
communication sequences such as the ones required for the
serialization example. However, the monoidal structure of
$\skipk$ and $\scCompose\_\_$ poses some challenges for the metatheory.  We
call this structure \emph{context-free session types} and it is
sufficient to assign a type to function \lstinline|sendTree|. First,
we define the recursive session type corresponding to the \lstinline|Tree|
datatype. Its definition follows the datatype definition, but
it makes the sequence of communication operations explicit.
\lstinputlisting{treechannel.cfs}
Now we are ready to explain the type signature for \lstinline|sendTree|.
\begin{lstlisting}
sendTree : forallalpha.Tree -> TreeChannel;alpha -> alpha
\end{lstlisting}
% \begin{displaymath}
%   \mathsf{sendTree} :
%   \begin{array}[t]{l}
%  \forall \alpha.
%   \mathsf{Tree} \\ \to
%   (\scMu\scVar
%   \scCompose{\scSendChoice{
%       \cgAlt{\kw{Leaf}}{\scSend\intk} \mid
%       \cgAlt{\kw{Node}}{(\scCompose\scVar\scVar)}}}\alpha) \\
%   \to \alpha
%   \end{array}
% \end{displaymath}
It abstracts over the type \lstinline|alpha| of the continuation
channel, takes as input a \lstinline|Tree| and a channel which first
runs the recursive  protocol \lstinline{TreeChannel} followed by some other
protocol specified by \lstinline|alpha|. The \lstinline|alpha|-typed
channel is returned which leaves its processing to the continuation.
%
This abstraction is required to make things work because a type of the form \lstinline|Tree ->  TreeChannel ->  skip|
does not fit the first recursive call.

Polymorphism, as seen in this signature, is rarely considered in session types
(with two exceptions \cite{BonoPadovaniTosatto13,DBLP:journals/mscs/Gay08} discussed in the related
work).  However, it appears quite natural in this context as sending a
tree generalizes sending a single value, which is naturally
polymorphic over the continuation channel as in $\kw{send} :\forall \alpha. \tBase \to
(\scCompose {\scSend\tBase}\alpha)
\to \alpha$.
% That is, the primitive \texttt{send} operation for a
% particular $\tBase$ could be given the type 
% \begin{displaymath}
%   \mathsf{send} : \forall \alpha.
%   \tBase \to
%   (\scCompose {\scSend\tBase}\alpha)
%   \to \alpha
%   \mathrm{.}
% \end{displaymath}
%
Further study of the typing derivation of \lstinline|sendTree| (in
Section~\ref{sec:context-free-session}) makes it clear that
polymorphism is absolutely essential to make context-free session
types work in connection with recursive types. It turns out that the
recursive calls happen at \emph{instances} of the declared type, so
that \lstinline|sendTree| (as well as its receiving counterpart,
\lstinline|recvTree|) makes use of \emph{polymorphic recursion}.

\subsection*{Contributions and overview}
\label{sec:contributions}

\begin{itemize}
\item We introduce context-free session types that extend the
  expressiveness of %traditional,
  regular
  session types to capture the type-safe serialization of recursive
  datatypes. They further enable the type-safe implementation
  of remote operations on recursive datatypes that either traverse the
  structure eagerly or on demand.
\item Section~\ref{sec:context-free-session} discusses the overall design and explains the
  requirements to the metatheory with examples.
\item Section~\ref{sec:types} formally introduces context-free session types. A kind
  system with subkinding guarantees well-formed\-ness; the definition of contractiveness needs to be
  refined to deal with the monoidal structure of the type operators $\skipk$ and $\_;\_$; we give a
  coinductive definition of type equivalence as a bisimulation of types and prove its decidability
  by reducing type equivalence to the equivalence of basic process
  algebra expressions (BPA).
\item Section~\ref{sec:processes} formally introduces the term
  language along with its statics and dynamics. It is a synchronous,
  first-order version of Gay and Vasconcelos' linear type theory for
  asynchronous session types (GV) \cite{DBLP:journals/jfp/GayV10}
  extended with recursive types and variant types to model recursive
  datatypes. We establish type soundness and progress for the
  sequential fragment of our language. We prove in
  Section~\ref{sec:conservative-extension} that our system
  conservatively extends a regular (first-order) session-type system.
\item We discuss related work in Section~\ref{sec:related-work} and conclude.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
