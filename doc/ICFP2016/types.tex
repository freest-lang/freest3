\section{Types}
\label{sec:types}

This section introduces the notion of types, the machinery required
for defining type equivalence, and a proof that type equivalence is
decidable. % which relies on bisimilarity.

\subsection{Types and the Kinding System}
\label{sec:types-kinding-system}

% Base sets

We rely on a few base sets: \emph{recursion variables}, denoted by
$x,y,z$; \emph{type variables} denoted by~$\alpha,\beta$;
% drawn from a set $\Tyvars$;
\emph{labels} denoted by $l$,
% drawn from $\Labels$,
and \emph{primitive types} denoted by~$B$, which include $\unitk$ and
$\intk$.
%, drawn from $\btypes$.

% Kinds

A \emph{kinding} system establishes what constitutes a valid type,
distinguishing between session types, general types, and type schemes.
%
The kinding system further distinguishes linear from unrestricted
types.
%
\emph{Prekinds}, denoted by $\prekind$, are session types~$\kinds$,
arbitrary types~$\kindt$, or type schemes~$\kindsch$. \emph{Multiplicities}, denoted by~$m$, can be
linear~$\Linear$ or unrestricted~$\Unrestricted$. \emph{Kinds} are of
the form $\prekind^m$, describing types and their multiplicities.
%
A partial order $\le$ is defined on prekinds, which describes that a session
type of kind~$\kinds$ may be regarded as a type of kind~$\kindt$,
which in turn may be regarded as a type scheme of kind~$\kindsch$.
Similarly, multiplicities establish that an unrestricted (use zero or more times)
type can be regarded as  a linear (use exactly once) type,
that is $\Unrestricted < \Linear$. The two order relations form a
complete lattice on kinds. Its ordering is determined by
$\prekind_1^{m_1} \le \prekind_2^{m_2}$ iff
$\prekind_1 \le \prekind_2$ and $m_1 \le m_2$.

% Kinding environments

\input{fig-types}

A \emph{kinding environment}, denoted by $\Delta$, associates
kinds~$\kind$ to type variables~$\alpha$ and to recursion
variables~$x$. When writing $\Delta, \alpha::\kind$ or
$\Delta,x::\kind$ we assume that~$\alpha$ and~$x$ do not occur
in~$\Delta$.
%
The notions of kinds, types, and kind environments are summarized in
Figure~\ref{fig:types}.

% Kinding

\input{fig-kinding}

\emph{Kind assignment} is defined by a judgment $\Delta \vdash T
:: \kind$ (see Figure~\ref{fig:kinding}) that
ensures the good formation of types $T$, while classifying well-formed
types in session types, general types, or type schemes, as well as
assigning a multiplicity to session types and general types.
%
The type scheme $\forall\alpha::\kind.T$ binds the type
variable~$\alpha$ and the recursive type $\mu x.T$ binds the recursion
variable~$x$ with scope $T$.  The set of \emph{free variables}, $\Free(T)$, in
a type $T$ is defined in the usual way, and so is the \emph{substitution}
of a type variable~$\alpha$ (resp.\ recursion variable~$x$) by a
type~$T$ in a type~$U$, denoted by $U\subs T \alpha$ (resp.\
$U\subs T x$).
%
We assume the variable convention whereby all variables in binding
occurrences in any mathematical context are pairwise distinct and
distinct from the free variables.

A session type may be $\skipk$ indicating no communication (this type
is unrestricted as it denotes a depleted channel that can be garbage
collected), $!B$ for sending a base type value, $?B$ for receiving a
base type value, or $(S_1; S_2)$ for the sequence of actions denoted
by $S_1$ followed by those denoted by $S_2$. Further, there are branch
types $\oplus\{l_i:T_i\}$ and choice types $\&\{l_i:T_i\}$ that either
select and send a label $l_i$ or branch on such a received label and
then continue on the corresponding branch. The formation rule for
sequence makes sure that its kind can only be unrestricted
$\Unrestricted$ if both $S_1$ and $S_2$ are. The formation rules for
the branch and choice types are straightforward.

The formation rules for recursion variables, type variables, and base
types are as expected.
% Recursive types cannot involve type schemes. 
Recursive types of the form $\mu x.T$ require that the body $T$ is
contractive in $x$ using the judgment $\Delta \Contr T$, %:\gamma$,
which we define shortly. The formation rules of the remaining type
constructions contain no surprises; the constituend types must not be
type schemes.  Finally, kind subsumption is standard and the
abstraction rule enables the formation of type schemes where
abstraction is restricted to types by the constraint $\kind
\le \kindt^\Linear$.

Regarding session types, the kinding system makes sure that the
operators $\&$, $\oplus$, and $\_;\_$ are only applied to session types,
that is, to types of kind $\kinds^m$. Types like
$(\intk \rightarrow \intk); \skipk$ and
$\oplus\{l_1\colon \intk, l_2\colon \intk\otimes \intk\}$ are not well formed. In
addition, types entirely composed of $\skipk$ may be assigned the
unrestricted kind~$\kinds^\Unrestricted$, whereas all other session
types are assigned the linear kind~$\kinds^\Linear$. An example of a
well-formed unrestricted session type is
$\cdot \vdash \mu x.(\skipk;\skipk)::\kinds^\Unrestricted$; an example
of a linear session type is
$\cdot \vdash (!\intk;\skipk);?\intk :: \kinds^\Linear$.
%
Recursion variables and type variables occurring free in types must be
defined in the kinding environment.
%
% Finally, a type scheme $\forall \alpha_1\dots\forall\alpha_n. T$ is
% \emph{well-formed} if $\alpha_1, \dots, \alpha_n \vdash T \isOk$ is
% derivable. 

% Contractivity

\input{fig-contractivity}

The language of types includes recursion, hence we must pay particular
attention to
\emph{contractivity}~\cite{DBLP:journals/tcs/Courcelle83}.  A type~$T$
is \emph{contractive on a recursion variable~$x$} if $\GEnv \Contr
T$ %:\gamma$
is derivable under an environment~$\GEnv$
that does \emph{not} contain~$x$.
%
% The contractivity system classifies session types under \emph{skips
%   only}, $\Guarded$, and \emph{productive}, $\Productive$, both
% denoted by metavariable~$\gamma$. % Not any more (vv)
%
% If $\GEnv \Contr T$ % : \Guarded$
% is derivable
% % , but not $\GEnv \Contr T : \Productive$
% then $T$ is essentially composed of $\skipk$s. On the other hand, if
% $\GEnv \Contr T$% : \Productive$
% is derivable then $T$ describes a nontrivial interaction.
%
The intuitive reading is that any use of recursion
variable~$x$ must be preceded (i.e., guarded) by a type construction that is different from $\skipk$.
%
The kinding system makes sure that well-formed types are contractive, by
calling the contractivity system in the rule for~$\mu$-types.

For example, types such as $\mu x. (\skipk; x)$ or $\mu x.(x; !\intk)$
are not contractive whereas $\mu x.(!\intk; x)$ is contractive.
%
The interaction between the $\mu$-operator and the semicolon is
nontrivial: the type $\mu x. \mu y. (x; y) $ is ruled out because~$x$
is not guarded. However, the type $\mu x. (!\intk; \mu y. (x; y))$ is
contractive because unrolling $\mu x$ reveals that the recursive
occurrence of $y$ is guarded:
$!\intk; \mu y. (\mu x. (!\intk; \mu y. (x; y)); y)$. 
Well-formedness of types is preserved
under arbitrary unrolling of $\mu$-operators, a result that we discuss
below.

The definition of contractivity incorporates type variables $\alpha$
and recursion variables $x$ by assuming that they are always replaced
by types that behave differently from  \lstinline|skip|.  Type
variables must be restricted in this way 
because contractivity of $\mu x. (\alpha; x)$ requires
$\alpha::\kind \Contr \alpha$ % : \Productive$
to be derivable so that $\alpha::\kind \Contr \mu x. (\alpha;
x)$ % : \Productive$
is derivable.

By abuse of notation let $\types$ denote the set of closed,
well-formed types, that is, of types $T$ such that
$\Delta \vdash T :: \kindt^m$, for some $\Delta$ that does not
bind recursion variables.
%
To avoid notational overhead, we let $S$ range over (closed) \emph{session
  types} with the understanding that $\Delta \vdash S :: \kinds^m$,
for some~$\Delta$ that does not bind recursion variables. We also
write $\kinds$ for the set of all such session types. 

\begin{lemma}[Substitution and kind preservation]\
%     [Type substitution preserves kinding]
  \label{lem:subs-preserves-kinding}
  \begin{itemize}
  \item If $\Delta,\alpha::\kind_1 \vdash T_2 :: \kind_2$ and
    $\Delta \vdash T_1 :: \kind_1$, then
    $\Delta \vdash T_2\subs{T_1}{\alpha} :: \kind_2$.
  \item If $\Delta,x::\kind_1 \vdash T_2 :: \kind_2$ and
    $\Delta \vdash T_1 :: \kind_1$, then
    $\Delta \vdash T_2\subs{T_1}{x} :: \kind_2$.
  \item If $\Delta \vdash \mu x.T :: \kind$, then
    $\Delta \vdash T\subs{\mu x.T}{x} :: \kind$.
  \end{itemize}
\end{lemma}
%
% \begin{proof}
%   By rule induction on the first hypothesis.
% \end{proof}


\subsection{Type Equivalence}
\label{sec:bisimulation}

Type equivalence is nontrivial in our system because the session type
sublanguage has a non-empty equational theory. This theory has two
components. First, the $\skipk$ and the sequence type constructors
form a monoid and as such should respect the monoidal laws: $\skipk$
is a left- and right-identity with respect to the sequence operator
and the sequence operator is associative. Second, the reading of the
$\mu$-operator is equirecursive, which means that a $\mu$-type is
equal to its unrolling. 

\input{fig-type-equivalence-lifted}

We concentrate on defining type equivalence for the session type
fragment (and extend to a congruence with respect to the remaining
type constructors, see Figure~\ref{fig:type-equivalence-lifted}).
%
% \vv{Perhaps alpha-equivalence? but we want more than that; we would
%   like to say that $(\skipk;\skipk,\intk) \approx (\skipk,\intk) $}
%
 Our approach relies on bisimulation. We regard two session types as
equivalent if they exhibit the same communication behavior. Previous
work follows a similar line, but syntactically restricts recursion to tail recursion which
simplifies the definition of type equivalence and guarantees its
decidability \cite{DBLP:journals/acta/GayH05}. 

To define the bisimulation on session types, we first need to define
a labelled transition system. Afterwards, we show that bisimilarity for
this system is decidable by reduction to basic process algebra (BPA),
a well-studied system
\cite{DBLP:journals/iandc/ChristensenHS95,DBLP:journals/jacm/BaetenBK93}. BPA
is known for generating context-free processes, which fits well with
our context-free session type framework.

\input{fig-lts}

In our labelled transition system, we consider the following primitive
actions:
\begin{itemize}
\item $!B$ and $?B$ for sending and receiving a base type value;
\item $\oplus l$ and $\& l$ for sending and receiving a label from a
  choice or branch type;
\item $\alpha$ (type variable) for an unknown, but nontrivial behavior.
\end{itemize}
In the following, let $A$ range over $\alpha$, $!B$, and $?B$; let $\star$ range over
$\oplus$ and $\&$; and let $a$ range over both $A$ and $\star l$. 
The labelled transition system is given the set of (well-formed) types
$\types$ as states, the set of \emph{actions} ranged over by $a$, and
the transition relation $\LTSderives$ defined by the rules in
Figure~\ref{fig:lts}. The transition relation 
makes use of an auxiliary judgment $\DONE{S}$ that characterizes
``terminated'' session types that exhibit no further action~\cite{DBLP:journals/jacm/AcetoH92}. The type
$\skipk$ has no action and a sequence $S_1;S_2$ has no action only if
both $S_1$ and $S_2$ have no action. A $\mu$-type has no action if
that is the case for  its body after unrolling. The definition of
$\DONE{S}$ is terminating for well-formed types. 

Apart from that, an $A$ action reduces an $A$ type to $\skipk$; $\star
l_i$ selects branch $l_i$ in a branch or choice type; and the
remaining transitions define the standard left-to-right behavior of
the sequence operator as well as the unrolling of the $\mu$-operator.
\begin{lemma}[Progress]\label{lemma:lts-progress}
  For each well-formed closed $S$, either $\DONE{S}$ or
  $\exists a, S'$ such that $S \LTSderives S'$.
\end{lemma}

%\vv{Proof sketch?}

The labelled transition system is deterministic and thus 
image-finite and finitely branching, but it has infinite transition
sequences 
($\mu x.!B;x \LTSderives[!B] \mu x.!B;x \LTSderives[!B] \dots$) as
well as transition sequences that visit
infinitely many different states
($\mu y.?B;y;\alpha \LTSderives[?B] \mu y.?B;y;\alpha;\alpha
\LTSderives[?B] \dots$).

Type bisimulation is defined in the standard way. We say that a binary
relation $\mathcal R$ on types is a \emph{bisimulation} if,
whenever $S_1 \mathcal R S_2$, for all $a$ we have:
%
\begin{enumerate}
\item for all $S_1'$ with $S_1 \LTSderives S_1'$, there is $S_2'$ such that $S_2
  \LTSderives S_2'$ and
  $S_1' \mathcal R S_2'$;
\item the converse, on transitions from $S_2$; i.e., for all $S_2'$ with
  $S_2 \LTSderives S_2'$, there is $S_1'$ such that $S_1 \LTSderives S_1'$ and
  $S_1' \mathcal R S_2'$.
\end{enumerate}

\emph{Bisimilarity}, written $\TypeEquiv$, is the union of all
bisimulations; thus $S_1 \TypeEquiv S_2$ holds if there is a bisimulation
$\mathcal R$ such that $S_1 \mathcal R S_2$.
%
Basic properties of bisimilarity ensure that $\TypeEquiv$ is an
equivalence relation, and that $\TypeEquiv$ is itself a
bisimulation~\cite{sangiorgi2014introduction}.

Two examples.
%
Take $S_1 \eqdef \mu x.\oplus\{l\colon \alpha, m\colon x\}$ and
$S_2 \eqdef \mu y.\oplus\{l\colon \skipk, m\colon y\}; \alpha$.  We
can easily show that $S_1 \TypeEquiv S_2$ by exhibiting an appropriate
bisimulation. Obviously the pair $(S_1,S_2)$ must be in the
relation. Then, using the rules in Figure~\ref{fig:lts}, we conclude
that $S_1 \LTSderives[\oplus l] \alpha$ and
$S_2 \LTSderives[\oplus l] \alpha$. Then we add pair $(\alpha,\alpha)$
to the relation. Because $\alpha$ reduces to $\skipk$, we add to the
relation the pair $(\skipk,\skipk)$. The other transition from
$(S_1,S_2)$ is by label $\oplus m$; in this case we have
$S_1 \LTSderives[\oplus m] S_1$ and $S_2 \LTSderives[\oplus m] S_2$.
The bisimulation we seek is then
$\{(S_1,S_2),(\alpha,\alpha),(\skipk,\skipk)\}$.

Now take $T_1 \eqdef \mu x.?B;x$ and $T_2 \eqdef \mu y.?B;y;y$.
%
We have $T_1 \LTSderives[?B] T_1 \LTSderives[?B] T_1 \dots$ We also
have
$T_2 \LTSderives[?B] T_2;\alpha \LTSderives[?B]
T_2;\alpha;\alpha\dots$
Since these are the only available transitions, the relation
$\{(T_1,T_2;\alpha^n) \mid n\ge 0\}$ is a bisimulation and contains
the pair $(T_1,T_2)$ when $n=0$.

% For example:
% %
% \begin{itemize}
% \item $S_1 \eqdef \mu x.\{l\colon \alpha, m\colon x\}$ and
%   $S_2 \eqdef \mu y.\{l\colon \skipk, m\colon y\}; \alpha$;
% \item $T_1 \eqdef \mu x.!B;x$ and $T_2 \eqdef \mu y.!B;y;y$.
% \end{itemize}

We now briefly explore the algebraic theory of bisimilarity, beginning
with some basic laws.
\begin{lemma}[Laws for terminated communication]
  For well-formed closed $S_1$ and $S_2$, if $\DONE{S_1}$ and $\DONE{S_2}$, then $S_1 \TypeEquiv S_2$.
\end{lemma}
%
\begin{proof}
  By Lemma~\ref{lemma:lts-progress}, neither $S_1$ nor $S_2$ can make
  a step. Hence, the relation
  $\{(S_1, S_2) \mid \DONE{S_1}, \DONE{S_2} \}$ is a bisimulation.
\end{proof}

\begin{lemma}[Laws for sequential composition]
\label{lemma:seq-laws}
  \begin{align*}
    \skipk;S \TypeEquiv&\; S
    \\
    S;\skipk \TypeEquiv&\; S
    \\
    (S_1;S_2);S_3 \TypeEquiv&\; S_1;(S_2;S_3)
    \\
    \star\{l_i\colon S_1\};S_2 \TypeEquiv&\; \star\{l_i\colon S_1;S_2\}
  \end{align*}
\end{lemma}
%
\begin{proof}
  Each law is proved by exhibiting a suitable bisimulation. For
  example, for the distributivity law we use the relation that
  contains the identity relation as well as all pairs of the form
  $(\star\{l_i\colon S_1\};S_2, \star\{l_i\colon S_1;S_2\})$.
  %(VV: one  more case here).
\end{proof}

Next we consider $\mu$-types and substitution.

\begin{lemma}[Laws for $\mu$-types]
\label{lemma:mu-laws}
  \begin{align*}
    \mu x. \mu y. S \TypeEquiv&\; \mu x. S\subs xy
    \\
    \mu x.S \TypeEquiv&\; S \quad\text{if}\quad x \notin \Free (S)
    \\
    \mu x.S \TypeEquiv&\; \mu y.S \subs yx
    \\
    S\subs{S'}{x} \TypeEquiv&\; S\subs{S''}{x} \quad\text{if}\quad S' \TypeEquiv S''
    \\
    \mu x.S \TypeEquiv&\; S\subs{\mu x.S}{x}
  \end{align*}
\end{lemma}
%
\begin{proof}
  Again, each law is proved by exhibiting a suitable bisimulation. For
  example, for the first case we use the relation that contains the
  identity relation as well as all pairs of the form
  $(\mu x. \mu y. S, \mu x. S[x/y])$ and
  $(\mu y.S[\mu x. \mu y. S/x], \mu x. S[x/y])$.
  % (VV: one  more case here).
\end{proof}

% \begin{lemma}
%   Rewriting a type with one of the bisimilarities from
%   Lemmas~\ref{lemma:seq-laws} and~\ref{lemma:mu-laws} does not affect
%   well-formedness of a session type.
% \end{lemma}

\begin{lemma}[Type equivalence preserves kinding]
  \label{lem:equiv-preserves-kinding}
  If $\Delta \vdash T_1::\kind$ and $\Delta \vdash T_1 \TypeEquiv T_2$
  then $\Delta \vdash T_2::\kind$.  
\end{lemma}

\begin{proof}
  By coinduction on the proof of $\Delta \vdash T_1 \TypeEquiv T_2$.
\end{proof}


\subsection{Type Equivalence Is Decidable}
\label{sec:decidability}

It turns out that we can translate each well-formed session type into
a guarded BPA (basic process algebra) process. The \emph{expressions of recursive BPA
processes} \cite{DBLP:journals/jacm/BaetenBK93} are generated by the
grammar
\begin{align*}
  E &::= a \mid x \mid E_1 + E_2 \mid E_1;E_2 \mid \varepsilon
\end{align*}
Here, $a$ ranges over atomic actions, $x$ over recursion
variables, $E_1+E_2$ denotes nondeterministic choice, $E_1;E_2$
stands for sequential composition, and $\varepsilon$ stands for a terminated
process. A \emph{BPA process} is defined as a pair consisting of an expression and a 
finite system of recursive process equations
\begin{align*}
%  \BPAprocess &= (E_0, \{ x_i = E_i \mid i,k\in\Nat, 1 \le i \le k \}) 
  \BPAprocess &= (E_0, \{ x_i = E_i \mid 1 \le i \le k \}) 
\end{align*}
where the $x_i$ are distinct and the $E_i$ are BPA expressions with
free variables in $\{x_1, \dots, x_k\}$. The behavior of a process is defined as the
behavior of $E_0$.

\input{fig-lts-bpa}


%\begin{definition}
  A BPA expression is \emph{guarded} if every variable occurrence is
  within the scope of an atomic action. A system $\{ x_i = E_i \}$ is
%  guarded, if each $E_i$ where $x_i$ occurs in some $E_j$ is guarded. 
  guarded, if each $E_i$  is guarded. 
%\end{definition}
%
%\begin{definition}
  A guarded BPA process $(E, \Xi)$ defines a \emph{labelled transition
    system}. The transition relation is the least relation
  $\LTSderives$ satisfying the rules in Figure~\ref{fig:lts-bpa}.
  Sometimes we explicitly write $(E, \Xi) \LTSderives (E', \Xi)$ if
  $E \LTSderives E'$ using the equations in $\Xi$.
%\end{definition}

The reason for our detour to BPA is the following decidability result
by Christensen and
coworkers~\cite{DBLP:journals/iandc/ChristensenHS95}, which we take as
the basis for proving decidability of type equivalence.

\begin{theorem}
  Bisimilarity is decidable for guarded BPA processes.
\end{theorem}

To reduce session type equivalence to bisimilarity of BPA processes,
we need to exhibit a translation from (well-formed) sessions types to
guarded BPA processes and show that this translation itself is a
bisimulation.

To this end, we define an unravelling function for a session type $S$,
$\Unravel(S)$, recursively by cases on the structure of~$S$.
\begin{align*}
  \Unravel(\mu x.S) & = \Unravel(S[\mu x.S/x])
  \\
  \Unravel (S;S') &= \left\{%
  \begin{array}{ll}
    \Unravel(S') & \Unravel(S) = \skipk
    \\
    (\Unravel(S); S') & \Unravel(S) \ne \skipk
  \end{array}
                        \right.
  \\
  \Unravel (S) &= S \qquad \text{for all other cases}
\end{align*}
The function $\Unravel$ is well-defined and terminating by our
assumption that the body of a recursive type is contractive. 


To define the translation to BPA,
we first show that, for a well-formed session type $S$, $\Unravel
(S)$ is guarded.
% That is the output of $\Unravel (S)$ is either
% $\skipk$ or it has one
% of the following forms:
\begin{lemma}[Characterization of $\Unravel$]
  \label{lem:unravel-yields-guarded-types}
  Suppose that $S$ is a well-formed closed session type.
% $\GEnv$ does not bind recursion variables and that
  % $\GEnv \vdash S :: \kinds^\Linear$,
  Then $\Unravel (S)$ is defined and yields either $\skipk$ or a
  guarded type of the form $O$ where
\begin{align*}
  O &\grmeq A \grmor \star\{l_i:S_i\}_{i\in I} \grmor (O; S)
\end{align*}
\end{lemma}

%\vv{Do we need a proof sketch?}

Now we define the translation of well-formed $S$ to a BPA as
follows. Assume that all recursion variable bindings are unique in the
sense that the set $\{ \mu x_1.S_1, \dots, \mu x_n.S_n\}$ contains all
distinct $\mu$-subterms of $S$.  Furthermore assume that for any free
recursion variable $x_i \in \Free(\mu x_j.S_j)$ it holds that
$i<j$. That is, the $\mu$-subterms are topologically sorted with
respect to their lexical nesting.


Now define unrolled versions of the $\mu$-subterms that have no free
recursion variables. As we are just unrolling recursion, replacing
$\mu_i.S_i$ by $S_i'$ in $S$ yields a term that is bisimilar to $S$
(Lemma~\ref{lemma:mu-laws}).
%
\begin{align*}
  S_1' &= S_1[\mu x_1.S_1/x_1] \\
  S_2' &= S_2[\mu x_2.S_2/x_2][\mu x_1.S_1/x_1] \\
       &\;\;\vdots \\
  S_n' &= S_n[\mu x_n.S_n/x_n]\dots [\mu x_1.S_1/x_1]
\end{align*}

Define the BPA process for $S$ as follows.
% 
\begin{align*}
  \toBPATop{S} &= (\toBPA{S}, \\
   \{ x_1=&\; \toBPA{\Unravel (S_1')}, \dots, x_n = \toBPA{\Unravel (S_n')} \}
  \\
  \\
  \toBPA{\skipk} &= \varepsilon \\
  \toBPA{A} &= A\\
  \toBPA{\star\{l_i\colon S_i\}_{i\in I}} &= \sum _{i\in I} \star l_i; \toBPA{S_i}\\
  \toBPA{\mu x.S} &=
                    \begin{cases}
                      \varepsilon & \DONE S
                      \\
                      x & \text{otherwise}
                    \end{cases}
                   \\
  \toBPA{S_1;S_2} &= \toBPA{S_1} ; \toBPA{S_2} \\
  \toBPA{x} &= x
\end{align*}
It is deliberate that we do \textbf{not} unravel the top-level type $S$ as this expression need not
be guarded. All equations are translated from unraveled session types so that they are guaranteed to
be guarded.

% Alternative: one could also define the equation extraction by
% induction on the kind derivation for $S$ and the right-hand side
% extraction by induction on the contractivity judgment. 

\begin{lemma}
  If $\mu x.S$ is a closed subterm of well-formed $S_0$ and not
  $\DONE S$, then $\toBPA{\Unravel (S)}$ is guarded with respect to
  $\toBPATop{S_0}$.
\end{lemma}
%
\begin{proof}
  By Lemma~\ref{lem:unravel-yields-guarded-types}, $\Unravel (S)$
  either yields $\skipk$ or a term of the form $O$. The answer
  $\skipk$ is ruled out by the assumption not $\DONE S$. Hence, the
  translation of a type of shape $O$ is guarded.
\end{proof}

It remains to show that $S$ is bisimilar to its
translation. Essentially, we want to prove that the function
$\toBPATop{\cdot}$ is a bisimilation when considered as a relation on states of transistion systems.

\begin{lemma}\label{lemma:skip-implies-done}
  Suppose that $S$ is a well-formed closed session type.
  If $\Unravel (S) = \skipk$, then $\DONE{S}$.
\end{lemma}
\begin{proof}
  Induction on the number $n$ of recursive calls to $\Unravel$.

  \textbf{Case }$n=0$. $S=\skipk$ and $\DONE{\skipk}$.

  \textbf{Case }$n>0$.

  \textbf{Subcase }$\mu x.S$. $\Unravel (\mu x.S) = \skipk$ because
  $\Unravel (S[\mu x.S/x]) = \skipk$. By induction,
  $\DONE{S[\mu x.S/x]}$ and by applying the $\DONE\mu$ rule
  $\DONE{\mu x.S}$.
  %

  \textbf{Subcase }$S_1;S_2$.  $\Unravel (S_1;S_2) = \skipk$ because
  $\Unravel (S_1) = \Unravel (S_2) = \skipk$. By induction
  $\DONE{S_1}$ and $\DONE{S_2}$. By the $\DONE;$ rule
  $\DONE{S_1;S_2}$.
\end{proof}

\begin{lemma}\label{lemma:s=unr-s}
  Suppose that $S$ is a well-formed closed session type.  Then
  $\toBPATop{S} \TypeEquiv \toBPATop{\Unravel (S)}$.
\end{lemma}
\begin{proof}
  Induction on the number $n$ of recursive calls to $\Unravel$.

  \textbf{Case} $n=0$. In this case, $S$ must be $\skipk$, $A$, or
  $\star\{l_i:S_i\}$ and the claim is immediate.

  \textbf{Case} $n>0$. There are two subcases.

  \textbf{Subcase} $\mu x.S$. Then $\toBPATop{\mu x.S} = (x, \dots)$
  and there is an equation $x = \toBPA{\Unravel(S\subs{\mu
      x.S}{x})}$.
  Now, $x$ is obviously bisimilar to
  $\toBPA{\Unravel(S\subs{\mu x.S}{x})}$.

  \textbf{Subcase }$S_1;S_2$. If $\Unravel (S_1) = \skipk$, then
  $\DONE{S_1}$ by Lemma~\ref{lemma:skip-implies-done}, and hence
  $\DONE{\toBPA{S_1}}$. Furthermore,
  $\Unravel (S_1;S_2) = \Unravel (S_2)$ and, by induction,
  $\toBPATop{S_2} \TypeEquiv \toBPATop{\Unravel(S_2)}$. The result
  follows because
  $\toBPATop{S_1;S_2} = ((\toBPA{S_1};\toBPA{S_2}), \dots) \TypeEquiv
  (\toBPA{S_2}, \dots)$
  and $\toBPATop{\Unravel(S_2)} = \toBPATop{\Unravel (S_1;S_2)}$.

  \begin{sloppypar}
    If $\Unravel (S_1) = S_u \ne \skipk$, then
    $\Unravel (S_1;S_2) = S_u; S_2$.  By induction, we know that
    $\toBPATop{S_1} \TypeEquiv \toBPATop{S_u}$ and as bisimilarity is
    a congruence
    $\toBPATop{S_1;S_2} \TypeEquiv ((\toBPA{S_u}; \toBPA{S_2}), \dots)
    = \toBPATop{\Unravel (S_1;S_2)}$.
  \end{sloppypar}
\end{proof}

\begin{lemma}\label{lemma:bisimulation-BPA-forwards}
  Suppose that $S$ is a well-formed closed session type.  If
  $S \LTSderives S'$, then $\toBPATop{S} \LTSderives \toBPATop{S'}$.
\end{lemma}
\begin{proof}
  By induction on  $S \LTSderives S'$.

  \textbf{Case }$A \LTSderives[A] \skipk$.
  In this case $\toBPATop{A} = (A, \emptyset) \LTSderives[A] (\varepsilon, \emptyset) = \toBPATop{\skipk}$.

  \textbf{Case }$\star\{l_i\colon S_i\}_{i\in I} \LTSderives[\star
  l_j] S_j$, for $j\in I$.  In
  this case
  \begin{align*}
    \toBPATop{\star\{l_i\colon S_i\}}
    & =(\sum_{i\in I} \star l_i; \toBPA{S_i},
      \overline{x_k = E_k}) \\
    & \LTSderives [\star l_j]
      (\toBPA{S_j}, \overline{x_k = E_k \mid x_k \text{ reachable}}) \\
    & =  \toBPATop{S_j}
  \end{align*}

  \begin{sloppypar}
    \textbf{Case
    }$\frac{S_1 \LTSderives S_1'}{S_1; S_2 \LTSderives S_1';S_2}$.  In
    this case
    % \begin{align*}
    %   \toBPATop{S_1;S_2}
    %   & = ((E_1; E_2), \overline{x_j = E_j})
    % \end{align*}
    $ \toBPATop{S_1;S_2} = ((E_1; E_2), \overline{x_j = E_j}) $
%
    where $E_i = \toBPA{S_i}$ for $i=1,2$.  Because
    $S_1 \LTSderives S_1'$, we obtain by induction that
    $\toBPATop{S_1} = (E_1, \overline{x_j = E_j \mid x_j\text{
        reachable}}) \LTSderives \toBPATop{S_1'} = (E_1', \dots)$.
    Therefore,
    $$((E_1;E_2), \dots) \LTSderives ((E_1';E_2), \overline{x_j =
      E_j}) = \toBPATop{S_1'; S_2}$$
  \end{sloppypar}

  \begin{sloppypar}
    \textbf{Case
    }$\frac{\DONE{S_1} \quad S_2 \LTSderives S_2'}{S_1; S_2
      \LTSderives S_2'}$.
    Again, $\toBPATop{S_1;S_2} = ((E_1;E_2), \dots)$ where
    $E_i = \toBPA{S_i}$ for $i=1,2$.  It is easy to see that
    $\DONE{S_1}$ implies $\DONE{\toBPA{S_1}}$, that is, $\DONE{E_1}$.
    Because $S_2 \LTSderives S_2'$, we obtain by induction that
    $\toBPATop{S_2} = (E_2, \dots) \LTSderives \toBPATop{S_2'} = (
    E_2', \dots)$.
    Therefore,
    $(( E_1;E_2), \dots) \LTSderives (E_2', \dots) = \toBPATop{S_2'}$.
  \end{sloppypar}

  \begin{sloppypar}
    \textbf{Case
    }$\frac{S[\mu x.S/x] \LTSderives S'}{\mu x.S \LTSderives S'}$.  In
    this case $\toBPATop{\mu x.S} = (x, \overline{x_j = E_j})$ where
    $x=x_i \in \overline{x_j}$ and
    $E_i = \toBPA{\Unravel (S[\mu x.S/x])}$.  By induction,
    $\toBPATop{S[\mu x.S/x]} \LTSderives \toBPATop{S'}$, which proves
    the claim because
    $\toBPATop{S[\mu x.S/x]} \TypeEquiv (E_i, \overline{x_j = E_j})$
    by Lemma~\ref{lemma:s=unr-s}.
  \end{sloppypar}
\end{proof}

%\clearpage
\begin{lemma}\label{lemma:bpa-unr-s}
  Suppose that $S$ is a well-formed closed session type and that $\toBPATop{\Unravel
    (S)} \LTSderives \BPAprocess'$. Then $S \LTSderives S'$
  and $\BPAprocess' = \toBPATop{S'}$.
\end{lemma}
\begin{proof}
  By induction on the number $n$ of recursive calls of $\Unravel$.

  \textbf{Case }$n=0$.

  \textbf{Subcase }$S=\skipk$. Contradictory.

  \textbf{Subcase }$S=A$. Then $a=A$, $\BPAprocess'=(\varepsilon, \emptyset)$, and $S' =
  \skipk$.

  \textbf{Subcase }$S = \star\{l_i\colon S_i\}_{i\in I}$. Then $a = \star
  l_j$ with $j\in I$, $\BPAprocess'= \toBPATop{S_j}$, and $S' = S_j$.

  \textbf{Case }$n>0$.

  \textbf{Subcase }$S = S_1;S_2$.
  If $\Unravel (S_1) = \skipk$, then $\Unravel (S) = \Unravel
  (S_2)$ with fewer than $n$ calls. As $\toBPATop{\Unravel (S_2)} \LTSderives \BPAprocess'$, induction yields
  that $S_2 \LTSderives S'$ and $\BPAprocess' = \toBPATop{S'}$.
  As $\Unravel (S_1) = \skipk$, we know that $\DONE{S_1}$. Hence,
  ${S_1;S_2} \LTSderives S'$ and $\BPAprocess' = \toBPATop{S'}$.

  If $\Unravel (S_1)\ne \skipk$, then consider $\toBPATop{\Unravel({S_1});
    S_2} \LTSderives (E',\overline{x_j=E_j})$ because $\toBPATop{\Unravel({S_1})} \LTSderives
  \BPAprocess_1'$ where $\BPAprocess_1' = (E_1', \overline{x_j = E_j \mid x_j \text{ reachable}})$,
  so that induction yields some $S_1'$ such that $S_1 
  \LTSderives S_1'$ and $\BPAprocess_1' = \toBPATop{S_1'}$.
  Clearly, $(S_1; S_2) \LTSderives (S_1'; S_2)$ and $E' = E_1'; \toBPA{S_2}$.

  \textbf{Subcase }$\mu x.S$.
  $\Unravel (\mu x.S) = \Unravel (S[\mu x.S/x])$ with one less
  invocation of $\Unravel$. As $\toBPATop{\Unravel (S[\mu x.S/x])}
  \LTSderives \BPAprocess'$, induction yields that  $S[\mu x.S/x] \LTSderives
  S'$ with $\BPAprocess' = \toBPATop{S'} $.
\end{proof}

\begin{lemma}\label{lemma:bisimulation-BPA-backwards}
  Suppose that $S$ is a well-formed closed session type. If
  $\toBPATop{S} \LTSderives \BPAprocess'$, then there is some $S'$
  such that $S \LTSderives S'$ and $\toBPATop{S'} = \BPAprocess'$.
\end{lemma}
\begin{proof}
  By induction on $S$.

  \textbf{Case }$\skipk$. Contradictory: $\BPAprocess = (\varepsilon, \emptyset)$ cannot step.

  \textbf{Case }$A$. $\BPAprocess = (A, \emptyset)
  \LTSderives (\varepsilon, \emptyset)$ and $A \LTSderives \skipk =: S'$.

  \textbf{Case }$\star\{l_i\colon S_i\}$. 
  \begin{align*}
    \BPAprocess
    & = (\sum\star l_i; \toBPA{S_i},  \overline{x_j =  E_j}) \\
    & \LTSderives[\star l_i] (\toBPA{S_i}, \overline{x_j =  E_j \mid x_j \text{ reachable from }\toBPA{S_i}})
  \end{align*}
  and
  $\star\{l_i\colon S_i\} \LTSderives[\star l_i] S_i =: S'$.

  \textbf{Case }$S_1;S_2$.
  \begin{align*}
    \BPAprocess
    & = (\toBPA{S_1;S_2}, \overline{x_j =  E_j}) \\
    & = (\toBPA{S_1};\toBPA{S_2}, \overline{x_j =  E_j})
  \end{align*}
  There are two cases. Either $(\toBPA{S_1},\overline{x_j =  E_j}) $ can make a step or $\DONE{\toBPA{S_1}}$ and
  $(\toBPA{S_2}, \overline{x_j =  E_j})$ can make a step.

  If $(\toBPA{S_1},\overline{x_j =  E_j}) \LTSderives (E_1', \overline{x_j =  E_j \mid x_j \text{ reachable}})$,
  then $S_1 \LTSderives S_1'$ and $(E_1', \overline{x_j =  E_j \mid x_j \text{ reachable}})  = \toBPATop{S_1'}$, by induction.
  Now we obtain that
  \begin{align*}
    & ((\toBPA{S_1};\toBPA{S_2}), \overline{x_j =  E_j}) \\
    &\LTSderives ((E_1';
      \toBPA{S_2}), \overline{x_j =  E_j \mid x_j \text{ reachable}})\\
    &= \toBPATop{S_1'; S_2}
  \end{align*}
  Choose $S' = S_1';S_2$.

  \begin{sloppypar}
    If $\DONE{\toBPA{S_1}}$ and
    $\toBPATop{S_2} \LTSderives (E_2', \overline{x_j = E_j \mid x_j
      \text{ reachable}})$,
    then $\DONE{S_1}$ and $S_2 \LTSderives S_2'$ and
    $(E_2', \overline{x_j = E_j \mid x_j \text{ reachable}}) =
    \toBPA{S_2'}$,
    by induction. Now, $\toBPATop{S_1;S_2} \LTSderives
    \toBPA{S_2'}$. Choose $S' = S_2'$.
  \end{sloppypar}
  \textbf{Case }$\mu x.S$. \\
  $\BPAprocess = \toBPATop{\mu x.S} = (x, \overline{x_j = E_j})$ where $x=x_i \in \overline{x_j}$.
  If $\BPAprocess \LTSderives \BPAprocess'$,
  then it must be because there is an equation $x_i = E_i$ and $\BPAprocess_i := (E_i, \overline{x_j = E_j})
  \LTSderives \BPAprocess'$.
  By definition of $\toBPATop{}$ it must be that $E_i = \toBPA{\Unravel(S[\mu x. S/x])}$ and
  $\BPAprocess_i = \toBPATop{\Unravel(S[\mu x. S/x])}$.

  Use Lemma~\ref{lemma:bpa-unr-s}
  to establish the claim.
\end{proof}

\begin{theorem}
  Suppose that $S$ is a well-formed closed session type and let
  $\BPAprocess = \toBPATop{S}$.
  \begin{enumerate}
  \item If $ S \LTSderives[a] S'$, then $\BPAprocess \BPAderives[a]
    \BPAprocess'$ with $\BPAprocess' = \toBPATop{S'}$.
  \item If $\BPAprocess \BPAderives[a] \BPAprocess'$, then $S
    \LTSderives[a] S'$ with  $\BPAprocess' = \toBPATop{S'}$.
  \end{enumerate}
\end{theorem}
\begin{proof}
  By Lemmas~\ref{lemma:bisimulation-BPA-forwards} and~\ref{lemma:bisimulation-BPA-backwards}.
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
