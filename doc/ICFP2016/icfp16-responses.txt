Thanks to the reviewers for their thoughtful comments.

** decidability of type equivalence vs undecidability of CFG equivalence

Type equivalence is proved by reduction to BPA equivalence. 
It is also related to equivalence of *deterministic*  context-free languages,
which is also decidable.

It was surprising (to the authors) that type equivalence is decidable without
any restrictions. We were expecting to impose restrictions to obtain decidability.

** -> vs -o

Our apologies for the confusion. 
Our setup (which is consistent) is influenced by the cited work of Gay and Vasconcelos, 
which seems to use the lollipop symbol in a non-standard way.
Each type has a linearity attribute formalized with predicate un(T):
* T1 -> T2  is the type of a function that may be used multiple times
It can subsume to
* T1 -o T2 is the type of a function that must be used exactly once
* sessions must be used exactly once
* T1  (x) T2 is the type of a tensor that must be used exactly once

[standard usage of the lollipop indicates a function that uses its argument linearly]

The "possible counterexample" (Review A), \x.(x,x), does not allow to
copy a linear parameter: in the derivation of

     |- \x.(x,x) : T -> (T tensor T)

there is one undischarged assumption, un(T), coming from the copy rule.

** lemma 3.3

The bisimulation needed for this proof is 
R={(S1,S2) | S1 terminating and S2 terminating}.
It's a bisimulation because a terminating type
cannot make a step.

** proofs in 4.4

The proofs are similar to those in reference [11], section 6. 
The main result (Thm 4.9, Soundness) relies on exactly the same
lemmata (congruence and the substitution lemmas, sub-derivation
introduction and elimination, and inversion). Linearity crucially
comes into play in the substitution lemma where the assumption for the
replaced variable is removed from the typing context.

** corollary 4.11 and progress for the full language

It should be easy to see that the full language does not enjoy
progress. Consider two processes exchanging messages on two
different channels:

	 (send on a; send on b) | (recv on b; recv on a).

The nonbuffered (rendez-vous, synchronous) semantics guarantees a
deadlocked situation. Section 7.5 of a recent survey reviews a few
alternatives for progress on session type systems (Huttel, Lanese, et
al., Foundations of session types and behavioural contracts. ACM
Comput. Surv. 49, 1, Article 3 (April 2016))

** challenges for type checking

[The pessimistic wording in the conclusion refers to an earlier draft,
before we realized the connection with BPA.]
The typing rules (Figure 6) are mostly syntax directed and we
conjecture that the choice between -o and -> could be resolved by
bidirectional type checking.
Polymorphism would be dealt with as in Haskell: polymorphic recursion
requires type annotations and linearity would be addressed by
threading the linear variable environment.
An algorithm for deciding type equivalence would be sufficient for type checking a fully type-annotated program.
This algorithm would apply the construction in the paper: translate to BPA and use the algorithm for
equivalence of BPAs.

For more ambitious goals (full type inference and subtyping), one
would have to define some sort of type unification and type inclusion.
These problems are more complicated than mere type equivalence and we
expect to address them by using approximations, leading to sound, but
incomplete procedures. 

** equirecursive vs isorecursive presentation

We believe there is an isorecursive presentation, which leads to decision problems related to visibly context-free
languages. For these languages, equivalence and containment are decidable, so that it seems to give rise to
easier decision problems (but at the price of a loss of some expressiveness).

** (1) why not Tree -> TreeChannel -> end

That type would be appropriate for a calculus with channel passing. In our calculus,
the typing does not fit the recursive call, even though it would fit
non-recursive calls.

** (4) let

let (a,b) = e in ... eliminates the tensor
let x = e1 in e2   is syntactic sugar


