===========================================================================
                           ICFP 2016 Review #48A
---------------------------------------------------------------------------
               Paper #48: Towards Context-Free Session Types
---------------------------------------------------------------------------

                      Overall merit: B. OK paper, but I will not champion
                                        it
                         Confidence: Y. I am knowledgeable in this area,
                                        but not an expert

                         ===== Paper summary =====

Traditional session types are related to regular languages, because the types are tail-recursive, analogous to regular grammars in which the r.h.s. of a production must begin with a terminal symbol; such session types can model serialization of list-like data structures.  The paper envisions session types that are related to context-free languages.  Thus, the resulting session types can model serialization of more complicated data structures, such as trees.

This is a really interesting idea.  My first reaction was extremely positive.  I was briefly disturbed by the paper seeming to contradict the known result that equivalence of CFGs is undecidable, but it appears that the "guardedness" of basic process algebras is allowing the authors to avoid that, so it seems okay (but I think this point should be emphasized in the paper).  The first two sections of the paper seem like they should be understandable even with only a passing knowledge of session types.

However, I have some concerns about later parts of the paper.  The broadest concern is that, while the core of the paper is (quite reasonably) devoted to type equivalence, the linear type system is an equally important component.  I have a specific question about how typing for -> and -o works (see below under Sec. 4), but another concern is that the proofs in 4.4 (in contrast, I think, to the proofs earlier in the paper) seem very terse.  In an ordinary (nonlinear) type system, substitution lemmas need minimal justification; in a linear type system, they are not standard and deserve more, I think, than a casual "By induction".  Perhaps there are fuller proofs elsewhere for very similar systems, but in that case, the paper should include clear references to them.  It's fine to reuse rules from earlier systems, but then the explanation of the system (and/or metatheory) should clearly reference the earlier work.

                      ===== Comments for author =====

Sec. 1

"recursive datatypes and XML documents": an XML document is essentially a recursive datatype, yes?  You don't seem to return to this later, so I would just drop "and XML documents".

The mention of polymorphic recursion seemed a little premature.  There are plenty of type systems that allow it (DML, other refinement types, etc.) and it's only a concern for type inference, which seems off in the future for this system.

"moniodal"

"functional sublanguage": define here what this means.  It only became clear to me near the end of the paper.

Sec. 2

"given that c :: TreeChannel;\alpha": Use ":" not "::", for consistency with rest of paper.

"equi-recursive...": Define and/or cite.  Many readers won't know what this means.

Sec. 3

In Fig. 3, note what star and 'a' range over (it is explained in the text, but not the figure).

Lemma 3.3 is stated without any proof (maybe it's clear to the authors, but I couldn't see immediately how to do it).

"constituend" -> constituent
"the exhibit" -> they exhibit

Sec. 4

"fo expressions"

I'm confused about the rules for -> and -o.  You treat T1 -> T2 as a refinement of T1 -o T2 in which (for ->) you have the additional information that the context Γ is unrestricted (the second premise of the intro rule for ->).  I thought that the intuitive understanding of -> vs. -o is that -o cannot use its argument more than once.  But the difference between the two intro rules has nothing to do with T1; rather, the difference is in the rest of the context.  One thought I had is that "un(Γ)" might be a typo for "un(Γ,a:T1)"?  I checked Gay and Vasconcelos (2010), and they have exactly the same intro rules, but I couldn't find a clarification of this particular point either.

The shape of a possible counterexample might be

  λx.(x,x)

which (using the copy rule) has type $T \rightarrow (T \otimes T)$ under empty Γ.  Then I use the rule that turns → into -o, and apply it to a linear type.  Hopefully I am just missing something, and the authors can clarify.

Please add the names "weak", "copy", "~" that you use in the text to those rules in Fig. 6.

"fat rule": I have never heard this term.  I would say "combined rule".

Sec. 5
"et at."

===========================================================================
                           ICFP 2016 Review #48B
---------------------------------------------------------------------------
               Paper #48: Towards Context-Free Session Types
---------------------------------------------------------------------------

                      Overall merit: A. Good paper, I will champion it
                         Confidence: Y. I am knowledgeable in this area,
                                        but not an expert

                         ===== Paper summary =====

The paper extends session types with the ability to express sending
and receiving context-free recursive structures (i.e., trees). This
requires non-trivial additions to the language of session types, such
as sequential composition of session type expressions, polymorphic
session type variables, and polymorphic recursion. Neither of these
have been considered before. Also required is a non-trivial extension
to type equality, which now has to include equi-recursive treatment of
type recursion, distribution of sequential type composition over
branching types, and monoidal laws for sequential composition of
session types.

It is not obvious in this setting that type equality is decidable,
because one can write a recursive session type expression that is not
tail recursive, and whose unfolding goes through infinitely many
states. This contrasts with regular (i.e., tale-recursive) session types, whose unfoldings are guaranteed to cycle.

Nevertheless, type equality is actually decidable, and one of the main
results of the paper is the decision algorithm that works by reducing
type equality to bisimilarity for guarded processes in Basic Process
Algebras (BPA). The reduction works thanks to various (reasonable, I
think) restrictions imposed on session type through the kinding
judgments, such as productivity, contractivity and first-order
recursion (i.e., no sending channels over channels).

The paper then shows a form of a linear type system for the calculus,
and proves the appropriate forms of preservation and progress
theorems.

                      ===== Comments for author =====

I am not an expert on session types, so I couldn't really determine
the difficulty and significance of the main accomplishments. In
particular, is the decidability of the type equality in this context
surprising, is the reduction to BPAs unusual, and are the restrictions
on type formation that are needed for the reduction to work
reasonable.

But, putting those aside, I really have nothing to object to in this
paper, and I think it should be accepted. The idea to target
context-free recursive structures with session types is certainly
well-motivated, the formalism looks very natural, and the paper is
excellently written.

One question that perhaps the authors could answer in the rebuttal
period is the status of Corollary 4.11. It says the progress is proved
for the functional sub-language, and I'm curious what would progress
for the full language look like (if that's just Theorem 4.10, why is
the corollary even interesting enough to be named?)

===========================================================================
                           ICFP 2016 Review #48C
---------------------------------------------------------------------------
               Paper #48: Towards Context-Free Session Types
---------------------------------------------------------------------------

                      Overall merit: B. OK paper, but I will not champion
                                        it
                         Confidence: Y. I am knowledgeable in this area,
                                        but not an expert

                         ===== Paper summary =====

This paper studies context free session types in the context of inductive data
type serialization. It presents a syntax of such session types and shows
examples programs operating on binary trees that they are rejected by type
systems of regular session types, but they could be potentially type-checked
with with a type system of context-free session types. The paper makes progress
towards such a more advanced session type system by proving that, given a simple
transition system, bisimulation of context free session types reduces to
bisimulation of context free processes, which is decidable.
A type assignment system is then defined which, however, does not give rise to a
type-checking algorithm. As stated in the conclusions, more work is required for
a type-checking algorithm for context-free session types to be possible.

                      ===== Comments for author =====

This work is a step into an interesting direction: the improvement of the
expressive power of session types. As the paper explains, this could be achieved
by typing programs with a type system supporting context-free session types.
This however requires---at least---decidability of type equivalence.
To achieve this the paper translates session types to first order processes and
uses the known result that strong bisimulation for such processes is decidable.
This is possible only after dropping the usual delegation construct of session
types, which would allow channels to be sent over other channels. If this
construct is added the session type language becomes higher-order and the
decidability result does not apply.

This is a reasonable simplification for a first study of context free session
types. There are, however, other decidability results for strong bisimulation of
the higher-order pi calculus which could perhaps support full context free
session types with delegation. For example:

  I. Lanese, J. A. Pérez, D. Sangiorgi, A. Schmitt, 
  On the expressiveness and decidability of higher-order process calculi,
  Information and Computation 2011.

Ideally, the restriction to first-order session types would lead to type
checking context-free session types in functional programs. However, the
conclusions state:

  "There is more work to do towards a practical type-checking algorithm as the
  algorithm resulting from the decidability proof is very hard to implement. We
  plan to proceed in this direction by giving up on completeness for type
  checking, but going for a sound approximation instead."

Does this mean that the only challenge for a type-checking algorithm is a
practical algorithm for deciding strong bisimulation? 

It is difficult to see an obvious answer by observing the fairly complex
inference rules of figure 6 (the type assignment system), and the paper itself
does not address this question. Even the challenge of finding a bisimulation
algorithm is not mentioned before the conclusions. 

If the answer to this question is positive then perhaps a type-checking
algorithm could have been given, assuming an oracle that decides bisimulation.
This would at least have shown that no other complications exist in
type-checking, and the source of potential incompleteness is only due to type
equivalence. Moreover, one would be able to plug-in in the type checker sound,
decidable approximations of the oracle and investigate their usefulness in
actual code. 

If, on the other hand, other substantial complications exist in developing a
type-checking algorithm, which have to be addressed in a future paper, then a
good discussion about them in the main body of the paper is warranted.

===========================================================================
                           ICFP 2016 Review #48D
---------------------------------------------------------------------------
               Paper #48: Towards Context-Free Session Types
---------------------------------------------------------------------------

                      Overall merit: B. OK paper, but I will not champion
                                        it
                         Confidence: X. I am an expert in this area

                         ===== Paper summary =====

I have mixed feelings about this paper, but I am minded to recommend accepting it. It addresses the issue of how to express and enforce communication protocols which trade in tree-structured data. The goal is certainly one that I find motivating. The complexity of the approach, however, makes me rather worried and inclined to ask whether we could live with less. Specifically, the choice to use an equirecursive fixpoint is what makes type equivalence here such a hard problem: it is impressive that they solved the problem (by translating types to processes in a calculus for which bisimulation is decidable), but is it worth it? The decidability property seems brittle and reliant on going not much further than context-free data. If we want more expressivity (say, Haskell-style GADTs), this approach to type equivalence will stop working. Even so, it is good to see how much is possible in this direction. The paper is well written, has good motivating examples, and has convinced me of its main results. It is a valuable contribution.

                      ===== Comments for author =====

Section by section

1 It is good to see sendTree, which is clearly the simplest nontrivial example. It raises an obvious naive question, however: why is the type not something like Tree -> TreeChannel -> end? What is it that makes the polymorphic recursion necessary? It's a little sad that the discussion of Sill comes at the end of the paper rather than here, because the readers really should know that somebody already has a session type system which allows the communication of trees. What is the type of sendTree in Sill? It seems to me that the job done by semicolon here is done by the tensor in the Caires-Pfenning school, but in a rather different way.

2 This section is very helpful. It is good to lead with such thoughtfully presented examples.

3 This is where the hard work happens, much of which is the consequence of equirecursion. Is there an isorecursive presentation? I would be tempted to start with explicit fixpoint unrolling in the language, to simplify typechecking, but retain the contractivity requirement so that every well typed isorecursive program can be translated to its equirecursive counterpart. We then would not need an algorithm to decide type equivalence for equirecursion, just a theorem about assignability of types.

  p5  the exhibit --> they exhibit

4 Am I right in noting that some let..in constructions are just syntactic sugar, whilst others are eliminations for tensors? It might be helpful to separate these notations. Also, I worry when I see let..in syntax immediately followed by in as injection.

  p10 rules fo expressions --> rules for expressions

Let me remark, though, that the GV-style does lead to very readable programs. This part of the paper makes a valuable design contribution which would survive any reconsideration of the equirecursion issue.

5 In the comparison with Sill etc, it's right to note that the CP way is explosive in channel creation, which is fundamental to the treatment of the tensor, but is also the way those systems achieve their compositionality. If you implement such systems naively, they will indeed have a heavy channel creation overhead and issues of embarrassing parallelism. The semicolon here is a more overtly sequential construct than the tensor, makes it clear when we can use the same channel to send messages in order. Amusingly, though, the CP approach might lead to highly efficient *parallel* communication of tree-like data, exploiting multiple physical channels if they are available.

6 I am glad to see that the authors, too, recognize that the complexity of their system is a considerable burden. The part of that complexity that is needed to tame equirecursion seems hard to sustain, and worse, limits the potential of the system to advance towards more subtle and flexible typing disciplines. However, it is certainly good to have such a thorough exploration of this part of the design space.
