\subsection{Trace simulation}
\label{sec:trace-simulation}

In this section, we define a trace semantics for session types and prove that type equivalence
coincides with equality of trace sets. Before defining trace languages, we recall some standard
notions from formal language theory. A language $U$ over an alphabet $\Sigma$ is a set of finite
words $U\subseteq \Sigma^*$ with $\varepsilon$ denoting the empty word. Correspondingly, an
$\omega$-language $U\subseteq\Sigma^\omega$ is a 
set of infinite words. We let $\Sigma^\infty = \Sigma^* \cup \Sigma^\omega$ denote the set of finite
and infinite words over $\Sigma$.
We write $|w|$ for the length of a finite word $w\in \Sigma^*$ and define
$|w| = \infty$ if $w \in \Sigma^\omega$. We denote concatenation of words by  the operator
$\cdot :
\Sigma^\infty \times \Sigma^\infty \to \Sigma^\infty$  or just by juxtaposition, if that is unambiguous, with the usual
definition:
\begin{align*}
  u \cdot v &=
              \begin{cases}
                u v & \text{if }|u|<\infty \\
                u & \text{if }|u|=\infty
              \end{cases}
\end{align*}
We define concatenation of ($\omega$-) languages $U\cdot V = \{u\cdot v \mid u\in U,
v \in V \}$ in terms of concatenation of words. 
We abuse notation and sometimes write symbols for single-symbol words and words for single-word
languages. 

\begin{definition}
  Let $\Sigma = \{ {!B}, {?B} \mid B \in \btypes\} \uplus \Tyvars \uplus \{ {\oplus L^i}, {\& L^i} \mid I
  \text{ finite index set}, L =  \{l_j \mid j\in I\}
  \subseteq \Labels, i \in I  \}$ be the alphabet of trace actions where
  a symbol of the form $\oplus L^i$ is a pair of a finite set $L$ of labels that occur together in a choice type and $i$
  is an index identifying an element of $L$. 

%%DONE \vv{Why not use $\oplus L^i$ in place of $\oplus L^i$ (same for $\& L^i$).}
 
A \emph{trace language} is a subset $\TL$ of $\Sigma^\infty$ that
satisfies the following conditions that cover determinacy and
branching.

%% DONE
% \vv{We use $T$ for types. Shall we use $U$ instead? (or $\mathcal U$,
%   since it is a set).}

  \begin{description}
  \item[(T1)] If $uav, ubw \in {\TL}$ with $u\in\Sigma^*$, $v,w \in \Sigma^\infty$, and
    $a \ne b \in \Sigma$, then there exist $L$, $i$, and $j$ such that either  $a=\oplus L^i$ and $b=\oplus L^j$ or $a=\& L^i$ and $b=\& L^j$.
  \item[(T2)]
    If $u\oplus L^i v \in {\TL}$ then there are $v_j$ such that $u\oplus L^jv_j \in {\TL}$, for all $j\ne i \in I (L)$, and
  analogously for $\& L^i$.
  \end{description}
\end{definition}
Condition \textbf{(T1)} says that the only branching points in a trace are the marks of branches
$\& L^i$ and choices $\oplus L^i$ and that they must be used consistently (all marks are either incoming or
outgoing and they must refer to the same label set $L$). Moreover, condition \textbf{(T2)} says that
each branch/choice is exhaustive. 

\begin{definition}\label{def:trace-language}
  Let $S$ be a session type and $\rho$ a mapping from recursion variables to trace languages such
  that $\dom (\rho) \subseteq \Free (S)$.
  The \emph{trace language of a session type} $\TR (S)\rho \subseteq \Sigma^\infty$ is defined by
  induction on $S$.
  \begin{align*}
    \TR (\skipk)\rho &= \{ \varepsilon \} \\
    \TR (\alpha)\rho &= \{ \alpha \} \\
    \TR (!B)\rho &= \{ !B \} \\
    \TR (?B)\rho &= \{ ?B \} \\
    \TR (S_1;S_2)\rho &= \TR (S_1)\rho \cdot \TR (S_2)\rho \\
    \TR (\oplus\{l_i\colon S_i\}_{i\in I})\rho &= {\cup} \{  {\oplus L_i} \cdot \TR (S_i)\rho \mid {i\in I} \} \\
    \TR (\&\{l_i\colon S_i\}_{{i\in I}})\rho &=  {\cup} \{ {\& L_i} \cdot \TR (S_i)\rho \mid {i\in I} \} \\
    \TR (\mu x.S)\rho &= \GFP\, \lambda Y. \TR (S)\rho[x\mapsto Y] \\
    \TR (x) \rho & = \rho (x)
  \end{align*}
\end{definition}

\vv{Merge cases 2--4 as $\TR (A)\rho = \{A\}$.}

\vv{Merge cases 6--7 with $\star$, if you accept my suggestion above
  for $\oplus L^i$.}

\vv{Don't we need braces around $\oplus L^i$ in cases 6--7? ${\cup} \{  \{\oplus L^i\} \cdot \TR (S_i)\rho \mid {i\in I} \}$.}

\vv{A sentence on why the $\GFP$ exists?}

\vv{Why do we need the proviso ``$\dom (\rho) \subseteq \Free (S)$''?
  I assume $\Free (S)$ denotes the set of free \emph{recursion
    variables} in $S$. Then what is the problem of defining
  $\TR (\skipk)[x\mapsto\{!B\}] = \{\varepsilon\}$. In fact, I believe
  that $\TR(\mu x.!B)\emptyset$ would not be defined, nor $\TR(\mu
  x.\oplus\{l\colon x, m\colon!B\})\emptyset$.}

\begin{lemma}
  Let ${\TL} = \TR (S) \rho$ with $S$ and $\rho$ according to Definition~\ref{def:trace-language}. Then
  ${\TL}$ is a trace language.
\end{lemma}
\begin{lemma}
  If $w \in \TR (S) \rho$ and $w$ is branch-free (that is, it does not contain symbols of the form
  $\oplus L^i$ or $\& L^i$), then $\TR (S)\rho = \{w\}$ and either $w$ is finite or $w=  uv^\omega$.
\end{lemma}
\begin{proof}
  By induction on $S$. (Sketch.)

  \textbf{Case }$\skipk$. Finite.

  \textbf{Case }$A$. Finite.

  \textbf{Case }$(S_1;S_2)$. By induction, $\TR (S_1)\rho = \{w_1\}$ and $\TR (S_2)\rho =
  \{w_2\}$. Consider $L = \TR (S_1)\rho \cdot \TR (S_2) \rho$. If $w_1$ is infinite, then $L = \{
  w_1\}$ and the claim holds by induction. If $w_1$ is finite, then $L = \{ w_1w_2 \}$ which is
  finite if $w_2$ is, and $w_1w_2 = w_1 u_2v_2^\omega$ if $w_2=u_2v_2^\omega$.

  \textbf{Case }$\star\{\overline{l_n:S_n}\}$. Contradicts branch-freedom.

  \textbf{Case }$\mu x.S$.
  \begin{align*}
    & w \in \TR (\mu x.S) \rho \\
    & = \GFP\, \lambda Y.\TR (S)\rho[x \mapsto Y] \\
    & = \TR (S) \rho[x \mapsto \GFP\, \lambda Y.\TR (S)\rho[x \mapsto Y]] \\
    & \text{ if $\TR( S)\rho$ independent of $x$,}\\
    & \text{ then the result is immediate by induction} \\
    & = \TR (S) \rho[x \mapsto \emptyset] \\
    & \text{ if $\TR (S) = v\cdot x$, then} \\
    & = \GFP\, \lambda Y.v \cdot Y \\
    & = \{ v^\omega \}
  \end{align*}

\vv{Remove the $w\in$ part from the 1st line?}

\vv{I am a bit puzzled with this proof. I did not expect we could go
  by induction. In a sense $S$ gets smaller, but $\rho$ gets
  larger. Now we are doing induction on $S$, not on $\rho$.  If we can
  proceed by induction then, there is a simpler proof. Let $U$ be the
  trace language $\GFP\, \lambda Y.\TR (S)\rho[x \mapsto Y]$.
%
  \begin{align*}
    & \TR (\mu x.S) \rho && \text{by definition}\\
    =\; & U \\
    =\; & \TR(S)\rho[x\mapsto U] && \text{by I.H.}\\    
    =\; & \{w\}
  \end{align*}
}
\end{proof}

As languages with a mixture of finite and infinite words are cumbersome to deal with, we make the
trace languages into proper $\omega$-languages by completing the finite words with an infinite
sequence of new blank symbols that are added to the alphabet.
\begin{definition}
  Let ${\TL} \subseteq \Sigma^\infty$ be a mixed language and $\BLANK \notin \Sigma$ a new
  symbol. Define   $\widehat{{\TL}} = {\TL} \cdot \BLANK^\omega \subseteq (\Sigma\cup\{\BLANK\})^\omega$. 

  The \emph{$\omega$-trace language of a session type} is defined by $\TRw (S) = \widehat{\TR
    (S)\emptyset} \subseteq (\Sigma\cup\{\BLANK\})^\omega$.
\end{definition}
\begin{lemma}\label{lemma:trw-never-empty}
  Trace languages of well-formed session types are never empty.
\end{lemma}

\begin{lemma}
  \label{lemma:tr-unfold}
  For all substitutions $\sigma$ of recursion variables:
  $\TR (S\sigma)\rho = \TR (\Unfold (S\sigma))\rho$.
\end{lemma}
\vv{Suggestion: ``$\sigma$ from recursion variables to types''}
\begin{proof}
  By induction on $S$. We ignore $\sigma$ when it is not
  needed. \vv{Better if we do not omit; otherwise omissions may look
    like typos.}

  \textbf{Case }$\skipk$. Obvious.

  \textbf{Case }$\alpha$, $!B$, $?B$. Obvious. \vv{use $A$ instead}

  \textbf{Case }$(S_1;S_2)$. Consider the cases for the result of $\Unfold (S_1)$.

  \textbf{Subcase }$\skipk$:
  By induction, $\TR (S_1)\rho = \TR (\skipk)\rho = \{\varepsilon\}$.
  Hence, 
  $\TR (S_1; S_2)\rho = \TR (S_2)\rho =
  \TR (\Unfold (S_1;S_2))\rho$.

  \vv{I guess we also need IH for $\TR(S_2\sigma)\rho$.}

  \textbf{Subcase }$A$:
  By induction, $\TR (S_1)\rho = \TR (A) \rho = \{A\}$.
  Hence,
  $\TR (S_1; S_2)\rho = \{A\} \cdot \TR (S_2)\rho =
  \TR (\Unfold (S_1;S_2))\rho$

  \textbf{Subcase }$(S_3; S_4)$:
  By induction, $$\TR (S_1)\rho = \TR (\Unfold (S_1)) \rho = \TR (S_3;  S_4) \rho.$$
  Hence,
  \begin{align*}
    \TR (S_1;S_2)\rho & = \TR (S_3;S_4)\rho \cdot \TR (S_2) \rho \\
                      &=  \TR (S_3) \rho \cdot  \TR(S_4)\rho \cdot \TR (S_2) \rho\\
                      &= \TR (\Unfold (S_1;S_2))\rho
                        .
  \end{align*}
  \textbf{Subcase }$\star\{l_i\colon S_i\}$: by distibutivity of $\cdot$ over union.

  \textbf{Case }$\star\{l_i\colon S_i\}$: trivial (remains fixed).

  \textbf{Case }$\mu x.S$:
  \begin{align*}
    & \quad\ \TR (\Unfold (\mu x.S\sigma))\rho \\
    & = \{ \text{ by unfold } \} \\
    & \TR (\Unfold(S\sigma[\mu x.S/x]))\rho \\
    & =  \{ \text{ by inductive hypothesis } \} \\
    & \TR (S\sigma[\mu x.S/x])\rho \\
    & =  \{ \text{ by definition TR } \} \\
    & \TR (S\sigma)\rho[x\mapsto \GFP\,\lambda Y. \TR (S)\rho[x\mapsto Y]] \\
    & =  \{ \text{ by fixpoint } \} \\
    & \GFP\,\lambda Y. \TR (S\sigma)\rho[x\mapsto Y] \\
    & =  \{ \text{ by definition TR } \} \\
    & \TR (\mu x.S\sigma)\rho
  \end{align*}
  \vv{There is a $\sigma$ missing in the two lines after unfold as
    well as in the $\GFP$ line; in the first two cases we need
    $S\sigma[\mu x.S\sigma/x]$, the third should be $\TR(S\sigma)$.}

  \vv{Again puzzled. Take $S$ for the type $\mu x.!B;x$. Then
    $\TR(\Unfold(S\emptyset))\emptyset = \TR(\Unfold(S))\emptyset =
    \TR(\Unfold(A;S\emptyset))\emptyset =
    \TR(\Unfold(A;S))\emptyset$.
    Now, $A;S$ is larger than $S$; are you sure one can proceed by
    induction here?}
\end{proof}

To prove equality of trace languages, we extend the coinductive proof techniques developed by Rot
and coworkers \cite{DBLP:conf/lata/RotBR13} to $\omega$-languages. To explain the technique, we consider an LTS $(\Power
(\Sigma^\omega), \Sigma, \LTSderives)$ where the states are $\omega$-languages and the actions the
symbols of the alphabet. The action of a letter $a$ on a language is defined as its derivative:
\begin{align*}
  {\TL} & \LTSderives[a] {\TL}_a := \{ w \in \Sigma^\omega \mid aw \in {\TL} \}
\end{align*}
\begin{definition}\label{def:language-bisimulation}
  A relation $R \subseteq \Power(\Sigma^\omega) \times \Power(\Sigma^\omega)$ is a
 \emph{bisimulation} on $\omega$-languages if
  \begin{description}
  \item[(B1)] $\forall (U, V) \in R$, $\forall a \in \Sigma$, $(U_a,
    V_a) \in R$;

    \vv{$U_a$ may not be defined. The standard definition of bisim
      avoids this case:
      \begin{equation*}
        U \LTSderives[a]  U' \text{ implies } V \LTSderives[a] V'
        \wedge U' R V'
      \end{equation*}
      (we also need the symmetric case.)
    }

  \item[(B2)] $(\emptyset,V)  \in R$ implies $V = \emptyset$;
  \item[(B3)] $(U, \emptyset) \in R$ implies $U = \emptyset$.
  \end{description}
  Bisimilarity $\bisim$ is the union of all bisimulations.
\end{definition}
Bisimilarity in this LTS corresponds to equality of trace languages.
\begin{proposition}
  For all $U, V \subseteq \Sigma^\omega$,  $U=V$ implies $U\bisim V$. 
\end{proposition}
\begin{proof}
  Every bisimulation is an equivalence relation.
\end{proof}
\begin{proposition}\label{proposition:bisim=equality}
  For all trace languages $U, V \subseteq \Sigma^\omega$,  $U\bisim V$ implies $U=V$. 
\end{proposition}
\begin{proof}
  Suppose
  that $U \bisim V$. If $U=\emptyset$, then $V=\emptyset$ by requirement~(B2). If $U\ne\emptyset$,
  then we show that $w \in U$ implies $w\in V$. To do so, we consider prefixes $w[n] = w_0\dots
  w_{n-1}$, for $n\in\Nat$, where $w_i \in\Sigma$ is the $i$th symbol of $w$, and show that for all $n\in\Nat$,
  $w_nw_{n+1}\ldots \in U_{w[n]} \ne \emptyset$ and $U_{w[n]} \bisim V_{w[n]}$. As this result implies $V_{w[n]}
  \ne\emptyset$, for all $n\in\Nat$, it must be that $w \in V$.

  \textbf{Case }$0$ is immediate.

  \textbf{Case }$n>0$: Assume by the inductive hypothesis that $U_{w[n]} \bisim V_{w[n]}$ and let
  $a=w_n$ so that $w[n+1] = w[n]a$. By requirement~(B1), $U_{w[n+1]} \bisim V_{w[n+1]}$,
  $w_{n+1}w_{n+2}\ldots \in U_{w[n+1]} \ne \emptyset$, and hence $V_{w[n+1]} \ne \emptyset$.
\end{proof}

Given this result, it is sufficient to establish a bisimulation between languages $U$ and $V$ to
prove that $U=V$. We exploit this fact to prove the next proposition.

\begin{proposition}
  If $S_1 \TypeEquiv S_2$, then $\TRw (S_1) = \TRw (S_2)$.
\end{proposition}
\begin{proof}
  It is sufficient to establish a bisimulation $Q \supseteq (\TRw (S_1), \TRw (S_2))$. To this end
  define 
  \begin{align*}
    Q &= \{ (\TRw (S_1), \TRw (S_2)) \mid S_1 \TypeEquiv S_2 \} \cup \{(\emptyset, \emptyset)\}
  \end{align*}
  The requirements~(B2) and~(B3) from Definition~\ref{def:language-bisimulation} are fulfilled because
  $\TRw (S)$ is never empty by Lemma~\ref{lemma:trw-never-empty}. It remains to show that $\forall
  a\in\Sigma$, $(U,V) \in Q$ implies $(U_a, V_a) \in Q$ by cases on the definition of $F$. We only
  consider guarded session types because unfolding does not affect the trace language (Lemma
  \ref{lemma:tr-unfold}). 
  \begin{enumerate}
  \item $(\TRw (\skipk), \TRw (\skipk)) = (\{\$^\omega\}, \{\$^\omega\}) \in Q$. On symbol $\$$
    remain fixed. On any other symbol, both side transition to $\emptyset$ and
    $(\emptyset,\emptyset) \in Q$.
  \item $(\TRw (A), \TRw (A)) = (\{A\cdot\$^\omega\}, \{A\cdot\$^\omega\}) \in Q$. On symbol $A$,
    both sides transition to state $\{\$^\omega\}$ and $(\{\$^\omega\}, \{\$^\omega\}) \in Q$. On
    any other symbol, both sides transition to $\emptyset$.
  \item $(\TRw (A;S_1), \TRw (A;S_2)) = (A\cdot\TRw (S_1), A\cdot\TRw (S_2)) \in Q$. On a symbol
    $\ne A$ both sides transition to $\emptyset$. On symbol $A$, we need to check that $(\TRw
    (S_1),\TRw (S_2)) \in Q$, which holds because $(A;S_1) \TypeEquiv (A;S_2)$ implies $S_1
    \TypeEquiv S_2$. 
  \item $(\TRw (\star\{\overline{l_n:S^1_n}\}), \TRw (\star\{\overline{l_n:S^2_n}\})) \in Q$ implies
    that $(\TRw (S^1_i), \TRw (S^2_i)) \in Q$, for all $i$, because $S^1_i \TypeEquiv S^2_i$.
  \end{enumerate}
  The claim follows by Proposition~\ref{proposition:bisim=equality}.
\end{proof}

\begin{lemma}
  If  $\TRw (S_1) \subseteq \TRw (S_2)$, then  $S_1 \TypeEquiv S_2$.
\end{lemma}
\begin{proof}
  Let $R = \{ (S_1, S_2) \mid \TRw (S_1) \subseteq \TRw (S_2) \}$ and show that $R
  \subseteq  F(R)$. 
  By Lemma~\ref{lemma:tr-unfold}, it is sufficient to consider the unfolded guarded types
  for $(S_1, S_2)$.

  \textbf{Case }$(\skipk, \skipk) \in F (\emptyset)$.

  \textbf{Case }$(A, A) \in F (\emptyset)$.

  \textbf{Case }$((A;S_1'), (A; S_2'))$. From $\TRw (A; S_1') = \{A\} \cdot \TRw (S_1') \subseteq
  \{A\} \cdot \TRw (S_2') = \TRw (A; S_2')$ it follows that $\TRw (S_1') \subseteq \TRw (S_2')$ so that
  $(S_1', S_2') \in R$. Hence, $(S_1, S_2) \in F (R)$.

  \sloppypar
    \textbf{Case
    }$(\star\{l_i\colon S_{1,i}\}, \star\{l_i\colon
    S_{2,i}\})$.
    Here we require the closedness condition on trace languages to
    conclude from
    $\TRw (\star\{l_i\colon S_{1,i}\}) = {\cup} \{ L_i \cdot \TRw
    (S_{1,i}) \} \subseteq {\cup} \{ L_i \cdot \TRw (S_{2,i}) \} =
    \TRw (\star\{l_i\colon S_{2,i}\}) $
    that $\TRw (S_{1,i}) \subseteq \TRw (S_{2,i})$, for all $i$, which
    in turn means $(S_{1,i}, S_{2,i}) \in R$, for all $i$. Hence
    $(S_1, S_2) \in F(R)$.
  %\end{sloppypar}
\end{proof}
\clearpage{}
Next, we set out to prove that $\TRw (S)$ is an $\omega$-context-free language. To do so, we a
construct a PDA from $S$ that recognizes the same language. We may assume that each recursion variable
in $S$ is uniquely bound, that is, for each $x\in S$, there is exactly one subterm of $S$ of the
form $\mu x.S'$.
We exploit this restriction to define a ``lazy'' version of unfolding with respect to some $S$ as follows.
\begin{enumerate}
\item $\Unfold_S(\mu x.T) = \Unfold_S(T)$
\item $\Unfold_S (S_1;S_2) = \left\{%
  \begin{array}{ll}
    \Unfold_S(S_2) & \Unfold_S(S_1) = \skipk
    \\
    (A; S_2) & \Unfold_S(S_1) = A
    \\
    (x; S_2) & \Unfold_S(S_1) = x
    \\
    (S_3; (S_4;S_2)) & \Unfold_S(S_1) = (S_3;S_4)
    \\
    \star\{l_i\colon S'_i;S_2\}  & \Unfold_S (S_1) = \star\{l_i\colon S'_i\}
  \end{array}
  \right.
$
%\item $\Unfold_S (x) = \Unfold_S(T)$, where $\mu x.T$ is the unique subterm of $S$ determined by $x$
\item $\Unfold_S(T) = T$, otherwise
\end{enumerate}
Define the (finite) set of all lazy unfoldings of subterms of a given session type $S$:
\begin{align*}
  \Unfold^* (S)& = \{ \Unfold_S (S') \mid S' \text{ subterm of }S \}.  
\end{align*}
All types in this set are guarded by construction or their ``first action'' is defined by a
recursion variable $x$.

We may further assume that the only occurrences of $\skipk$ in $S$ appear in the otherwise empty branches
of branch and choice types. Each well-formed session type may be transformed into this $\skipk$-reduced form.


Now we are ready to define a PDA $\PDA(S)$ for $S$.
The set of stack symbols of $\PDA (S)$ is $\Gamma = \Unfold^* (S)$.
The set of states is $Q = \{ q_0, q \}$.
The transition function is defined by
\begin{enumerate}
\item $q_0 \to [\Unfold_S (S)] q$
\item $[\skipk] q \to q$
\item $[A] q A \to q$
\item $[A;S'] q A \to [\Unfold_S (S')] q$
\item $[\star\{l_i:S_i\}] q L_j \to [\Unfold_S (S_j)] q$
\item\label{item:4} Let  $\mu x.S'$ be the subterm of $S$  determined by $x$:
  \begin{enumerate}
  \item\label{item:5} $[x] q \to [\Unfold_S(S')] q$ 
  \item\label{item:6} $[x; S''] q \to [\Unfold_S (S'')][\Unfold_S(S')] q$ 
  \end{enumerate}
\end{enumerate}

This automaton is deterministic, but it has some transitions that do not consume input (cf.\ Item~\ref{item:4}). These
$\varepsilon$-transition may be eliminated by identifying the symbols $[x]$ and $[\Unfold_S(S')]$,
which eliminates the transitions according to Item~\ref{item:5}, and by pulling back the transition
of Item~\ref{item:6} to the transition that pushes a symbol of the form $[x; S'']$. Contractivity
ensures that this transformation of the PDA terminates. Hence, there is a real-time DPDA that
accepts the same language as $\PDA (S)$.

The PDA $\PDA (S)$ accepts a language by the trivial acceptance criterion (i.e., existence of a run is
sufficient to accept a word).

\begin{lemma}
  $\TR (S)\emptyset = L (\PDA(S))$.
\end{lemma}
\begin{proof}
  First we need to become more concrete. Let words $u,v,w$ range over $\Sigma^\infty$ unless
  otherwise indicated. 

  $\forall w$: $w \in \TR (S)\emptyset$ iff there is a run for $[\Unfold_S (S)] q w$.

  Induction on $S'$ as a subterm of $S$.

  \textbf{Case }$\skipk$:\\
  $w = \TR (\skipk)\emptyset= \varepsilon$ and a run $[\skipk] q \varepsilon
  \vdash q$ obviously exists.

  \textbf{Case }$A$: \\
  $w = \TR (A)\emptyset= A$ and there is a run $[A] q A \vdash q$.

  \textbf{Case }$(S_1;S_2)$:\\
  $w = \TR (S_1;S_2) \emptyset= \TR (S_1) \emptyset \cdot \TR (S_2)\emptyset$

  Case analysis on $S_1' = \Unfold_S (S_1)$.

  \textbf{Subcase }$S_1' = \skipk$: In this case, $\TR (S_1) \emptyset = \{\varepsilon\}$, $\Unfold_S
  (S_1;S_2) = \Unfold_S (S_2)$, and the result holds by induction on $S_2$.

  \textbf{Subcase }$S_1' = A$: In this case,  $\TR (S_1) \emptyset = \{ A \}$, $\Unfold_S (S_1;S_2)
  = (A; S_2)$, $w = Aw'$, $w' \in \TR (S_2)\emptyset$, and there is a transition $[A;S_2] q A \vdash
  [\Unfold_S (S_2)] q$. By induction on $S_2$, there is a run for $[\Unfold_S (S_2)] q w'$.

  \textbf{Subcase }$S_1' = \star\{l_i:S_i\}$: In this case, $\TR (S_1) \emptyset = \bigcup_i \{ L_i
  \} \cdot \TR (S_i)\emptyset$, $\Unfold_S (S_1;S_2) = \star\{l_i:(S_i; S_2)\}$, $w = L_j w'$, $w'
  \in \TR(S_j; S_2)\emptyset$, and there is a transition $[\star\{l_i:(S_i; S_2)\}] q L_j \vdash
  [\Unfold_S (S_j; S_2)]q $. \textbf{Need a terminating order so that we can argue by induction
    here:} By induction, $w'  \in \TR(S_j; S_2)\emptyset$ iff exists a run for $[\Unfold_S (S_j;
  S_2)]q w'$.

  \textbf{Subcase }$S_1' = (S_3;S_4)$: In this case,  $\TR (S_1) \emptyset = \TR (S_3)\emptyset
  \cdot \TR (S_4) \emptyset$, $\Unfold_S (S_1;S_2) = (S_3;(S_4; S_2))$, $w = uv$, and $\TR
  (S_3)\emptyset = u $, $\TR (S_4;S_2)\emptyset = v$.

  We need to construct a run for $[(S_3;(S_4; S_2))] q uv$. \textbf{To this end, we need to be able to argue
  by induction }
  that $[(S_3;(S_4; S_2))] q u v \vdash^* [\Unfold_S (S_4;S_2)] v $ and that the latter configuration has
  a run.

  \textbf{Subcase }$S_1' = x$: In this case, $\TR (S_1)\emptyset = \dots$ \textbf{Here, it's not
    clear how to replace $\emptyset$ by a meaningful environment.}
\end{proof}

\clearpage

\begin{theorem}\label{theorem:tr-is-w-CFL}
  $\TRw (S)$ is an $\omega$-context-free language.
\end{theorem}
\begin{proof}
  We may assume that the only occurrences of $\skipk$ in $S$ appear in the otherwise empty branches
  of branch and choice types. Each well-formed session type may be transformed in this $\skipk$-reduced form.

  For the translation from $S$ to the productions of a context-free grammar, we rely on a monad that
  is a combination of an output monad to collect the set of productions and a name generator monad
  for fresh nonterminal symbols. The monadic functions \Out{} and \Fresh{} output a production and
  return a new nonterminal symbol drawn from a set $\NT$. We use a Haskell-inspired \Do{} notation
  for composing monadic functions.
  \begin{figure}[tp]
    \begin{align*}
      \toLHS (\skipk)\SEnv & = \Return\ \varepsilon \\
      \toLHS (A)\SEnv & = \Return\ A \\
      \toLHS (S_1; S_2)\SEnv & = \Do
                              \begin{array}[t]{l}
                                \gamma_1 \gets \toLHS (S_1) \\
                                \gamma_2 \gets \toLHS (S_2) \\
                                \Return (\gamma_1\cdot\gamma_2)
                              \end{array}
      \\
      \toLHS (\star\{\overline{l_n:S_n}\})\SEnv &= \Do
                                                 \begin{array}[t]{l}
                                                   N_\star \gets \Fresh \\
                                                   \dots \\
                                                   \gamma_i \gets \toLHS (S_i)\SEnv \\
                                                   \Out (N_\star \to \star L^i \cdot \gamma_i) \\
                                                   \dots \\
                                                   \Return\ N_\star
                                                 \end{array}
      \\
      \toLHS (\mu x.S)\SEnv &= \Do
                             \begin{array}[t]{l}
                               N_\mu^x \gets \Fresh \\
                               \gamma \gets \toLHS (S)\SEnv[x \mapsto N_\mu^x] \\
                               \Out (N_\mu^x \to \gamma) \\
                               \Return\ N_\mu^x
                             \end{array}
      \\
      \toLHS (x) \SEnv &= \Return\ (\SEnv (x))
      \\
      \toCFG (S) &= \Do
                   \begin{array}[t]{l}
                     N_0 \gets \Fresh \\
                     \gamma \gets \toLHS (S)\emptyset \\
                     \Out (N_0 \to \gamma) \\
                     \Return\ N_0
                   \end{array}
    \end{align*}
    \caption{Translation of a session type to a CFG}
    \label{fig:session-to-grammar}
  \end{figure}

  Figure~\ref{fig:session-to-grammar} defines the translation with two functions $\toCFG$ and $\toLHS$. The entry point
  is $\toCFG$ which creates the start symbol $N_0$ of the grammar and invokes $\toLHS$ to create the
  right hand side of the production. The function $\toLHS$ takes a session type $S$ and an environment
  $\SEnv$ mapping recursion variables to nonterminals. It returns a string of terminals and
  nonterminal and creates new productions as needed. New productions are started for each branch or
  choice type to model the alternative and for each $\mu$-type to model the recursion.

  If the session type $S$ is  $\skipk$-reduced, then the generated grammar has no
  $\varepsilon$-productions. Moreover, the grammar is deterministic because for each nonterminal there is
  either just one rule (for the start symbol $N_0$ and for the symbols $N_\mu$ used to model
  recursion) or each rule starts with a distinct terminal symbol (for the branch and choice symbols $N_\star$). 

  It remains to show that the thus generated grammar defines $\TR (S)\emptyset$. To this end, we let
  $N_0 \gets \toCFG (S)$ and call the generated set of productions (extracted from the output monad)
  $P$. That is, formally we have to show that $\TR (S) \emptyset = L^\infty (P)( N_0)$, which may be
  defined as the projection on $N_0$ of the greatest fixpoint of the productions $P$
  \cite{Niwinski1984}. This fixpoint is a nonterminal-indexed vector of $\infty$-languages which we
  write equivalently as a mapping $\rho$ from nonterminals to $\infty$-languages:
  \begin{align*}
    L^\infty (P) & = \GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv) \\
    \RHS (P, N, \LEnv) &= \bigcup_{N \to \gamma \in P} \hat\LEnv({\gamma}) & \gamma & \in (\Sigma \cup
                                                                                 \NT)^* \\
    \hat\LEnv (\varepsilon) &= \{\varepsilon\} \\
    \hat\LEnv (a \gamma)  &= \{ a \} \cdot \hat\LEnv (\gamma)  & a &\in \Sigma\\
    \hat\LEnv (N \gamma) &= \LEnv (N) \cdot \hat\LEnv (\gamma) & N & \in \NT
  \end{align*}

  We show by induction on the execution of $\gamma \gets \toLHS(S)\SEnv$ that $\TR (S) \rho =
  \hat\LEnv (\gamma) $ where $\LEnv = \GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv)$ with $P$
  being the final output of the grammar generation and, for all $x\in\Free (S)$, $\rho (x) = \LEnv (N_\mu^x)$.

  \textbf{Case }$\skipk$. Immediate.

  \textbf{Case }$A$. Immediate.

  \textbf{Case }$(S_1;S_2)$. By induction, $\TR (S_i) \rho = \hat\LEnv (\gamma_i)$ where $\gamma_i
  \gets \toLHS (S_i)\SEnv$ so that $\toLHS (S_1;S_2)\SEnv$
  returns $\gamma_1\cdot\gamma_2$. Hence $\TR (S_1;S_2)\rho = \TR (S_1)\rho \cdot \TR (S_2)\rho =
  \hat\LEnv (\gamma_1\cdot\gamma_2)$ as desired.

  \textbf{Case }$\star \{ \overline{l_n:S_n} \}$. By induction, $\TR (S_i) \rho = \hat\LEnv
  (\gamma_i)$ where $\gamma_i \gets \toLHS (S_i)\SEnv$ so that $\toLHS (\star \{ \overline{l_n:S_n}
  \})\SEnv$ returns some $N_\star$ with productions $N_\star \to \star L^i \cdot \gamma_i \in P$.
  Hence, by unrolling the fixpoint, 
  \begin{align*}
    \hat\LEnv (N_\star) & = \LEnv (N_\star) \\
                        & = \bigcup_{N_\star \to \gamma \in P} \hat\LEnv  (\gamma) \\
                        &= \bigcup_i \hat\LEnv (\star L^i \cdot \gamma_i)  \\
                        &=\bigcup_i \{\star L^i\} \cdot\hat\LEnv (\gamma_i)  \\
                        &=\bigcup_i \{\star L^i\} \cdot\TR (S_i)\rho  \\
                        &=\TR( \star\{ \overline{ l_n: S_n}\} )\rho
  \end{align*}
\clearpage
  \textbf{Case }$\mu x.S$.
  Let $N_\mu^x$ be the fresh nonterminal generated for this recursion and
  $\gamma \gets \toLHS (S)\SEnv[x \mapsto N_\mu^x]$ its right hand side.
  By induction,
  $\TR (S) \rho[x \mapsto \hat\LEnv (N_\mu^x)] = \hat\LEnv(\gamma)$.
  \begin{align*}
    \hat\LEnv (N_\mu^x) &= \LEnv (N_\mu^x) \\
                        &= \hat\LEnv (\gamma) \\
                        &= \TR (S) \rho[x \mapsto \hat\LEnv (N_\mu^x)] \\
                        &=? \\
                        &= \TR (S) \rho[x \mapsto \GFP\ \lambda Y. \TR (S)\rho[x \mapsto Y]] \\
                        &= \GFP\ \lambda Y. \TR (S) \rho[x \mapsto Y] \\
                        &= \TR (\mu x.S)\rho \\
                        &\\
    & \text{Apply David Park's lower fixpoint induction principle:} \\
    \hat\LEnv (\gamma) & \subseteq \GFP\ \lambda Y. \TR (S) \rho[x \mapsto Y] \\
    \text{iff } & \exists X. X \subseteq \TR (S) \rho[x \mapsto X] \wedge \hat\LEnv (\gamma)
                   \subseteq X \\
    \text{choose } & X = \hat\LEnv (\gamma) \\
    \text{then } & \hat\LEnv (\gamma) \\
                        &\stackrel{IH}= \TR (S)\rho[x \mapsto \LEnv (N_\mu^x)] \\
                        &= \TR (S)\rho[x \mapsto (\GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv)) (N_\mu^x)] \\
                        &= \TR (S)\rho[x \mapsto \RHS (P, N_\mu^x, \LEnv)] \\
                        &= \TR (S)\rho[x \mapsto \hat\LEnv (\gamma)] \\
  \end{align*}
  For the reverse direction, we want to prove that
  \begin{align}\label{eq:3}
    \GFP\ \lambda Y. \TR (S) \rho[x \mapsto Y] & \subseteq (\GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv)) (N_\mu^x)
  \end{align}
  Now we can apply Bekic-Leszczylowski to the right hand side to pull out the fixpoint on component
  $N_\mu$.
  \begin{align*}
    & (\GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv)) (N_\mu^x) \\
    &= \GFP\, \lambda Y. \RHS (P, N_\mu, (\GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv[N_\mu
      \mapsto Y])) ) \\
    &= \GFP\, \lambda Y.
      \begin{array}[t]{l}
        \hat\delta (\gamma) \\
        \text{where}\ \delta = (\GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv[N_\mu
      \mapsto Y]))
      \end{array}
  \end{align*}
  Now we need $X$ such that
  \begin{align*}
    X &\subseteq \begin{array}[t]{l}
        \hat\delta (\gamma) \\
        \text{where}\ \delta = (\GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv[N_\mu
      \mapsto X]))
      \end{array}
    \\
    & \GFP\ \lambda Y. \TR (S) \rho[x \mapsto Y] \subseteq X
  \end{align*}
  But all this requires the statement that we want to prove \dots

  To proceed, we blow up the left hand side of Equation~\eqref{eq:3} to a vector by taking the
  components for $N \ne N_\mu$ from the right hand side.
  \begin{align*}
    & \GFP\, \lambda \LEnv. [N_\mu \mapsto \TR (S) \rho[x \mapsto \LEnv(N_\mu)], N \mapsto \RHS (P, N, \LEnv)]
      \\
    & \subseteq
      (\GFP\, \lambda \LEnv. \lambda N. \RHS (P, N, \LEnv))
  \end{align*}
  To apply Park's lower fixpoint induction principle again, we need to find an environment $\xi$ such that 
  \begin{align}\label{eq:4}
    && \xi & \subseteq \lambda N. \RHS (P, N, \xi)  \\
    \notag\Leftrightarrow &
           & \forall N. \xi (N) & \subseteq \RHS (P, N, \xi)
  \end{align}
  and
  \begin{align}\label{eq:5}
    \GFP\, \lambda \LEnv.
    \left[
    \begin{array}{l}
      N_\mu \mapsto \TR (S) \rho[x \mapsto \LEnv(N_\mu)] \\
      N \mapsto \RHS (P, N,    \LEnv)
    \end{array}
    \right]
 &\subseteq \xi
  \end{align}
  
  Let's try with $\xi=\delta$, the fixpoint of the rhs.
  Clearly, Equation~\eqref{eq:4} holds because $\delta$ is a fixpoint.

  Unfolding the lhs of Equation~\eqref{eq:5} and expanding pointwise yields
  \begin{align}
    \TR (S) \rho[x \mapsto (\GFP\dots)(N_\mu)] & \subseteq \LEnv (N_\mu)  = \hat\delta (\gamma)\\
    \RHS (P, N,  (\GFP\dots)) & \subseteq \LEnv (N) & N \ne N_\mu
  \end{align}

  \begin{align*}
    \toCFG (\skipk, N) & = \{ N \to \varepsilon \} \\
    \toCFG (\alpha, N) & = \{ N \to \alpha \} \\
    \toCFG (!B, N) & = \{ N \to !B \} \\
    \toCFG (?B, N) & = \{ N \to ?B\} \\
    \toCFG ((S_1; S_2), N) & = \{ N \to N_1N_2 \} \cup \toCFG (S_1, N_1) \cup \toCFG (S_2, N_2) \\
    \toCFG (\oplus\{l_i\colon S_i\}, N) & = \{ N \to {\oplus L_i} N_i \mid i\in I \} \cup \toCFG (S_i, N_i) \\
    \toCFG (\&\{l_i\colon S_i\}, N) & = \{ N \to {\& L_i} N_i \mid i\in I \} \cup \toCFG (S_i, N_i) \\
    \toCFG (\mu x.S, N) &= \{ N \to N_x \} \cup \toCFG (S, N_x) \\
    \toCFG (x, N) &= \{ N \to N_x \} \\
  \end{align*}
  Next, we show that this grammar defines $\TR (S)\emptyset$.
  In particular, $\TR (S)\emptyset = L^\infty (\toCFG (S, N_0), N_0)$
  using the greatest fixpoint characterization of the
  $\infty$-language defined by a context-free grammar $G$ using
  nonterminal $N$ as the start symbol:
  \begin{align*}
    L^\omega (G, N) & = (\GFP\, \lambda Y. \lambda N. \RHS (N, Y)) (N) \\
    \RHS (N, Y) &= \bigcup
                          \begin{cases}
                            \{ \varepsilon \} & N \to \varepsilon \in G \\
                            \{ x \} & N \to x \in G\\
                            Y (N_1) \cdot Y (N_2) & N \to N_1N_2 \in G \\
                            \{ x \} \cdot Y (N') & N \to x N' \in G \\
                            Y (N') & N \to N' \in G
                          \end{cases}
  \end{align*}
  In this definition, $Y$ maps a nonterminal symbol to its associated
  $\omega$-language. The function $\RHS (N, Y)$ takes the union of the
  interpretations of all right-hand sides for $N$ (as
  $\omega$-languages) using $Y$ to interpret the nonterminal symbols.

  The proof of the language equality proceeds by induction on $S$.

  \textbf{Case }$\skipk$, $\alpha$, $!B$, $?B$. Immediate.

  \textbf{Case }$(S_1;S_2)$:
  \begin{align*}
    & \TR (S_1;S_2)\rho \\
    &= \TR (S_1)\rho \cdot \TR (S_2)\rho \\
    &= L^\omega (\toCFG (S_1, N_1), N_1) \cdot L^\omega( \toCFG (S_2, N_2), N_2) \\
    & = L^\omega (\{ N_0 \to N_1N_2\} \cup \toCFG (S_1, N_1) \cup \toCFG (S_2, N_2), N_0) \\
    & = L^\omega (\toCFG ((S_1; S_2), N_0), N_0)
  \end{align*}

  \textbf{Case }$\oplus\{l_i\colon S_i\}$:
  \begin{align*}
    & \TR (\oplus\{l_i\colon S_i\})\rho \\
    & =  {\cup} \{  {\oplus L_i} \cdot \TR (S_i)\rho \mid {i\in I} \} \\
    & =  {\cup} \{  {\oplus L_i} \cdot L^\omega (\toCFG(S_i, N_i), N_i) \} \\
    & =  L^\omega (\{ N_0 \to {\oplus L_i} N_i \mid i\in I \} \cup \toCFG (S_i, N_i), N_0) \\
    & = L^\omega (\toCFG (\oplus\{l_i\colon S_i\}, N_0))
  \end{align*}

  \textbf{Case }$\&\{l_i\colon S_i\}$: Analogously.

  \textbf{Case }$\mu x.S$:
  \begin{align*}
    & \TR (\mu x.S)\rho \\
    &= \GFP\, \lambda Y. \TR (S)\rho[x\mapsto Y] \\
    & \{ \text{ by a separate coinductive argument } \} \\
    &= L^\omega (\toCFG (S, N_x) , N_x)\\
    &= L^\omega (\{ N_0 \to N_x \} \cup \toCFG (S, N_x) , N_0)\\
    &= L^\omega (\toCFG (\mu x.S, N_0), N_0)
  \end{align*}
  The coinductive argument relies on the coinductive definition of $L^\omega$.
  To establish the needed inclusion in both directions, consistency must be proved with respect to
  the other monotone function.

  Finally, we embed $L \subseteq \Sigma^\infty$ in a proper $\omega$-language by choosing a new
  symbol $\BLANK \notin \Sigma$  and considering $\hat{L} = L \cdot \BLANK^\omega \subseteq
  (\Sigma\cup\{\BLANK\})^\omega$. To adjust the grammar generated from $S$ with start symbol $N_0$,
  we add two new symbols $N_0'$ and $N_\bot$ and two productions: $N_0' \to N_0N_\bot$ and $N_\bot
  \to \BLANK N_\bot$.
\end{proof}

We aim to show that equivalence of trace languages of session types is decidable.
Because $\TRw (S)$ is a deterministic context-free $\omega$-language, it can be recognized by
a deterministic $\omega$-pushdown automaton. While equivalence of standard deterministic
pushdown automata is known to be decidable \cite{DBLP:conf/icalp/Senizergues97}, decidability is only
known for equivalence of \emph{weak} $\omega$-deterministic pushdown automata \cite{DBLP:conf/mfcs/LodingR12}, but
not for the full class.
% Unfortunately, weak $\omega$-pushdown automata are not sufficient to recognize $\TR(S)\emptyset
% \cdot \BLANK^\omega$ as soon as $\TR (S)\emptyset$ contains infinite words.

To make this point precise, we recap the relevant definitions.
\begin{definition}
  $\MACHINE= (Q, \Sigma, \Gamma, \delta, q_0, \bot)$ is
  a \emph{deterministic pushdown automaton} (DPDA) if it consists of
  \begin{itemize}
  \item a finite set $Q$ of states and initial state $q_0\in Q$,
  \item a finite input alphabet $\Sigma$; we write $\Sigma_\varepsilon = \Sigma \cup\{\varepsilon\}$,
  \item a finite stack alphabet $\Gamma$ with initial stack symbol $\bot\notin\Gamma$; we write
    $\Gamma_\bot = \Gamma\cup\{\bot\}$,
  \item a transition function
    $\delta \in (Q \times \Gamma \times \Sigma_\varepsilon \to Q  \times \Gamma^*)
    \cup (Q \times \{\bot\} \times \Sigma_\varepsilon \to Q \times  \Gamma^*\bot)$, such that for each $q \in Q$ and
    $Z\in \Gamma_\bot$ either
    $\delta (q, Z, x)$ is defined for all $x \in\Sigma$ and $\delta (q, Z, \varepsilon)$ is
    undefined and vice versa.
  \end{itemize}
  A configuration of $\MACHINE$ is an element of $Q \times \Gamma^*\bot$ with initial
  configuration $(q_0,\bot)$. A \emph{run} of $\MACHINE$ on $w \in \Sigma^\omega$ is an infinite sequence
  of configurations $(q_i,\gamma_i)_{i\in\Nat}$ such that $\gamma_0 = \bot$, $w =
  \sigma_0\sigma_1 \dots$ where $\sigma_i \in \Sigma_\varepsilon$, 
  $\gamma_i = Z_i\gamma_i'$, $\gamma_{i+1} = g_i\cdot\gamma_i'$, and $\delta (q_i, Z_i, \sigma_i) =
  (q_{i+1}, g_i)$.

  A run is \emph{accepting}, if the parity of the highest priority of an infinitely occuring state
  is even, where priority is given by a map $\Omega : Q \to \Nat$. (Parity acceptance criterion.)

  A machine is \emph{weak}, if no transition decreases the priority: for each transition from $q$ to
  $q'$ it must be that $\Omega (q) \le \Omega (q')$.
\end{definition}

\begin{proposition}\label{prop:trace-is-weak-wpda}
  The language $\TRw (S)$ can be recognized by a weak $\omega$-DPDA.
\end{proposition}
\begin{proof}
  To construct an $\omega$-DPDA for this language, we consider the context-free grammar $G = \toCFG
  (S)$ with set of nonterminals $\mathcal{N}$ and start symbol $N_0 \in \mathcal{N}$ and transform
  it to a DPDA $(Q, \Sigma', \Gamma, \delta, q_0, \bot)$ as shown in Figure~\ref{fig:construction-of-dpda}. 
  \begin{figure}[t]
    \begin{align*}
      Q & = \{q_0, q_2, q_4 \} && \text{with priorities given by the indexes} \\
      \Sigma' & = \Sigma \cup \{ \BLANK \} &
      \Gamma & = \Sigma \cup \mathcal{N} \\
      \delta & \ni (q_0, \bot, \varepsilon, q_2, N_0\bot)  && \\
      \delta & \ni (q_2, N, \varepsilon, q_2, \varepsilon)  & N & \to \varepsilon\\
      \delta & \ni (q_2, N, A, q_2, \varepsilon)  & N & \to A \qquad A \in \{\alpha, !B, ?B \}\\
      \delta & \ni (q_2, N, \varepsilon, q_2, N_1N_2)  & N & \to N_1N_2\\
      \delta & \ni (q_2, N, \oplus L_i, q_2, N_i)  & N& \to \oplus L_iN_i\\
      \delta & \ni (q_2, N, \& L_i, q_2, N_i)  & N& \to \& L_iN_i\\
      \delta & \ni (q_2, N, \varepsilon, q_2, N_x)  & N& \to N_x\\
      \delta & \ni (q_2, \bot, \BLANK, q_4, \bot) \\
      \delta & \ni (q_4, \bot, \BLANK, q_4, \bot) 
    \end{align*}
    \caption{Construction of DPDA}
    \label{fig:construction-of-dpda}
  \end{figure}
In the definition  of $\delta$ the mapping on the left is part of delta if the production on the
right is a production of the grammar.

This automaton is weak by inspection of the transition function. It is standard to prove that it recognizes the same
$\omega$-language as the grammar.
\end{proof}

Here is an example for an automaton resulting from the construction from the preceding proposition. 
\begin{align*}
  S & = (l_1 : {?B}; S; !B) \oplus (l_2 : \skipk)
  \\
  \TR (S) \emptyset & = \{ (\oplus L_1.?B)^n.\oplus L_2.{!B}^n \mid n \in \Nat\} \cup (\oplus L_1; ?B)^\omega
\end{align*}
The grammar associated to $S$ has start symbol $S'$:
\begin{align*}
  S' & \to S\ S'' & S'' & \to \BLANK\ S'' \\
  S & \to {\oplus L_1} {?B} S {!B} \mid {\oplus L_2} 
\end{align*}
The pushdown automaton derived from the grammar looks as follows (with some simplifications to improve readability).
\begin{align*}
  Q &= \{ q_0, q_2, q_4 \}  \qquad \text{with priorities $0$, $2$, and $4$, respectively}\\
  \delta & \in Q \times \Gamma_\bot \times \Sigma_\varepsilon \to Q \times (\Gamma^* \cup \Gamma^*\bot) \\
  \delta & = \{
           \begin{array}[t]{l}
             (q_0, \bot, \varepsilon, q_2, S\bot) \\
             (q_2, S, {\oplus L_1}, q_2, {?B} S {!B}) \\
             (q_2, S, {\oplus L_2}, q_2, \varepsilon) \\
             (q_2, {?B}, {?B}, q_2, \varepsilon) \\
             (q_2, {!B}, {!B}, q_2, \varepsilon) \\
             (q_2, \bot, \BLANK, q_4, \bot) \\
             (q_4, \bot, \BLANK, q_4, \bot) \\
             \} \\
           \end{array}
\end{align*}
An infinite run of the automaton either remains in state $q_2$ accepting a word of the form $(\oplus L_1;
?B)^\omega$ or it steps up to $q_4$ accepting a word with paired up $?B$s and $!B$s
and remains there (by weakness). 
\begin{theorem}
  Equivalence of session types is decidable.
\end{theorem}
\begin{proof}
  $S_1 \TypeEquiv S_2$ iff $\TRw (S_1) = \TRw (S_2)$ iff $L^\omega (\toCFG (S_1,
  N_1), N_1) = L^\omega (\toCFG (S_2, N_2), N_2)$. By Proposition~\ref{prop:trace-is-weak-wpda},
  there are weak $\omega$-DPDAs that recognize the trace languages for $S_1$ and for
  $S_2$. Equivalence of weak $\omega$-DPDAs is known to be decidable~\cite{DBLP:conf/mfcs/LodingR12}.
\end{proof}


% Nevertheless, we abandon completeness and use a sound approximation to bisimulation equivalence
% $\TypeEquiv$ because its checking algorithm is simpler. 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
