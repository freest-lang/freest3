%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Context-Free Session Types in Action}
\label{sec:context-free-session}

To understand the requirements for the metatheory of
context-free session types, we first examine the type derivation of
\lstinline|sendTree| in Listing~\ref{listing:serializing}. Then we
turn to further examples that underline the expressiveness and the
usefulness of context-free session types.

\subsection{Sending Leaves}
\label{sec:sending-leaves}


To typecheck the first alternative of the \lstinline|sendTree|
function for sending leaves, we need to derive type \lstinline|alpha| for the code
fragment
\begin{lstlisting}
  select Leaf c
\end{lstlisting}
given that \lstinline{c : TreeChannel;alpha}. Anticipating the formal
definition in Section~\ref{sec:processes} (Figure~\ref{fig:typing}),
we sketch an informal typing rule for \lstinline|select|, which is
taken verbatim from GV~\cite{DBLP:journals/jfp/GayV10}:
\begin{equation}\label{eq:2}
    \frac{
      \vdash e : \oplus\{l_i\colon S_i\}_{i\in I}
      \quad
      j\in I
      % \quad
      % \cdot\vdash T_i :: \kinds^m
    }{
      \vdash \select {l_j} e \colon S_j
    }
\end{equation}
 The \lstinline|select|
operation expects a branch type $\oplus\{l_i\colon S_i\}$, but we are given the recursive
\lstinline|TreeChannel| type, which has to be unfolded first. Such
unfolding is to be expected in the 
presence of recursive types. As unfolding is not indicated in the term,
we require an \emph{equi-recursive treatment of recursion in types}~\cite{Pierce2002-tpl}.


After unfolding, we obtain
\begin{lstlisting}
  c : oplus{Leaf: skip,
        Node: !int;TreeChannel;TreeChannel};alpha
\end{lstlisting}
This type, a sequence of protocols, is still not in the form expected
by \lstinline|select|. Hence, we further
need to enrich type equivalence to enable us to \emph{commute the
continuation type \lstinline|alpha| inside the branches}.

After commutation, we obtain the typing
\begin{lstlisting}
  c : oplus{Leaf: skip;alpha,
        Node: !int;TreeChannel;TreeChannel;alpha}
\end{lstlisting}
which is finally in a form acceptable to \lstinline|select|. Applying
the typing rule~\eqref{eq:2} yields
\begin{lstlisting}
  select Leaf c : skip;alpha
\end{lstlisting}
At this point, we need to apply the \emph{monoid identity law} (which
also needs to be part of type equivalence) to obtain the desired
outcome.
\begin{lstlisting}
  select Leaf c : alpha
\end{lstlisting}


\subsection{Sending Nodes}
\label{sec:sending-nodes}

We turn to typechecking the second alternative of the
\lstinline|sendTree| function
\begin{lstlisting}
  let c1 = select Node c
      c2 = send x c1
      c3 = sendTree l c2
      c4 = sendTree r c3
  in  c4
\end{lstlisting}
given that 
\begin{lstlisting}
  x : int, l : Tree, r : Tree, c : TreeChannel
\end{lstlisting}

Typechecking the \lstinline|select| operation requires the same steps
as for leaves. We skip over those and note the resulting typing for
\lstinline|c1|.
\begin{lstlisting}
  c1 : !int;TreeChannel;TreeChannel;alpha
\end{lstlisting}
The \lstinline|send| operation just peels off the leading
\lstinline{!int} type, but our typing for \lstinline|c1| glosses over
an important detail, namely the bracketing of the $\scCompose\_\_$
operator. After commuting \lstinline|alpha| inside the branch type and
applying the \lstinline|select| rule, we are actually left with this
type:
\begin{lstlisting}
  c1 : (!int;(TreeChannel;TreeChannel));alpha
\end{lstlisting}
Again, we need to appeal to type equivalence to reassociate the
nesting of the sequence operator, that is, to apply the \emph{monoidal
associativity law}. The resulting type
\begin{lstlisting}
  c1 : !int;((TreeChannel;TreeChannel);alpha)
\end{lstlisting}
is compatible with the typing for \lstinline|send| and we can
proceed with
\begin{lstlisting}
  c2 : (TreeChannel;TreeChannel);alpha
\end{lstlisting}
Again, we need to reassociate:
\begin{lstlisting}
  c2 : TreeChannel;(TreeChannel;alpha)
\end{lstlisting}
At this point, we see the need for \emph{polymorphic recursion}: the
recursive call \lstinline|sendTree l c2| of
\begin{lstlisting}
sendTree : forallbeta.Tree -> TreeChannel;beta -> beta
\end{lstlisting}
must instantiate the type variable \lstinline|beta| to
\lstinline{(TreeChannel;alpha)}. With this instantiation, we obtain
\begin{lstlisting}
  c3 : TreeChannel;alpha
\end{lstlisting}
The second recursive call instantiates \lstinline|beta| to
\lstinline|alpha| (it could be treated monomorphically) and we readily
obtain the desired final outcome, which is equivalent to the outcome
of the first alternative:
\begin{lstlisting}
  c4 : alpha
\end{lstlisting}
In summary, the type system for context-free session types requires
polymorphism with polymorphic recursion.\footnote{This particular example can
be made to work without polymorphic recursion by abstracting the
recursive calls to \lstinline|transform| in a separate function with a
specialized type. However, we argue that it is advantageous to be able
to type the straightforward code that we present.} Furthermore, it relies on a
nontrivial notion of type equivalence that includes unfolding of
equi-recursive types, distributivity of branching over sequencing, and the
monoidal structure of \lstinline|skip| and sequencing (identity and
associativity laws). Our technical treatment of type equivalence in
Sections~\ref{sec:bisimulation} and~\ref{sec:decidability}
relies on a terminating unraveling operation that normalizes the
``head'' of a session type with respect to these notions. 

\subsection{Structure-Preserving Tree Transformation}
\label{sec:remote-tree-transf}

As another example for the expressiveness of context-free session
types, we present client and server code for a remote structure-preserving tree
transformation in Listing~\ref{listing:remote-tree-transformation}. It is based on the same tree datatype as before, but
it introduces a new channel type \lstinline|XformChan| that
receives the transformed node value after sending the old value and
the two subtrees. This code makes use of the \lstinline|receive|
operation that takes a channel of type \lstinline|!int;alpha| and
returns a linear pair of type \lstinline|intotimesalpha|. The pair
must be linear because channels in session-type calculi generally have
linear types to cater for the change of their type at each operation.
\lstinputlisting[float={t},captionpos={b},caption={Remote tree transformation},label={listing:remote-tree-transformation}]{tree.cfs}

The server function \lstinline|transform| demonstrates the use of
\lstinline|receive|. It also uses pattern matching to deconstruct the
linear pairs returned by recursive calls and by receiving integers. No
new issues arise in typing this function compared to
\lstinline|sendTree|. 

The function \lstinline|treeSum| is a suitable client for transformer
channels. It computes the accumulated sum at each tree node, so that
running \lstinline|transform| and
\lstinline|treeSum| concurrently results in a tree where each node value is
replaced by the sum of all node values below. The function
\lstinline|treeSum| takes an argument channel of type
\lstinline|dualof XformChan; alpha| where the \lstinline|dualof|
operator swaps sending and receiving types as usual. The
\lstinline|case| expression is the receiving counterpart of the
\lstinline|select| expression. It receives a label from a channel and
dispatches according to this label. Each branch of the
\lstinline|case| is a function that takes the respective continuation
of the channel and continues the interaction on that channel.

The final definition of \lstinline|go| stitches it all together. Using
\lstinline{new XformChan} it creates a new pair of channels, the types
of which are \lstinline{XFormChan} and its dual, it forks a new
process that runs \lstinline{treeSum} on the server channel, and
finally runs \lstinline{transform} on an example tree and the client channel.

The example also illustrates how channels are
closed. \lstinline|treeSum| (\lstinline|transform|) returns a
\emph{linear pair} of the accumulated sum (transformed tree) and a
depleted channel of type \lstinline|skip|. The function
\lstinline|fst| eliminates the linear pair and returns its first
component, which is possible because the second component is of an
unrestricted type (\lstinline|skip|). It implicitly closes the channel
by discarding it, as the channel end of type \lstinline|skip| can no longer be used for
interaction.

% which is possible because \lstinline|skip| is no
% longer restricted to be linear.

\subsection{Expression Server}
\label{sec:expression-server}

An example that is quite often used in the literature on session types
is an arithmetic server with a type like the one indicated in the
introduction:
\begin{displaymath}
  \sRecvChoice{
    \cgAlt{\mathit{add}}{\sRecv{\intk}\sRecv{\intk}\sSend{\intk}\End}
    ,
    \cgAlt{\mathit{neg}}{\sRecv{\intk}\sSend{\intk}\End}
  }
\end{displaymath}

\lstinputlisting[float={t},captionpos={b},caption={Arithmetic
  expression
  server},label={listing:arithmetic-expression-server}]{arithmetic-server.cfs}
 
Exploiting context-free session types, we can extend the scope of such
a server to receive and process arbitrary well-formed arithmetic
expressions. As an example consider the arithmetic expression server
for terms composed of constants, addition, and multiplication in
Listing~\ref {listing:arithmetic-expression-server}.
%
The implementation of the protocol is straightforward using the
techniques already described.

It is possible to extend this protocol to lazily traverse the term
(Listing~\ref{listing:lazy}). In this case, the server requests from
the client the parts of the term needed to complete the
evaluation. For instance, if a factor in a multiplication is zero, the
server can avoid to even ask for sending the other factor. We
elucidate this idea with a simplified protocol to explore a binary
tree lazily. No new features are required for its realization.

\lstinputlisting[deletekeywords={Left,Right},float={t},captionpos={b},caption={Lazy
tree traversal},label={listing:lazy}]{exploration.cfs}

A client connecting to the server \lstinline|exploreTree| first
connects to the root node of a tree. First it must check whether the
current node is a \lstinline|Leaf| or a \lstinline|Node|. If it is a
\lstinline|Node|, it can further explore the contents: it can ask for
the value or traverse the left subtree or the right subtree as often
as desired. Finally the client sends \lstinline|Exit| to return to the
parent node. 

The type describing this interaction is mutually recursive. The
``inner loop'' described by \lstinline|XploreNodeChan| is
tail-recursive like a regular session type, but the ``outer loop''
corresponding to \lstinline|XploreTreeChan| is not as its invocations
are intertwined with the inner loop.

% Now with a datatype to simplify the client's life.

% \lstinputlisting{arithmetic-server-data.cfs}


% Let's try a SePi-like version. All we need are context-free session
% types and type schemas\footnote{Predicative Polymorphism in
%   pi-Calculus. Vasco Thudichum Vasconcelos. In 6th Parallel
%   Architectures and Languages Europe, volume 817 of LNCS, pages
%   425--437. Springer, 1994.}. We witness the extra ``plumbing''
% typical of the pi-calculus, but otherwise very little (type only, in
% fact) extra basic notions.

% \lstinputlisting{arithmetic-server-sepi.cfs}


% The code for deserialization is analogous to the one for serialization and it can also be typed with
% the type structure explained in the introduction.
% \begin{alltt}
% recvT : Channel -> Tree \(\otimes\) Channel
% recvT c =
%   case c of
%   | Leaf : lambda c0.
%       let (n, c1) = receive (c0) in
%       (Leaf n, c1)
%   | Node : lambda c0.
%       let (r, c1) = recvT c0 in
%       let (l, c2) = recvT c1 in
%       (Node (l, r), c2)
% \end{alltt}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
