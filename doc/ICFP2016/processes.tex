\section{Processes, Statics, and Dynamics}
\label{sec:processes}

This section introduces our programming language, its static and
dynamic semantics. It shows that typing is preserved by reduction and
concludes by showing that our type system is a conservative extension
of that of a conventional functional session type language.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expressions and Processes}

\input{fig-processes}
 
Fix a base set of \emph{term variables}, disjoint from those
introduced before. Let $a,b$ range over this set.
%
The syntax of values, expressions, and processes is described in
Figure~\ref{fig:processes}.

\emph{Expressions}, denoted by metavariable $e$, incorporate a
\emph{standard functional core} composed of term variables~$a$,
abstraction introduction $\lambda a.e$ and elimination $ee$, pair
introduction $(e,e)$ and elimination $\letin{a,b} e e$, datatype
introduction $\inject le$ and elimination
$\match e {l_i\rightarrow e_i}_{i\in I}$, as well as a fixed point
construction $\fixk\,e$.
%
Further expressions support the usual \emph{session operators}, in the
form of channel creation $\newk$, message sending $\sendk$ and
receiving $\recvk$, internal choice (or label selection) $\select le$,
and external choice (or branching)
$\case e{\{l_i\rightarrow e_i\}_{i\in I}}$.
%
Concurrency arises from a $\forkk$ operator, spawning
a new process.
%
% In expressions $\match e {l_i\rightarrow e_i}_{i\in I}$ and
% $\casek\,e\,\ofk\,\{l_i\rightarrow e_i\}_{i\in I}$ $I$ is an index set.

\emph{Processes}, denoted by metavariable $p$, are expressions~$e$,
the parallel composition of two processes~$p\PAR q$, and the scope
restriction~$(\nu a,b)p$ of a channel described by its two end
points,~$a$ and~$b$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Operational Semantics}
\label{sec:semantics}

% Bindings, free vars, substitution

The \emph{binding} occurrences for term variables~$a$ and~$b$ are
expressions $\lambda a.e$, $\fixk\,a.e$, and $\letin{a,b}{e_1}{e_2}$.
%, and $\case e{\{l_i\rightarrow e_i\}_{i\in I}}$.
The sets of free and bound
term variables are defined accordingly, and so is the
\emph{capture avoiding substitution} of a variable~$a$ by a value~$v$ in a term~$e$,
denoted by $e\subs va$.

The operational semantics makes use of a \emph{structural congruence}
relation on processes, $\equiv$, defined as the smallest congruence
relation that includes the commutative monoidal rules---binary
operator $\_\PAR\_$ and any value for neutral---and scope extrusion:
%
\begin{equation*}
  (\nu a,b)p \PAR q \equiv (\nu a,b)(p\PAR q) \quad\text{if $a,b$ not free
    in $q$}
\end{equation*}

% op semantics

The operational semantics is call-by-value: expressions are reduced to
values before being ``applied''. The syntax of values is in
Figure~\ref{fig:processes}, and includes the values $\sendk$,
$\recvk$, unit, lambda abstraction, pair of values, and injection of a
value in a sum type. The semantics combines a standard reduction
relation for the functional part with an also standard message passing
semantics of the $\pi$-calculus.
%
The rules are in Figure~\ref{fig:reduction}.

\input{fig-reduction}

The first four axioms are standard in functional call-by-value languages,
and comprise $\beta$-reduction, (linear) pair elimination, data type
elimination, and fixed-point unrolling.
%
The first rule in the figure allows reduction to happen underneath
(functional) evaluation contexts $E$ as defined by the grammar
below.
%
\begin{align*}
  E \grmeq& [] \grmor (E,e) \grmor (v,E) \grmor Ee \grmor vE \grmor \letin{a,b}Ee
  % \letin aEe \grmor
  \\
  \grmor& \casek\,E\,\ofk\,\{l_i\rightarrow e_i\} \grmor \selectk\,l\,E
  \\
  \grmor& \match{E}{l_i\rightarrow e_i} \grmor \ink\,l\,E
\end{align*}

The $\forkk$ operator creates new threads: the expression $\fork{e}$
evaluates to $()$, the unit value, while creating a new thread to run
expression~$e$ concurrently.

The next three axioms in the figure deal with session operations. The
$\newk$ operator creates a new channel. Channels are denoted by their
two end points,~$a$ and $b$ in this case. We require that context~$E$
does not bind variables $a,b$, so that these are bound by the
outermost channel binding, $(\nu a,b)$.

The $\sendk$-$\recvk$ rule captures message passing: the sending
process writes value~$v$ in channel end point~$a$ whereas the
receiving process reads it from channel end point~$b$. That the pair
$a$-$b$ forms the two end points of a channel is captured by the
outermost $(\nu a,b)$ binding. The result of sending a value on channel
end~$a$ is~$a$ itself; that of receiving on~$b$ is the pair
$(v,b)$. In this way both threads are able to use their channel ends
for further interaction. This ``rebinding'' of channel ends provide
for a standard treatment of~$a$ and~$b$ as linear values. It is also
the type system that makes sure that, in a given process, there is
exactly one thread holding a copy of a given channel end, thus
allowing a simplified reduction rule where one finds exactly two
threads underneath channel binder $(\nu a,b)$.

The rule for $\selectk$-$\casek$ is similar in spirit. One thread
selects an $l$-labelled option on a channel end, whereas another offers
a choice on the other channel end. After successful interaction, the
selecting thread is left with its channel end, $a$, whereas the
choice-offering thread is left with an application of the
branch that was selected, $e_j$, to its channel end, $b$.

The remaining three rules are standard in the $\pi$-calculus. The
first two allow reduction underneath parallel composition and scope
restriction; the last incorporates structural congruence in the
reduction relation.

% Example of reduction

As an example consider an expression that creates a new channel, forks
a thread that writes an integer on the channel and reads back its
successor. The original thread, in turn, waits for an integer value
and writes back its successor. We depict the reduction below, where we
make use of the conventional semicolon operator $e_1;e_2$ defined as
$(\lambda a.e_2)e_1$, where $a$ is a variable not occurring free
in~$e_2$. We also write $\letin{a}{e_1}{e_2}$ for $(\lambda a.e_2)e_1$.
%
\begin{gather*}
  \letk\, a,b = \newk\,\ink\,
    \forkk\,(\letin{c}{\send 5a}{\recv c});\qquad \qquad \qquad
    \\\qquad \qquad \qquad \qquad \qquad
    \letin{n,d}{\recv b}{\send{(n+1)}{d}}
  \rightarrow
  \\
  (\nu e,f)\letin{a,b}{(e,f)}{\dots} \rightarrow
  \\
  (\nu e,f) \forkk\,(\letin{c}{\send 5e}{\dots});
    \letin{n,d}{\recv f}{\dots} \rightarrow \rightarrow
  \\
  (\nu e,f) (\letin{c}{\send 5e}{\dots} \PAR \letin{n,d}{\recv f}{\dots})
  \rightarrow
  \\
  (\nu e,f) (\letin{c}{e}{\dots} \PAR \letin{n,d}{(5,f)}{\dots})
  \rightarrow \rightarrow 
  \\
  (\nu e,f) (\recv e \PAR \send{(5+1)}{f})
  \rightarrow
  \\
  (\nu e,f)((e,6) \PAR f)
\end{gather*}

% RUNTIME ERRORS

We complete this section by discussing the notion of \emph{run-time
  errors}. The \emph{subject} of an expression~$e$, denoted by
$\subj(e)$, is~$a$ in the following cases and undefined in all other
cases.
%
\begin{equation*}
  \send ea \qquad
  \recv a \qquad
  \select ea \qquad
  \case ae
\end{equation*}

We say that two expressions~$e_1$ and $e_2$ \emph{agree} on channel
$ab$, denoted $\agree^{ab}( e_1,e_2)$, in the following four cases.
%
\begin{itemize}
\item $\agree^{ab}(\send ea, \recv b)$;
\item $\agree^{ab}(\recv a,\send be)$;
\item $\agree^{ab}(\select{l_j}{a}, \case b{l_i\rightarrow e_i}_{i\in
    I})$ and $j\in I$;
\item $\agree^{ab}(\case a{l_i\rightarrow e_i}_{i\in
    I}, \select{l_j}{b})$ and $j\in I$.
\end{itemize}

A closed process is an \emph{error} if it is structurally congruent to
some process that contains a subexpression or subprocess of one of the
following forms.
%
\begin{enumerate}
\item $\letin{a,b}{v}{e}$ and $v$ is not a pair;
\item $\match{v}{l_i\rightarrow e_i}_{i\in I}$ and
  $v\ne(\ink\,l_j\,v')$ for some $v'$ and some $j\in I$;
\item $E_1[e_1] \PAR E_2[e_2]$ and $\subj(e_1) = \subj(e_2) = a$, where
  neither $E_1$ nor $E_2$ bind~$a$;
\item $(\new a,b)(E_1[e_1] \PAR E_2[e_2] \PAR p)$ and $\subj(e_1)=a$
  and $\subj(e_2)=b$ and $\neg\agree^{ab}(e_1,e_2)$, where $E_1$ does not
  bind~$a$ and $E_2$ does not bind~$b$.
% \item $  (\new a,b)(E_1[\selectk\,l_j\,a] \PAR
%   E_2[\casek\,b\,\ofk\,\{l_i\rightarrow e_i\}_{i\in I}] \PAR p) $
%   where $E_1$ does not bind $a$ and $E_2$ does not bind $b$ and
%   $j\notin I$ (or the same with $a$ and $b$ exchanged).
\end{enumerate}

The first two cases are typical of functional languages with pairs and
datatypes.
%
The third case guarantees that no two threads hold references to the
same channel end (the fact that the process is closed and that the
contexts do not bind variable~$a$ ensure that~$a$ is a channel end).
%
The fourth case says that channel ends agree at all times: if one
thread is ready for sending, then the other is ready for receiving,
and similarly for selection and branching.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Type Assignment System}

% DUALITY

\emph{Duality} is a central notion in session types. It allows to
``switch'' the point of view from one end of a channel (say, the
client side) to the other (the server side).
%
The duality function on session types, $\dual S$, is defined as
follows.
%
\begin{gather*}
  \dual\alpha = \alpha 
  \qquad
  \dual\skipk = \skipk
  \qquad
  \dual{!B} = \;?B
  \qquad
  \dual{?B} = \;!B
  \\
  \dual{\&\{l_i\colon S_i\}} = \oplus\{l_i\colon \dual{S_i}\}
  \qquad
  \dual{\oplus\{l_i\colon S_i\}} = \&\{l_i\colon \dual{S_i}\}
  \\
  \dual{S_1;S_2} = \dual{S_1};\dual{S_2}
  \qquad
  \dual{\mu x.S} = \mu x.\dual S
  \qquad
  \dual x = x
\end{gather*}
%
This simple definition is justified by the fact that the types we
consider are first order, thus avoiding a complication known to arise
in the presence of
recursion~\cite{bernardi.hennessy:using-contracts-model-session-types}.

To check whether $S_1$ is dual to $S_2$ we compute $S_3 = \dual{S_1}$
and check $S_2$ and $S_3$ for equivalence.
%
Duality is clearly an involution ($\dual{\dual S} = S$), hence we can
alternatively compute $\dual{S_2}$ and check that $S_1$ is equivalent
to $\dual{S_2}$.
%
For example, to check that $!B;\mu x.(\skipk;!B;x)$ is dual to
$\mu y.(?B;y)$, we compute $\dual{\mu y.(?B;y)}$ to obtain
$\mu y.(!B;y)$, and check that this type is equivalent to
$!B;\mu x.(\skipk;!B;x)$.

We can easily show that duality preserves kinding.

\begin{lemma}
  \label{lem:duality-preserves-kinding}
  If $\Delta \vdash S :: \kind$, then $\Delta \vdash \dual S :: \kind$.
\end{lemma}
%
\begin{proof}
  By rule induction on the premise.
\end{proof}

% TYPING CONTEXT

\input{fig-wellformed-contexts}

Typing contexts are generated by the following grammar.
%
\begin{equation*}
  \Gamma \grmeq \cdot \grmor \Gamma,a\colon T
\end{equation*}
%
As before we consider contexts up to reordering of their entries.
%
% The UN PREDs
%
The $\un_\Delta$ predicate, on types~$T$ defined on $\Delta$, is an
abbreviation of $\Delta \vdash T :: \prekind^\Unrestricted$. The $\un_\Delta$
predicate is also true of contexts of the form
$x_1\colon T_1,\dots, x_n\colon T_n$ if it is true of all
types~$T_1,\dots,T_n$. We often omit the $\Delta$ in $\un_\Delta$ when
it is clear from the context.

% CONTEXT FORMATION
We expect all types in typing contexts to be well formed, a notion
captured by judgement $\Delta \vdash \Gamma$ whose rules can be found
in Figure~\ref{fig:contexts}.

% CONTEXT SPLITTING
Linear variables must be split between the different subterms to
ensure that each variable is used once. Figure~\ref{fig:contexts}
defines a relation $\Delta \vdash \Gamma = \Gamma_1 \circ \Gamma_2$,
which describes how to split a context $\Gamma$ into two contexts
$\Gamma_1$ and $\Gamma_2$ that will be used in different subterms in
rule premisses~\cite{walker:substructural-type-systems}.

%
% However, unlike conventional contexts ($\Delta$ for example), we
% allow duplicated variables in contexts, but subject to two
% restrictions: if both $a\colon T$ and $a\colon U$ are in $\Gamma$
% then: i) $T=U$ and ii) $\Delta \vdash T :: \kindt^\Unrestricted$.


% TYPING

\input{fig-typing}

Figure~\ref{fig:typing} contains the typing rules for expressions and for
processes. Judgments for expressions and processes take the usual forms of
$\Delta;\Gamma \vdash e: T$ and 
$\Delta;\Gamma \vdash p$. We describe the rules briefly.

% description of the rules

The first group of rules deals with the functional part of
the language. The rule for the unit value requires a context
free from term variables. If needed, unrestricted term variables are
introduced by an explicit weakening rule. The typing rule for variables
reads the type of the variable from the context. We require that
the term context contains no other entry, and that the type is
well-formed against~$\Delta$, ensuring that types introduced in a
derivation are well-formed. The rule for the fixed point is standard.

The type system comprises rules for the introduction and the
elimination of unrestricted ($\rightarrow$) and linear ($\multimap$)
functions.
%
The elimination rules are standard. In the introduction of linear
functions the term context is split in two parts, one to type the
function~$e_1$, the other to type the argument~$e_2$.
%
% The next rule in the same line allows unrestricted functions to be
% converted into linear functions, so that the rule for function
% elimination may apply.

The next four rules are all standard and provide for the
introduction and the elimination of pairs ($T_1\otimes T_2$) and
variants ($[l_i\colon T_i]$).
%
The rules for the introduction and elimination of type abstraction are
also conventional; the extra premises on kindings are meant to ensure
that types introduced in derivations are well-formed.

We now come to the channel communication rules. The rule for channel
creation introduces a pair of dual session types, one for each end
point. The $\sendk$ operator is a function that expects a value to be
sent~$B$, then a channel on which to send the value~$!B;T$, and
returns the rest of the channel~$T$. The $\recvk$ operator expects a
channel from which a value can be read $?B;T$ and returns a pair
composed of the value and the rest of the channel, $B\otimes T$. The
premises ensure that~$T$ is a session type.
%
The rule for label selection requires that expression~$e$ denotes a
channel offering an internal choice, $\oplus\{l_i\colon
T_i\}$.
Expression $\select {l_j} e$ evaluates to the rest of the channel,
hence its type is~$T_j$.
%
A $\casek$ expression expects a channel offering an external choice,
$\&\{l_i\colon T_i\}$. The expression in each branch must be function
expecting the rest of the channel~$T_i$. All such functions must
produce a value of a common type~$T$, which becomes the type of the
$\casek$ expression.

The rule for $\forkk$ requires the expression to be of an unrestricted
type, for the value the expression evaluates to will never be
consumed.

The last three rules are structural. The first two ---weakening and
copy (or contraction)---manipulate the term context. In both cases
we require the type to be unrestricted. The last rule incorporates
type equivalence in the typing relation.

The rules for processes should be easy to understand. An expression,
when seen as a process must be of an unrestricted type. This implies
that linear resources, channels in particular, are fully consumed. The
rule for parallel composition splits the context in two, using one
part for each process. Finally, the rule for channel creation
introduces two entries in the context, of types dual to each other,
one for each end of the channel.

We complete this section with a result that relates the type system to
the kinding system.

\begin{lemma}[Agreement]
  If $\Delta;a_1\colon T_1,\dots,a_n\colon T_n \vdash e : T_0$, then,
  for all $0\le i\le n$, there are kinds $\kind_i$ such that
  $\Delta \vdash T_i:: \kind_i$.
\end{lemma}
%
\begin{proof}
  By rule induction on the premise using the various kinding
  preservation lemmas (\ref{lem:subs-preserves-kinding},
  \ref{lem:equiv-preserves-kinding}, and
  \ref{lem:duality-preserves-kinding}).
\end{proof}

% The usual derived rules.
% %
% \begin{gather*}
%   \frac{
%     \Gamma_1 \vdash e_1:T_1
%     \quad
%     \Gamma_2,x:T_1 \vdash e_2:T_2
%   }{
%     \Gamma_1,\Gamma_2 \vdash \letin x {e_1}{e_2} : T_2
%   }
% \\
%   \frac{
%     \Gamma_1 \vdash e_1:T_1
%     \quad
%     \Gamma_2 \vdash e_2:T_2
%     \quad
%     \un(T_1)
%   }{
%     \Gamma_1,\Gamma_2  \vdash e_1;e_2 : T_2
%   }
% \end{gather*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Soundness and Type Safety}

The proofs for the two results of this section follow a conventional
approach: we first establish lemmas for strengthening, weakening,
% (weakening is built into the type system) -- Not anymore
substitution, sub-derivation manipulation, and inversion of the typing
relation. Soundness (Theorem~\ref{thm:soundness}) follows by rule
induction on the reduction step, and type safety
(Theorem~\ref{thm:safety}) follow by an analysis of the typing
derivation.

\begin{lemma}[Strengthening]
  \label{lem:strengthening}
  If $\Delta;\Gamma,a\colon T \vdash p$ and~$a$ not free in~$p$, then
  $\Delta;\Gamma \vdash p$ and~$\un_\Delta(T)$.
\end{lemma}
%
\begin{proof}
  By rule induction on the first premise.
\end{proof}

\begin{lemma}[Weakening]
  \label{lem:weakening}
  If $\Delta;\Gamma \vdash p$ and $\Delta \vdash T::\prekind^\Unrestricted$, then
  $\Delta;\Gamma, a\colon T \vdash p$.
\end{lemma}
%
\begin{proof}
  By rule induction on the first premise.
\end{proof}

\begin{lemma}[Congruence]
  \label{lem:congruence}
  If $\Delta;\Gamma \vdash p$ and $p\equiv q$, then
  $\Delta;\Gamma \vdash q$.
\end{lemma}
%
\begin{proof}
  By rule induction on the first premise, using strengthening
  (Lemma~\ref{lem:strengthening}).
\end{proof}

\begin{lemma}[Substitution]
  \label{lem:subs}
  If $\Delta;\Gamma_1, a\colon T_2 \vdash e_1 : T_1$ and
  $\Delta;\Gamma_2 \vdash e_2 : T_2$, then
  $\Delta;\Gamma_1,\Gamma_2 \vdash e_1 \subs{e_2}{a} : T_1$.
\end{lemma}
%
\begin{proof}
  By rule induction on the first premise.
\end{proof}

The following two lemmas are adapted from~\cite{DBLP:journals/jfp/GayV10}.

\begin{lemma}[Sub-derivation introduction]
  \label{lem:derivation-intro}
  If $\mathcal D$ is a derivation of $\Delta;\Gamma \vdash E[e] : T$,
  then there exist $\Gamma_1$, $\Gamma_2$ and $U$ such that
  $\Gamma = \Gamma_1,\Gamma_2$ and $\mathcal D$ has a sub-derivation
  $\mathcal D'$ concluding $\Delta;\Gamma_2 \vdash e : U$ and the
  position of $\mathcal D'$ in $\mathcal D$ corresponds to the
  position of the hole in $E$.
\end{lemma}

\begin{lemma}[Sub-derivation  elimination]
  \label{lem:derivation-elim}
  If
  \begin{itemize}
  \item $\mathcal D$ is a derivation of
    $\Delta;\Gamma_1,\Gamma_2 \vdash E[e] : T$,
  \item $\mathcal D'$ is a sub-derivation of $\mathcal D$
    concluding $\Delta;\Gamma_2 \vdash e : U$,
  \item the position of $\mathcal D'$ in $\mathcal D$ corresponds
    to the position of the hole in $E$,
  \item $\Delta;\Gamma_3 \vdash e_2 : U$,
  \item $\Gamma_1,\Gamma_3$ is defined,
  \end{itemize}
then
  $\Delta;\Gamma_1,\Gamma_3 \vdash E[e_2] : T$.
\end{lemma}

% No more combined rule
% The structural rules (weakening, copy, and $\TypeEquiv$) commute.  We
% can easily show that these three rules can be replaced by a single
% combined rule as follows.
% %
% \begin{equation*}
%   \frac{
%     \Delta;\Gamma_1, \Gamma_2, \Gamma_2 \vdash e : T_1
%     \quad
%     \un_\Delta(\Gamma_2,\Gamma_3)
%     \quad
%     \Delta \vdash T_1 \TypeEquiv T_2
%   }{
%     \Delta;\Gamma_1, \Gamma_2, \Gamma_3 \vdash e : T_2
%   }
% \end{equation*}
% %
% Notice that if we replace, in the weakening rule, the proviso
% $a\notin\Gamma$ by
% $a:U\in\Gamma \Rightarrow \Delta \vdash U\TypeEquiv T$, then copy and
% weakening do not commute anymore.  This combined rule forms the basis
% for the inversion lemma below.

\begin{lemma}[Inversion of the expression typing relation]\
  \label{lem:inversion}

% Cases ordered as required for soundness, which in turn are ordered
% by the reduction rules.

  \begin{itemize}
  \item % app
    If $\Delta;\Gamma \vdash e_1e_2 : T$, then
    $\Gamma = \Gamma_1 \circ \Gamma_2$ with 
    $\Delta;\Gamma_2 \vdash e_2: T_1$ and
    $\Delta \vdash T_2 \TypeEquiv T$ and either
    \begin{itemize}
    \item $\Delta;\Gamma_1 \vdash e_1: T_1 \multimap T_2$; or 
    \item $\Delta;\Gamma_1 \vdash e_1: T_1 \rightarrow T_2$.
    \end{itemize}
  \item % lambda
    If $\Delta;\Gamma \vdash \lambda a.e : T$, then
    $\Delta;\Gamma, a:T_1 \vdash e: T_2$ and
    $\Delta \vdash T_1, T_2 ::\kindt^\Linear$
    either
    \begin{itemize}
    \item $\un_\Delta (\Gamma_1)$ and $\Delta \vdash T_1 \to T_2
      \TypeEquiv T$; or
    \item  $\Delta \vdash T_1 \multimap T_2      \TypeEquiv T$.
    \end{itemize}
  \item % let/2
    If $\Delta;\Gamma \vdash \letin{a,b}{e_1}{e_2} : T$, then
    $\Gamma = \Gamma_1 \circ \Gamma_2$ and
    $\Delta;\Gamma_1 \vdash e_1: T_1 \otimes T_2$ and
    $\Delta \vdash T \TypeEquiv U$ and
    $\Delta;\Gamma_2 ,a\colon T_1,b\colon T_2 \vdash e_2: U$.
  \item % (e1,e2)
    If $\Delta;\Gamma \vdash (e_1, e_2) : T$, then
    $\Gamma = \Gamma_1\circ \Gamma_2$ with 
    $\Delta;\Gamma_1 \vdash e_1: T_1$ and
    $\Delta;\Gamma_2 \vdash e_2: T_2$ and
    $\Delta \vdash T_1, T_2 ::\kindt^\Linear$ and
    $\Delta \vdash T_1\otimes T_2 \TypeEquiv T$.
  \item % match
    If $\Delta;\Gamma \vdash \match{e}{l_i\rightarrow e_i}_{i\in
      I} : T$, then
    $\Gamma =  \Gamma_1 \circ \Gamma_2$ with
    $\Delta; \Gamma_1 \vdash e : [l_i : T_i]$ and
    $\Delta; \Gamma_2 \vdash e_i : U$ and
    $\Delta \vdash U \TypeEquiv T$.
  \item % in
    If $\Delta;\Gamma \vdash \ink\,l_j\,e : T$, then
    $\Delta;\Gamma \vdash e: T_j$ and
    $\Delta \vdash [l_i:T_i]_{i\in I} \TypeEquiv T$ and
    $j\in I$ and
    $\Delta\vdash T_i::\kindt^m$, for all $i\in I$.
  \item % fix
    If $\Delta;\Gamma \vdash \fix ae : T$, then
    $\un_\Delta(\Gamma)$ and
    $\vec\alpha\notin\Delta$ and
    $\Delta, \vec\alpha::\vec\kind;\Gamma,
    a:\forall\vec\alpha::\vec\kind. U \vdash e: U$ and
    $\Delta \vdash \forall\vec\alpha::\vec\kind. U \TypeEquiv T$.
  \item % let
    If $\Delta;\Gamma \vdash \letin{a}{e_1}{e_2} : T$, then
    $\Gamma = \Gamma_1 \circ \Gamma_2$ and
    $\vec\alpha\notin\Delta$ and
    $\Delta, \vec\alpha::\vec\kind; \Gamma_1 \vdash e_1 : T_1$ and
    $\Delta;\Gamma_2,
    a:\forall\vec\alpha::\vec\kind. T_1 \vdash e_2: T_2$ and
    $\Delta \vdash \forall\vec\alpha::\vec\kind. T_2 \TypeEquiv T$.
  \item % fork
    If $\Delta;\Gamma \vdash \fork\,e:T$, then
    $\un_\Delta(U,\Gamma)$ and
    $\Delta;\Gamma \vdash e : U$ and
    $T = \unitk$.
  \item % new
    If $\Delta;\Gamma \vdash \newk : T$,
    then $\un_\Delta(\Gamma)$ and
    $\Delta \vdash T \TypeEquiv S\otimes\dual S$ and
    $\Delta \vdash T::\kinds^m$.
  \item % send
    If $\Delta;\Gamma \vdash \sendk\, e\, a : T$, then
    $\Delta \vdash T \TypeEquiv S$ and
    $\Gamma = \Gamma_1, a\colon T_2$ and
    $\Delta \vdash T_2 \TypeEquiv \;!B;S$ and
    $\Delta;\Gamma_1 \vdash e \colon B$.
  \item % receive
    If $\Delta;\Gamma \vdash \recvk\, a : T$, then
    $\Delta \vdash T \TypeEquiv B \otimes S$ and 
    $\Gamma = \Gamma_1, a\colon T_2$ and
    $\un_\Delta(\Gamma_1)$ and
    $\Delta \vdash T_2 \TypeEquiv \;?B;S$.
  \item % select
    If $\Delta;\Gamma \vdash \select{l_j} a : T$, then
    $\Delta \vdash T \TypeEquiv S_j$ and
    $\Gamma = \Gamma_1, a\colon T_2$ and
    $\un_\Delta(\Gamma_1)$ and $\Delta \vdash T_2 \TypeEquiv
    \oplus \{ l_i\colon S_i \}_{i\in I}$ and $j\in I$.
  \item % case
    If $\Delta;\Gamma \vdash \casek\,b\,\ofk\,\{l_i\rightarrow
    e_i\}_{i\in I} : T$, then
    $\Gamma =  \Gamma_1, b\colon T_2$ and  
    $\Delta \vdash T_2 \TypeEquiv  \& \{ l_i\colon S_i \}$ and
    (for all $i\in I$)
    $\Delta; \Gamma_1 \vdash e_i : S_i \tcLolli T'$ and
    $\Delta \vdash T' \TypeEquiv T$.
  % \item %par
  %   If $\Delta;\Gamma \vdash p \PAR q$, then
  %   $\Gamma = \Gamma_1, \Gamma_2, \Gamma_3, \Gamma_4$ and
  %   $\un_\Delta (\Gamma_3,\Gamma_4)$ and
  %   $\Delta; \Gamma_1, \Gamma_3 \vdash p$ and
  %   $\Delta; \Gamma_2, \Gamma_3 \vdash q$.
  % \item %new
  %   If $\Delta;\Gamma \vdash (\new a,b) p$, then there exists $T$
  %   such that $\Delta; \Gamma, a:T, b:\dual{T} \vdash p$.
  % \item If $\Delta;\Gamma \vdash p$ , then there exists $q$ such that
  %   $p \equiv q$ and $\Delta;\Gamma \vdash q$.
  \end{itemize}
\end{lemma}
%
\begin{proof}
  For each case we consider the derivation ending with the
  corresponding structural rule followed by the combined rule, and
  collect all undischarged assumptions.
\end{proof}

Inversion of the typing relation for processes is obtained by simply
reading the rules for processes bottom-up, since all rules are
syntax-directed.

\begin{theorem}[Soundness]
  \label{thm:soundness}~\\
  If $\Delta;\Gamma \vdash p$ and $p \rightarrow q$, then
  $\Delta;\Gamma \vdash q$.
\end{theorem}
%
\begin{proof}
  By rule induction on the second premise, using the congruence and
  the substitution lemmas, sub-derivation introduction and
  elimination, and inversion
  (Lemmas~\ref{lem:congruence}--\ref{lem:inversion}).

  % Cases by the order the reduction rules appear in the definition
  % (figure X).

  \textbf{Case} the derivation ends with $\beta$: inversion (for
  expressions as processes, application, and abstraction),
  substitution lemma, rule for expressions as processes.

  \textbf{Case} the derivation ends with $\letk$: inversion (for
  expressions as processes, $\letk$, and pairs), substitution lemma
  (twice), weakening and copy rules, rule for expressions as
  processes.

  \textbf{Case} the derivation ends with $\matchk$: inversion (for
  expressions as processes, $\matchk$, and $\ink$), rules for
  application and expressions as processes.

  \textbf{Case} the derivation ends with $\fixk$: inversion (for
  expressions as processes and $\fixk$), substitution lemma, 
  contraction and rule for expressions as processes.

  \textbf{Case} the derivation ends with context: inversion for
  expressions as processes, sub-derivation intro, induction,
  sub-derivation elim, and rule for expressions as processes.

  \textbf{Case} the derivation ends with $\forkk$: inversion for
  expressions as processes, sub-derivation intro, inversion for
  $\forkk$, rule $()$, sub-derivation elimination, combined rule,
  rules for expressions as processes and parallel composition.

  \textbf{Case} the derivation ends with $\newk$: inversion for
  expressions as processes, sub-derivation intro, inversion for
  $\newk$, var axiom, $\otimes$ intro, sub-derivation elimination,
  typing rules for expressions as processes and $\nu$.

  \textbf{Case} the derivation ends with the reduction rule for
  communication: inversion ($\nu$, parallel composition, and
  expressions as processes twice), sub-derivation intro (twice),
  inversion ($\sendk$, $\recvk$), typing rules for variables and
  $\TypeEquiv$, sub-derivation elim (twice), typing rules for
  expressions as processes (twice) and parallel composition and
  weakening and copy, definition of $\dual S$, and typing rule $\nu$.

  \textbf{Case} the derivation ends with the rule for branching:
  similar to the above, but simpler.

  \textbf{Case} the derivation ends with par: inversion for parallel
  composition, induction, typing rule for parallel composition.

  \textbf{Case} the derivation ends with reduction under $\nu$:
  inversion for $\nu$, induction, typing rule for $\nu$.

  \textbf{Case} the derivation ends with $\equiv$: congruence lemma,
  induction.
\end{proof}

% \vv{In the proof above, we could spell out the details of one case
%   (there is some space left)}

We conclude this section with the results on type safety and progress
for the functional sub-language.

\begin{theorem}[Type safety]
  \label{thm:safety}
  If $\Delta;\Gamma \vdash p$, then $p$ is not an error.
\end{theorem}
%
\begin{proof}
  A simple analysis of the typing derivation for the premise. We
  analyse one of the five cases in the definition of error in
  Section~\ref{sec:semantics}, namely $(\new a,b)(E_1[e_1] \PAR
  E_2[e_2] \PAR p)$,
  where $\subj(e_1)=a$ and $\subj(e_2)=b$ and $E_1$ does not bind~$a$
  and $E_2$ does not bind~$b$. We show that $\agree^{ab}(e_1,e_2)$.
 
  The structural typing rules and those for $\newk$ and for parallel
  composition guarantee that
  $\Delta;\Gamma_1,a\colon S \vdash E_1[e_1]$ and
  $\Delta;\Gamma_2,b\colon \dual S \vdash E_2[e_2]$, for some
  $\Delta,\Gamma_1,\Gamma_2$. When $e_1$ is $\send{e'_1}a$,
  sub-derivation introduction and inversion
  (lemmas~\ref{lem:derivation-intro} and~\ref{lem:inversion}) allow to
  conclude that $\Delta \vdash S \TypeEquiv \;!B.S'$,
  hence~$\Delta \vdash \dual S \TypeEquiv \;?B.\dual{S'}$. Of all the
  terms with subject~$b$ only $\recv b$ has a type of the form
  $?B.\dual{S'}$, hence $\agree^{ab}(\send{e'_1}a,\recv b)$.
\end{proof}

\begin{corollary}[Progress for the functional sub-language]
  If $\Delta;\Gamma \vdash (\nu\vec a,\vec b)(E[e] \PAR p)$, then either
  $e\rightarrow e'$ or $e$ is a value or $e$ is of one of the
  following forms: $\send{v}{a}$, $\recv a$, $\select{l}{a}$ or
  $\case{a}{\{l_i\rightarrow e_i\}}$.  
\end{corollary}

It should be easy to see that the full language does not enjoy
progress. Consider two processes exchanging messages on two
different channels as follows.
%
\begin{equation*}
  (\nu a_1,a_2)(\nu b_1,b_2)(\sendk\;5\;a_1; \sendk\;7\;b_1 \mid \recvk\;b_2; \recvk\;a_2)
\end{equation*}
%
The nonbuffered (rendez-vous, synchronous) semantics leads to a
deadlocked situation. A recent survey reviews a few alternatives for
progress on session type
systems~\cite{huttel.lanese.etal:foundations-session-types}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conservative Extension}
\label{sec:conservative-extension}

Our system is a conservative extension of previous session type
systems. In those systems, the session type language is restricted to
tail recursion, the $\mu$ operator works with a much simpler notion
of contractivity, and equivalence is defined modulo unfolding.
We take the definitions from the functional session type
calculus~\cite{DBLP:journals/jfp/GayV10} as a blueprint.
The first-order part of the session type language from that paper may
be defined by $S'$ in the following grammar. Henceforth, we call that
language \emph{regular session types}.
\begin{align*}
  S'_X \grmeq& \End \grmor !B.S''_X \grmor ?B.S''_X \grmor \oplus\{l_i\colon {S_i}_X''\} \grmor
         \&\{l_i\colon {S_i}_X''\}
  \\
   \grmor& \mu x. S'_{X\cup\{x\}} \\
  S''_X \grmeq& x\in X \grmor S'_X
\end{align*}

The translation $\Embed{}$ into our system is defined as follows.
\begin{align*}
  \Embed{\End} & = \skipk
  \\
  \Embed{!B.S''} & = !B; \Embed{S''}
  &
  \Embed{?B.S''} & = ?B; \Embed{S''}
  \\
  \Embed{\oplus\{l_i\colon S_i''\}} & = \oplus\{l_i\colon\Embed{S_i''}\}
  &                                      
  \Embed{\&\{l_i\colon S_i''\}} & = \&\{l_i\colon  \Embed{S_i''}\}
  \\
  \Embed{\mu x.S'} & = \mu x. \Embed{S'}
  &
  \Embed{x} & = x
\end{align*}

\begin{lemma}
  For all $S'_\emptyset$, $\cdot \vdash \Embed{S'_\emptyset} :: \kinds^\Linear$.
\end{lemma}
\begin{proof}
  We need to prove a more general property.  Define
  $\GEnv_X = x : \kinds^\Linear \PAR x \in X$ and show that for all
  $S'_X$, $\GEnv_X \vdash \Embed{S'_X} :: \kinds^\Linear$. The proof
  is by straightforward induction.
\end{proof}
\begin{lemma}
  Let $\vdash_{\text{GV}}$ be the typing judgment for expressions from
  Gay and Vasconcelos~\cite{DBLP:journals/jfp/GayV10}.  If
  $\Gamma \vdash_{\text{GV}} e : T$, then
  $\cdot; \Gamma \vdash e : \Embed{T}$.
\end{lemma}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
