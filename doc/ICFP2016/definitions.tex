\section{Expressions, statics, and dynamics}
\label{sec:definitions}

% PROCESSES 
\subsection{Processes}
\label{sec:processes}

\input{fig-processes}

Values, expressions, and processes in Figure~\ref{fig:processes}.

% REDUCTION
\input{fig-reduction}

Structural congruence, $\equiv$, is the smallest relation that
includes the commutative monoid rules (for $\mid$ and $()$) and scope
extrusion. Reduction in Figure~\ref{fig:reduction}.

% RUNTIME ERRORS

Runtime errors. The \emph{subject} of an expression~$e$, $\subj(e)$,
is~$x$ in the following cases and undefined in all other cases.
%
\begin{equation*}
  \send \_x \qquad
  \recv x \qquad
  \select \_x \qquad
  \case x\_
\end{equation*}

Two expressions \emph{agree} in the following cases.
%
\begin{align*}
  \agree^{xy}(\send \_x, \recv y) &\qquad
  \agree^{xy}(\recv x,\send \_y)\\
  \agree^{xy}(\select \_x, \case y\_) &\qquad
  \agree^{xy}(\case x\_,\select \_y)
\end{align*}

A process is an \emph{error} if it is structurally congruent to some
process that contains a subexpression or subprocess of one of the
following forms:
%
\begin{enumerate}
\item $\letin{xy}{v}{e}$ and $v$ is not a pair;
\item $\match{v}{l_i\rightarrow e_i}_{i\in I}$ and $v\ne(\ink\,l_j\,v')$ for some $v'$ and
  $j\in I$;
\item $E_1[e_1] \mid E_2[e_2]$ and $\subj(e_1) = \subj(e_2) = x$ where
  neither $E_1$ nor $E_2$ bind~$x$;
\item $(\new xy)(E_1[e_1] \mid E_2[e_2] \mid p)$ and $\subj(e_1)=x$
  and $\subj(e_2)=y$ and $\neg\agree^{xy}(e_1,e_2)$ where $E_1$ does not
  bind~$x$ and $E_2$ does not bind~$y$;
\item $  (\new xy)(E_1[\selectk\,l_j\,x] \mid
  E_2[\casek\,y\,\ofk\,\{l_i\rightarrow e_i\}_{i\in I}] \mid p) $
  where $E_1$ does not bind $x$ and $E_2$ does not bind $y$ and
  $j\notin I$ (or the same with $x$ and $y$ swapped).
\end{enumerate}

% TYPES

% BEGIN - Moved to the section on types
% \subsection{Types}
% \label{sec:types}


% Base sets: \emph{recursion variables}~$x$; \emph{type
%   variables}~$\alpha$; \emph{primitive types}~$B$ including for
% example $\unitk$ and $\intk$. Grammars for session types, types, and
% type schemes in Figure~\ref{fig:types}.

% % WELL FORMED TYPE EXPRESSIONS
% Not all types in the language generated by the grammar are of
% interest; as customary, we consider recursive types like $\mu x. \mu y.x$ or
% $\mu x.(x;x)$ meaningless as they only have trivial interpretations. We
% follow MacQueen at al.~\cite{MacQueen198695} and require recursive
% types to be contractive.
% %
% %\input{fig-contractivity}
% %
% A type $T$ is \emph{contractive in $x$} if $\GEnv_x \Contr T : \gamma$ is
% derivable with the rules in Figure~\ref{fig:contractivity} for
% some $\GEnv_x$ that contains \textbf{no guardedness assumption about $x$}. The metavariable
% $\gamma$ ranges over $\Guarded$ and $\Productive$. 
% The intuitive reading is that any (recursive) use of $x$ must be preceded
% by a nontrivial type construction, where nontrivial means different
% from $\skipk$. For example, a session type like $\mu x. (\skipk; x)$
% or $\mu x.(x; !B)$ must be disallowed whereas $\mu x.(!B; x)$ should
% be allowed.  If $\GEnv \Contr T : \Guarded$ is derivable, but not $\GEnv
% \Contr T : \Productive$, then $T$ is essentially composed of
% $\skipk$s. If $\GEnv \Contr T : \Productive$ is derivable, then $T$
% describes a nontrivial interaction.

% The interaction between $\mu$-operators is also nontrivial. For
% example, the type $\mu x'. \mu x. (x'; x) $ is ruled out because $x'$
% would not be guarded after unrolling $\mu x$ once. However, the type
% $\mu x'. (!B; \mu x. (x'; x))$ is accepted because unrolling $\mu x'$
% reveals that the recursive occurrence of $x$ is guarded: $(!B; \mu
% x. (\mu x'. (!B; \mu x. (x'; x)); x))$. Hence, an essential
% requirement of well-formedness of types is preservation of
% well-formedness under arbitrary unrolling of $\mu$ operators. 

% The second judgment $ \GEnv \vdash T \isOk$ in Figure~\ref{fig:contractivity}
% specifies the set of \emph{well-formed} type expressions where
% $\GEnv$ contains guardedness assumptions about the recursion
% variables that may occur in $T$. The obvious
% inductive rules that require well-formedness of every subexpression
% are omitted.

% This definition incorporates type variables $\alpha$ by assuming that they
% are always replaced by productive types.
% Type variables must be restricted in this way because contractivity of $\mu
% x. (\alpha; x)$ requires the $\alpha \Contr \alpha : \Productive$ to be derivable so that
% $\alpha \Contr \mu x. (\alpha; x) : \Productive$ is derivable. 
% %
% Finally, a type scheme $\forall \alpha_1\dots\forall\alpha_n. T$ is
% \emph{well-formed} if $\alpha_1, \dots, \alpha_n \vdash T \isOk$ is
% derivable. 

% \begin{lemma}
%   If $\GEnv \vdash T \isOk$, then $\GEnv, x : \gamma \vdash T \isOk$
%   for some $x$ not in $\GEnv$.
% \end{lemma}

% \begin{lemma}
%  If $\GEnv \vdash \mu x.T \isOk$, then $\GEnv \vdash T[\mu
%   x. T/x] \isOk$.
% \end{lemma}
% \begin{proof}
%   If  $\GEnv \vdash \mu x.T \isOk$, it must be because  $\GEnv,
%   x:\gamma \vdash T \isOk$ and $\GEnv\setminus x \Contr T : \gamma$.
%   We prove by induction on $\GEnv, x:\gamma \vdash T \isOk$ that
%   $\GEnv \vdash T[\mu  x. T/x] \isOk$.

%   There are two interesting cases. In the first case, we encounter the
%   recursion variable $\GEnv, x:\gamma, \GEnv' \vdash x
%   \isOk$. At this point, we have to return $\GEnv, \GEnv' \vdash \mu
%   x.T \isOk$. But is derivable by the initial assumption and
%   weakening.

%   The other case is a different $\mu$ operators in a judgment $\GEnv,
%   x:\gamma, \GEnv' \vdash \mu x'. T' \isOk$. Inversion yields $\GEnv,
%   x:\gamma, \GEnv', x':\gamma' \vdash T' \isOk$ and $(\GEnv,
%   x:\gamma, \GEnv') \setminus x' \Contr T' : \gamma'$. The first part
%   can be handled by induction, but the second part requires an
%   auxiliary induction to prove that $(\GEnv, \GEnv') \setminus x'
%   \Contr T'[\mu x.T/x] : \gamma'$. For this auxiliary induction it is
%   sufficient to observe that a successful derivation never reaches a
%   recursion variable, so the unrolling does not matter. 
% \end{proof}

% END - Moved to the section on types 



% PJT: Too limiting, unfortunately.
% This definition rules out \mu x.(!B;x)  --- which should be allowed.
% This definition admits \mu x.(\mu x.skip; x) --- which should not be
% allowed.
% \begin{itemize}
% \item $T$ has one of the forms $T \rightarrow T$, $T \multimap T$, $T
%   \otimes T$, $[l_i\colon T_i]$, $B$, $\skipk$, $!B$, $?B$,
%   $\oplus\{l_i\colon S_i\}$, $\&\{l_i\colon S_i\}$, or $\alpha$.
% \item $T$ has the form $S_1;S_2$ with both $S_1$ and $S_2$ contractive
%   in~$x$.
% \item $T$ has the form $\mu x'.T'$ with either $x=x'$ or $T'$
%   contractive in~$x$.
% \end{itemize}

% TYPE EQUIVALENCE 

%\input{type-simulation}

% \input{fig-type-equivalence}
% Type equivalence in Figure~\ref{fig:type-equivalence}.
% Given a binary relation $R$,  we write
% $R^{-1}$ for the inverse relation $\{(y,x)\mid (x,y)\in R\}$ and $R^s$
% for the symmetric closure $R \cup R^{-1}$.

% ALGORITHMIC TYPE EQUIVALENCE  _ DEPRECATED

% \input{proofs-type-equivalence}

% \input{fig-algorithmic-type-equiv}

% Algorithmic type equivalence is in
% Figure~\ref{fig:alg-type-equiv}.
% %
% For example, letting $S_1= \mu x.!B;x$, $S_2 = \;!B;S_2'$, and
% $S_2' = \mu y.((\skipk;!B);y)$, for an initial goal of the form
% $\cdot \vdash S_1 \equiv S_2$, a run of the algorithm generates the
% following subgoals:
% %
% \begin{align*}
%   S_1 \equiv S_2 \vdash& \;!B;S_1 \equiv \;!B;S_2'
%   \\
%   S_1 \equiv S_2 \vdash&\; S_1\equiv S_2'
%   \\
%   S_1 \equiv S_2, S_1\equiv S_2' \vdash& \;!B;S_1 \equiv !B;(\skipk;S_2')
%   \\
%   S_1 \equiv S_2, S_1\equiv S_2' \vdash& S_1 \equiv \skipk;S_2'
%   \\
%   S_1 \equiv S_2, S_1\equiv S_2', !B;S_1 \equiv \skipk;S_2' \vdash& \;!B;S_1 \equiv \;!B;(\skipk;S_2')
%   \\
%   S_1 \equiv S_2, S_1\equiv S_2', !B;S_1 \equiv \skipk;S_2' \vdash& S_1 \equiv \skipk;S_2'
% \end{align*}

% \input{proofs-alg-type-equivalence}

% END OF DEPRECATED

% THE UN PREDs

The $\un(T)$ predicate for types is an abbreviation of judgment
$\vdash T :: \kind^\Linear$. For contexts, predicate
$\un(x_1\colon T_1,\dots, x_n\colon T_n)$ is true when all
$\un(T_1),\dots,\un(T_n)$ hold.

% The $\un$ predicate is true of the following session types and
% types. The predicate is not defined for type schema.
% %
% \begin{gather*}
%   \un(\skipk) \quad \un(S_1;S_2) \text{ if } \un(S_1) \text{ and } \un(S_2) 
%   \\
%   \un (\unitk)
%   \quad
%   \un([l_i\colon T_i]) \text{ if } \un(T_1) \text{ for all } i
%   \\ \un(T_1\rightarrow T_2)
%   \quad \un(B) \quad \un(\mu x.T) \text{ if } \un(T) \quad \un (x)
% \end{gather*}

% DUALITY

The duality function on session types, $\dual S$, is defined as
follows.
%
\begin{gather*}
  \dual\skipk = \skipk
  \qquad
  \dual{!B} = \;?B
  \qquad
  \dual{?B} = \;!B
  \qquad
  \dual{S_1;S_2} = \dual{S_1};\dual{S_2}
  \\
  \dual{\&\{l_i\colon S_i\}} = \oplus\{l_i\colon \dual{S_i}\}
  \qquad
  \dual{\oplus\{l_i\colon S_i\}} = \&\{l_i\colon \dual{S_i}\}
  \\
  \dual{\mu x.S} = \mu x.\dual S
  \qquad
  \dual x = x
\end{gather*}
%
This simple definition is justified by the fact that the types we
consider are first order, hence the complication known to arise
in presence of higher-order
recursion~\cite{bernardi.hennessy:using-contracts-model-session-types}
does occur.

To check whether $S_1$ is dual to $S_2$ we compute $S_3 = \dual{S_1}$
and check $S_2$ and $S_3$ for equivalence.
%
Duality is clearly an involution ($\dual{\dual S} = S$), hence we can
alternatively compute $\dual{S_2}$ and check that $S_1$ is equivalent
to $\dual{S_2}$.
%
For example, to check that $!B;\mu x.(\skipk;!B;x)$ is dual to
$\mu y.(?B;y)$, we compute $\dual{\mu y.(?B;y)}$ to obtain
$\mu y.(!B;y)$, and check that this type is equivalent to
$!B;\mu x.(\skipk;!B;x)$.

% Let $\rho$ denote a map from recursion variables~$x$ into session
% types~$S$, where $\varepsilon$ is empty map, and $\rho[x\mapsto S]$ is
% map extension. The substitution of recursion variable~$x$ by $S'$ in
% $S$, notation $S\subs{S'}x$, is defined appropriately. The
% \emph{duality function} on session types is defined as
% %
% \begin{equation*}
% \dual S = \dualof(S,\varepsilon)
% \end{equation*}
% where
% %
% \begin{align*}
%   \dualof(\skipk,\rho) &= \skipk\\
%   \dualof(!B,\rho) &=\: ?(B\rho)\\
%   \dualof(?B,\rho) &=\: !(B\rho)\\
%   \dualof(S_1;S_2,\rho) &= \dualof(S_1,\rho); \dualof(S_2,\rho)\\
%   \dualof(\oplus\{l_i\colon S_i\}, \rho) &= \&\{l_i\colon \dualof(S_i,\rho)\}\\
%   \dualof(\&\{l_i\colon S_i\}, \rho) &= \oplus\{l_i\colon \dualof(S_i,\rho)\}\\
%   \dualof(\mu x.S, \rho) &= \mu x.\dualof(S, \rho[x\mapsto \mu x.S])
% \end{align*}

% This definition fixes an issue with the (flawed) more conventional
% syntactic definition of
% duality~\cite{bernardi.hennessy:using-contracts-model-session-types}.
% Example. Take $S = \mu x.\mu y.?y;x$. Then
% $\dual T = \mu x \mu y.!(\mu y.?y.S);x$, as opposed to
% $\mu x.\mu y.!y;x$.

% TYPING

\input{fig:typing}

Typing rules in Figure~\ref{fig:typing}.
%
The usual derived rules.
%
\begin{gather*}
  \frac{
    \Gamma_1 \vdash e_1:T_1
    \quad
    \Gamma_2,x:T_1 \vdash e_2:T_2
  }{
    \Gamma_1,\Gamma_2 \vdash \letin x {e_1}{e_2} : T_2
  }
\\
  \frac{
    \Gamma_1 \vdash e_1:T_1
    \quad
    \Gamma_2 \vdash e_2:T_2
    \quad
    \un(T_1)
  }{
    \Gamma_1,\Gamma_2  \vdash e_1;e_2 : T_2
  }
\end{gather*}

% EXAMPLES

\subsection{Examples}
\label{sec:examples}

Streaming a tree on a channel, back and forth.

\lstinputlisting{tree.cfs}

A trace of the type of the channel in function \lstinline|transform|,
where \lstinline|TC| abbreviates \lstinline|TreeChannel|.

\lstinputlisting{trace.cfs}

The arithmetic expression server.

\lstinputlisting{arithmetic-server.cfs}

Now with a datatype to simplify the client's life.

\lstinputlisting{arithmetic-server-data.cfs}

Let's try a SePi-like version. All we need are context-free session
types and type schemas\footnote{Predicative Polymorphism in
  pi-Calculus. Vasco Thudichum Vasconcelos. In 6th Parallel
  Architectures and Languages Europe, volume 817 of LNCS, pages
  425--437. Springer, 1994.}. We witness the extra ``plumbing''
typical of the pi-calculus, but otherwise very little (type only, in
fact) extra basic notions.

\lstinputlisting{arithmetic-server-sepi.cfs}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
