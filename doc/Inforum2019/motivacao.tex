\section{Motivação}

Os tipos de sessão foram propostos para responder à necessidade de
formalização de trocas de mensagens, permitindo definir protocolos na
forma de tipos que representam interações corretas do sistema e que
garantem propriedades tais como a inexistência de erros na comunicação
e de situações de impasse~\cite{ref-lang-primitives}. Contudo, a
expressividade dos tipos de sessão está ainda aquém de todos os
desafios de comunicação que encontramos nos sistemas: não permitem em
particular misturar \textit{input} e \textit{output} na mesma escolha.

Considere-se o seguinte problema.
%
\begin{quotation}
	Dado $k\in\mathbb{Z}$, qual o maior inteiro $n$ tal que
	$\sum_{i=1}^n i < k$?
\end{quotation}

Imagine-se um processador capaz de gerar sequências de números
inteiros mas sem a capacidade de os somar. Imagine-se a um
segundo processador capaz de somar números inteiros, mas incapaz de os
gerar. Ambos os processadores estão aptos para a utilização de
comunicação por canais.
%
Este exemplo simplista retrata o caso em que a interação entre
os processos se dá necessariamente nos dois sentidos e ambos 
os processos deverão
estar aptos, leia-se \emph{corretamente tipados}, para responder 
às necessidades da comunicação.

Tirando partido das restrições computacionais dos nossos dois
processadores, podemos tentar resolver o problema dos seguinte modo:
%
\begin{itemize}
\item Um dos processos, \lstinline|produtor|, gera a sequência de
  números: 1,2,3,\dots e envia-a num canal, até receber no mesmo
  canal uma notificação para terminar o envio. A notificação vem na
  forma de uma marca \lstinline|EOS| (\textit{end-of-stream});
\item O outro processo, \lstinline|consumidor|, vai somando os números
  que recebe os números que recebe enquanto a soma for menor do que
  $n$. Neste ponto envia a marca \lstinline|EOS|.
\item O programa principal cria o canal e lança os dois processos.
\end{itemize}

O canal de comunicação segue o  protocolo delineado acima. Quando
visto do lado do \lstinline|produtor| o canal toma o tipo
%
\begin{lstlisting}
  type CanalInt = ?EOS + !Int;CanalInt
\end{lstlisting}
%
permitindo a cada momento a leitura (\lstinline|?|) da marca
\lstinline|EOS| ou a escrita (\lstinline|!|) de um inteiro. No caso da
leitura o protocolo volta ``ao início''.
%
Quando visto do lado do \lstinline|consumidor| o canal toma o tipo
obtido do acima trocando as operações de leitura pelas de escrita, e
vice-versa. Abreviamos esse tipo com \lstinline|dualof CanalInt|.

\begin{lstlisting}
produtor : CanalInt -> Int -> ()
produtor c i = choice {
  (c, EOS) = receive -> (),
  c = send c n -> consumidor c (i+1)

consumidor : dualof CanalInt -> Int -> Int -> Int -> Int
consumidor c s n k = if n >= n
then choice { c = send EOS -> n--1 }
else choice { (c, m) = receive c -> produtor c (s+m) (n+1) k }

main : Int
main = let
  k = 1000
  (p, c) = new CanalInt in
  fork produtor p 1;
  consumidor c 0 0 k
\end{lstlisting}

O construtor linguístico que manipula escolhas é \lstinline|choice|:
entre as chavetas encontramos \emph{um ou mais} padrões. Os padrões de
\textit{output} levam a palavra reservada \lstinline|send| e os de
\textit{input} \lstinline|receive|. Todas estas primitivas devolvem o
canal (\lstinline|c| no exemplo) onde a interação deve continuar. No
caso da receção, a operação \lstinline|receive| um segundo elemento: o
valor lido. Finalmente, no caso de receção de marcas,
(\lstinline|EOS|, por exemplo), permitimo-nos usar
\textit{pattern-matching}.
%
A escolha do \lstinline|consumidor| é degenerada, quer no ramo
\lstinline|then| como no ramo \lstinline|else|. Poderiamos neste caso
eliminar a palavra reservada \lstinline|choice|.

O programa principal cria um novo canal através da primitiva
\lstinline|new|. O resultado é um par descrevendo as duas extremidades
do canal, \lstinline|p| e \lstinline|c|, destinado a cada um dos
processos.
%
A primitiva \lstinline|fork| lança uma nova \textit{thread} destinada
a correr o processo produtor. O resultado do programa principal é o
resultado do processo \lstinline|consumidor|.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
