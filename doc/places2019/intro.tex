\section{Session types deserve to be free}

Session types have been long subject to the shackles of tail
recursion~\cite{DBLP:conf/concur/Honda93,DBLP:conf/esop/HondaVK98}. Regular
session-type languages bear the evident advantage of providing simple
algorithms to check type equivalence and subtyping. Given two types, a
fixed-point construction algorithm such as the one introduced by Gay
and Hole builds, in polynomial time and space, a bisimulation relating
the two types, or decides that no such relation
exists~\cite{DBLP:journals/acta/GayH05}. The scenario darkens when one
decides to let go of tail recursion, for now the fixed-point
construction algorithm does not necessarily terminate.
%
This is one of the main reasons why session types have been confined
to ($\omega$-) regular languages for so many years.

The discipline of conventional (that is, regular) session types
provides guarantees not easily accessible to simpler languages such as
Concurrent ML, where channels are unidirectional and transport values
of a fixed type~\cite{DBLP:conf/mcmaster/Reppy93}. Session types, in
turn, provide for the description of richer protocols, epitomised by
the math client~\cite{DBLP:journals/acta/GayH05}, which can be
rendered in the SePi language~\cite{DBLP:conf/sefm/FrancoV13} as
follows:
%
\begin{lstlisting}[morekeywords=end]
MathClient = +{
  Plus: !Int.!Int.?Int.MathClient,
  Eq: !Int.!Int.?Bool.MathClient,
  Done: end
}
\end{lstlisting}

The type \lstinline|MathClient| describes the client side of the
protocol, introducing three choices: \lstinline|Plus|, \lstinline|Eq|,
and \lstinline|Done|. A client that chooses the \lstinline|Plus|
choice is supposed to send two integer values and to receive a further
integer (possibly representing the sum of the two values sent), after
which it goes back to the beginning. If the same client chooses
instead the \lstinline|Eq| option, it must subsequently send two
integer values and expect a boolean result (possibly describing
whether the two integers are equal), after which it must go back to
the beginning.  The \lstinline|Done| option terminates the protocol,
as described by type \lstinline[morekeywords=end]|end|.

The guarantees introduced by session type systems include the
adherence of the code to the protocol and the related absence of
runtime errors, including race
conditions~\cite{DBLP:conf/esop/HondaVK98}. Some systems further
guarantee progress~\cite{DBLP:conf/concur/CairesP10}. All this, under
a rather expressive type language, that of (regular) session types.

There is one further characteristic of session types that attest for
its flexibility: the ability to send channels on channels, often
called delegation. This feature provides for the transmission of
complex data on channels in a typeful manner. Suppose we want to
transmit a tree of integer values on a channel. The tree may be
described by data type \lstinline|Tree|:
%
\begin{lstlisting}
data Tree = Leaf | Node Int Tree Tree
\end{lstlisting}

One has to choose between a) using multiple channels for
sending the tree or b) using a single channel but incurring runtime
checks to check adherence to the protocol. In the former scenario,
trees are sent on channels of type
%
\begin{lstlisting}[morekeywords=end]
type TreeChannelR = +{Leaf:end, Node:!Int.!TreeChannelR.!TreeChannelR.end}
\end{lstlisting}
%
and we see that two new channels must be created and exchanged for
each \lstinline|Node| in a tree, so that $2n+1$ channels are needed to
transmit an $n$-\lstinline|Node| tree (equivalently, $n$ channels are
needed to transmit a tree with~$n$ \lstinline|Leaf| or
\lstinline|Node| components).
%
To see why, notice that type \lstinline|TreeChannelR| is not
recursive: a \lstinline|Leaf| is sent on the given channel, a
\lstinline|Node| is sent on the channel, but two the two subtrees are
sent of newly created channels (the parts \lstinline|!TreeChannelR| in
the type above).
%
In the latter case, tree parts are sent on a single channel, but not
necessarily in a ``tree form''. A suitable channel type is
%
\begin{lstlisting}[morekeywords=end]
type TreeParts = +{Leaf: TreeParts, Node: !Int.TreeParts, EOS: end}
\end{lstlisting}
%
where \lstinline|EOS| represents the end of transmission. In this case
tree \lstinline|Node 1 (Node 2 Leaf Leaf) Leaf| can be transmitted as
\lstinline|Node 1 Node 2 Leaf Leaf Leaf EOS|, when visited in a
depth-first manner. It should be easy to see that type
\lstinline|TreeParts| allows transmitting many different tree parts
that do not add up to a tree (such as,
%
\lstinline|Node 1 Leaf Leaf Node 2 Leaf EOS|), hence the necessary
runtime checks to look over unexpected parts on the channel.

In 2016, Thiemann and Vasconcelos introduced the concept of
context-free session types and proved that type equivalence remains
decidable~\cite{DBLP:conf/icfp/ThiemannV16}.
%
Context-free session types appear as a natural extension of
conventional (regular) session-types. Syntactically, the changes are
minor: rather than dot (\lstinline|.|), the prefix operator, we use
semi-colon (\lstinline|;|), a new binary operator on types. We also
take the chance to replace \lstinline [morekeywords=end]|end| by
\lstinline|Skip| to make it clear that it does not necessarily ``end''
a session type, but else merely introduces a mark that can sometimes
be omitted. In fact \lstinline|Skip| is the identity element of
sequential composition. The concurrent programming language
we present, \freest, is an implementation of the
language proposed by Thiemann and Vasconcelos.
\freest{} enjoys the monoidal axioms:
\lstinline|Skip;T| $\equiv$ \lstinline|T;Skip| $\equiv$ \lstinline|T|,
for all types \lstinline|T|.
%
Using the syntax of \freest, a channel that streams a tree can be
written as follows:
%
\begin{lstlisting}
type TreeChannel = +{Leaf: Skip, Node: !Int;TreeChannel;TreeChannel}
\end{lstlisting}

The language \freest, described in the remainder of the paper, 
provides for the best
of both worlds: stream the tree on a \emph{single} channel,
\emph{without} extraneous runtime checks.

% Related work

There are a few experimental programming languages based on session
types and there are many proposals for encoding session types in
mainstream programming languages. We cannot cover them all in
this short abstract; the interested reader is referred to a 2016
survey on behavioural types in programming
languages~\cite{DBLP:journals/ftpl/AnconaBB0CDGGGH16}.  Here, we briefly
discuss a few prototypical programming languages using session types.

SePi is a programming language based on the pi-calculus whose channels
are governed by regular session types refined with uninterpreted
predicates~\cite{DBLP:conf/sefm/FrancoV13}. The concrete syntax we
choose for \freest{} types is influenced by SePi.

SILL is a functional language with session typed concurrency, based on
the Curry-Howard interpretation of intuitionistic linear
logic~\cite{DBLP:conf/concur/CairesP10}, further extended with
recursive types and
processes~\cite{Toninho:phd,DBLP:conf/esop/ToninhoCP13}.
%
C1 is an imperative language~\cite{Pfenning:C1} developed along the
lines of SILL, featuring types that express
sharing~\cite{DBLP:journals/pacmpl/BalzerP17}.
%
All these languages use regular session types. Compared to \freest,
they present stronger properties (including progress), at the expense
of imposing a particular form of programming (derived from the
Curry-Howard interpretation) whereby each process uses zero or more
channels and provides exactly one. At the time of this writing,
\freest{} does not allow for multiple threads to share a same channel.

Links~\cite{DBLP:conf/fmco/CooperLWY06} is a functional programming
language for the web, later extended with session typing
primitives~\cite{DBLP:conf/esop/LindleyM15,Lindley.Morris_Lightweight.functional.session.types}. Very
much like SILL and C1, the base language is deadlock-free and
terminating. Links also includes recursion and shared channels, the
later foregoing termination and deadlock-freedom.
%
The kinding system of \freest{} is quite similar to that of FST,
proposed by Lindley and
Morris~\cite{Lindley.Morris_Lightweight.functional.session.types}.

The only other implementation of context-free session types we are
aware of is that of Padovani~\cite{DBLP:conf/esop/Padovani17}, a
language that admits equivalence, subtyping and, of particular
interest, inference algorithms. It does however require a structural
alignment between the process code and the session types, enforced by
a \emph{resumption} process operator that explicitly breaks a type
$S;T$. The usage of resumptions requires additional annotations in
programs---something we managed to avoid in \freest---and,
furthermore, it does not solve the type equivalence problem since the
monoidal rules proposed by Thiemann and Vasconcelos cannot be
used. Padovani proposes the use of \emph{explicit coercions} to
overcome this limitation, but this requires greater efforts from
programmers.  Additional effort by programmers are always time
consuming and error-prone, hence we have embedded a full-fledged type
equivalence checker into the compiler, thus avoiding additional
annotations.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
