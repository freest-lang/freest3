\section{Session types deserve to be free}

Session types have been long subject to the shackles of tail
recursion~\cite{DBLP:conf/concur/Honda93,DBLP:conf/esop/HondaVK98}. Regular
session-type languages bear the evident advantage of providing
simple algorithms to check type equivalence and subtyping. Given two
types, a fixed-point construction algorithm such as the one introduced
by Gay and Hole builds, in polynomial time and space, a bisimulation
relating the two types, or decides that no such relation
exists~\cite{DBLP:journals/acta/GayH05}. The scenario darkens when one
decides to let go of tail recursion, for now the fixed-point
construction algorithm does not necessarily terminate.
%
This is one of the main reasons why session types have been confined
to ($\omega$-) regular languages for so many years.

The discipline of conventional (that is, regular) session types
provides guarantees not easily accessible to simpler languages such as
Concurrent ML, where channels are unidirectional and transport values
of a fixed type~\cite{DBLP:conf/mcmaster/Reppy93}. Session types, in
turn, provide for the description of richer protocols, epitomised by
the math client~\cite{DBLP:journals/acta/GayH05}, which can be
rendered in the SePi language~\cite{DBLP:conf/sefm/FrancoV13} as
follows:
%
\begin{lstlisting}[morekeywords=end]
MathClient = +{
  Plus: !Int.!Int.?Int.MathClient,
  Eq: !Int.!Int.?Bool.MathClient,
  Done: end
}
\end{lstlisting}

The type \lstinline|MathClient| describes the client side of the protocol,
introducing three choices: \lstinline|Plus|, \lstinline|Eq|, and
\lstinline|Done|. A client that chooses the \lstinline|Plus| choice is
supposed to send two integer values and to receive a further integer
(possibly representing the sum of the former two), after which it goes
back to the beginning. If the same client chooses instead the
\lstinline|Eq| option, it must subsequently send two integer values
and expect a boolean result (possibly describing whether the two
integers are equal), after which it must go back to the beginning.
The \lstinline|Done| option terminates the protocol, as described by
type \lstinline[morekeywords=end]|end|.

The guarantees introduced by session type systems include the
adherence of the code to the protocol and the related absence of
runtime errors, including race
conditions~\cite{DBLP:conf/esop/HondaVK98}. Some systems further
guarantee progress~\cite{DBLP:conf/concur/CairesP10}. All this, under
a rather expressive type language, that of (regular) session types.

There is one further characteristic of session types that attest for
its flexibility: the ability to send channels on channels, often called
delegation. This feature provides for the transmission of complex data
on channels in a typeful manner. Suppose we want to stream a tree
%
\begin{lstlisting}
data Tree = Leaf | Node Int Tree Tree
\end{lstlisting}
%
on a channel. One has to choose between a) using multiple channels for
sending the tree or b) using a single channel but incurring runtime
checks to check adherence to the protocol. In the former scenario,
trees are sent on channels of type
%
\begin{lstlisting}[morekeywords=end]
type TreeChannelR = +{Leaf:end, Node:!Int.!TreeChannelR.!TreeChannelR.end}
\end{lstlisting}
%
and we see that two new channels must be created and exchanged for
each \lstinline|Node| in a tree, so that $2n+1$ channels are needed to
stream an $n$-\lstinline|Node| tree.
%
In the latter case, tree parts are sent on a single stream, but not
necessarily in a ``tree form''. A suitable channel type is
%
\begin{lstlisting}[morekeywords=end]
type TreeParts = +{Leaf: TreeParts, Node: !Int.TreeParts, EOS: end}
\end{lstlisting}
%
where \lstinline|EOS| represents the end of stream. In this case tree
\lstinline|Node 1 (Node 2 Leaf Leaf) Leaf| can be streamed as
\lstinline|Node 1 Node 2 Leaf Leaf Leaf EOS|, when visited in a
depth-first manner. It should be easy to see that type
\lstinline|TreeParts| allows streaming many different tree parts that
do not add up to a tree (such as,
%
\lstinline|Node 1 Leaf Leaf Node 2 Leaf EOS|), hence the necessary
runtime checks to look over unexpected parts on the stream.

In 2016, Thiemann and Vasconcelos introduced the concept of
context-free session types and proved that type equivalence remains
decidable~\cite{DBLP:conf/icfp/ThiemannV16}.
%
Context-free session types appear as a natural extension of
conventional (regular) session-types. Syntactically, the changes are
minor: rather than dot (\lstinline|.|), the prefix operator, we use
semi-colon (\lstinline|;|), a new binary operator on types. We also
take the chance to replace \lstinline [morekeywords=end]|end| by
\lstinline|Skip| to make it clear that it does not necessarily ``end''
a session type, but else merely introduces a mark that can sometimes
be omitted. In fact \lstinline|Skip| is the identity element of
sequential composition. The concurrent programming language
we present, \freest, is an implementation of the
language proposed by Thiemann and Vasconcelos.
\freest{} enjoys the monoidal axioms:
\lstinline|Skip;T| $\equiv$ \lstinline|T;Skip| $\equiv$ \lstinline|T|,
for all types \lstinline|T|.
%
Using the syntax of \freest, a channel that streams a tree can be
written as follows:
%
\begin{lstlisting}
type TreeChannel = +{Leaf: Skip, Node: !Int;TreeChannel;TreeChannel}
\end{lstlisting}

The language \freest, described in the remainder of the paper, 
provides for the best
of both worlds: stream the tree on a \emph{single} channel,
\emph{without} extraneous runtime checks.

% Related work

There are a few experimental programming languages based on session
types and there are many proposals for encoding session types in
mainstream programming languages. We cannot cover them all in
this short abstract; the interested reader is referred to a 2016
survey on behavioural types in programming
languages~\cite{DBLP:journals/ftpl/AnconaBB0CDGGGH16}.  Here, we briefly
discuss a few prototypical programming languages using session types.

SePi is a programming language based on the pi-calculus whose channels
are governed by regular session types refined with uninterpreted
predicates~\cite{DBLP:conf/sefm/FrancoV13}. The concrete syntax we
choose for \freest{} types is influenced by SePi.

SILL is a functional language with session typed concurrency, based on
the Curry-Howard interpretation of intuitionistic linear
logic~\cite{DBLP:conf/concur/CairesP10}, further extended with
recursive types and
processes~\cite{Toninho:phd,DBLP:conf/esop/ToninhoCP13}.
%
C1 is an imperative language~\cite{Pfenning:C1} developed along the
lines of SILL, featuring types that express
sharing~\cite{DBLP:journals/pacmpl/BalzerP17}.
%
All these languages use regular session types. Compared to \freest,
they present stronger properties (including progress), at the expense
of imposing a particular form of programming (derived from the
Curry-Howard interpretation) whereby each process uses zero or more
channels and provides exactly one. At the time of this writing,
\freest{} does not include shared types.

Links~\cite{DBLP:conf/fmco/CooperLWY06} is a functional programming
language for the web, later extended with session types
primitives~\cite{Lindley.Morris_Lightweight.functional.session.types}. Very
much like SILL and C1, the base language is deadlock-free and
terminating. Links also includes recursion and shared channels,
foregoing deadlock-freedom.

The only other implementation of context-free session types we are
aware of is that of Padovani~\cite{DBLP:conf/esop/Padovani17}, a
language that admits equivalence, subtyping and, of particular
interest, inference algorithms. It does however require a structural
alignment between the process code and the session types, enforced by
a \emph{resumption} process operator that explicitly breaks a type
$S;T$. The usage of resumptions requires additional annotations
from the programmer---which we would like to avoid in 
\freest---and, beyond that, it does not solve the type equivalence
problem since the monoidal rules proposed by Thiemann and
Vasconcelos cannot be used. Padovani proposes the use of 
\emph{explicit coercions} to fix this limitation, but this
would require a greater effort from the programmer. 
Any additional effort by the programmer is error-prone, hence
we have embedded a type equivalence checker into  
\freest\ so that it does not need to rely on any
additional annotation from the programmer.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
