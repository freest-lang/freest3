\section{The bright future of \freest{}}
\label{sec:conclusion}

We have developed a basic compiler for \freest, a concurrent
functional programming with context-free session types, based on the
ideas of Thiemann and Vasconcelos~\cite{DBLP:conf/icfp/ThiemannV16}.
%
There are many possible extensions to the language. We discuss a
few.
%
Support for linear pairs and linear datatypes, as well for polymorphic
datatypes, should not be difficult to incorporate.
%
Because \freest{} compiles to Haskell, a better interoperability is
called for. We plan to add primitive support for lists, and for some
functions in Haskell's prelude, namely rank-1 functions that we will
have to annotate with \freest{} types.
%
We have chosen a buffered semantics with buffers of size one, for ease
of implementation, but we plan to experiment with buffered channels of
arbitrary size by simply replacing the back-end.
%
The original proposal of context-free sessions is based on a
call-by-value operational semantics and we kept that strategy in
\freest. We however plan to experiment with call-by-need, taking
advantage of the back-end in Haskell. 
%
Shared channels allow for multiple readers and multiple writers,
thus introducing (benign) races. There are several proposals in the
literature~\cite{DBLP:journals/pacmpl/BalzerP17,
  DBLP:conf/sefm/FrancoV13,Lindley.Morris_Lightweight.functional.session.types,DBLP:journals/iandc/Vasconcelos12}
on which we may base this extension.
%
The \lstinline|dualof| type operator is present in the SePi
language~\cite{DBLP:conf/sefm/FrancoV13}. Its incorporation in
\freest{} may be complicated by the presence of polymorphic type
variables.

We also plan to extend the expressivity of \freest{} by allowing
messages to convey arbitrary types, as opposed to basic types only.
% session types to be used to send or receive other session types.  For
% this purpose, we intend to enable message operators to be applied not
% only to basic types but to any functional or session type. 
In this wider scope, the type equivalence algorithm for context-free
session types must be intertwined with the type equivalence algorithm
for functional types, for now, the labels of the labeled-transition
system are types themselves.

Last but not least, we plan to incorporate type inference on type
applications in order to allow the automatic identification of the
unifier matching a polymorphic type against a given type. This
unification process should recognize the unifiers of two types up to
type equivalence. However, dealing with type inference on type
applications with recursive types might be challenging, as observed by
Hosoya and Pierce~\cite{DBLP:journals/toplas/PierceT00}.
%in~\cite{hosoya1999good}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
