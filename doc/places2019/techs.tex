\section{Let \freest{} run}
\label{sec:compiler}

\freest{} is written in Haskell and generates Haskell code that can be
compiled with a conventional GHC compiler.
%
The validation phase features a kinding system and a typing system
briefly described in the previous section. Only declarative versions
of these systems are described in Thiemann and
Vasconcelos~\cite{DBLP:conf/icfp/ThiemannV16}; we have developed the
corresponding algorithmic versions.

% The \emph{kinding system} classifies types in kinds, composed of a
% prekind (session or functional) and a multiplicity (unrestricted or
% linear). For example \lstinline|!Int| is a well formed type of kind
% linear session type. On the other hand \lstinline|(Int->Bool);Int| is
% not well formed for it mixes functional types with session types.
% %
% It is polymorphism that precludes the syntactic separation of session
% and functional types. For example, type \lstinline|TreeC;alpha| is
% well formed only in a context assigning a session kind to type
% variable \lstinline|alpha|. In such a case the type is of kind linear
% session.
% %
% The declarative kinding system comprises a rule of kind subsumption,
% and is therefore not guided by the syntax of types. The algorithmic
% version used in the compiler is obtained by transforming the original
% system into a bidirectional system.
%
% The \emph{typing system} is a conventional type system for GV-like
% languages~\cite{DBLP:journals/jfp/GayV10}. It further includes the
% specialisation rule, typical of Hindley-Milner type
% systems~\cite{DBLP:journals/jcss/Milner78}, allowing to replace a
% polymorphic type with a monomorphic one. The original system is not
% syntax-directed due to specialisation and to a type equivalence rule
% that allows replacing the type of an expression by an equivalent
% type.
% %
% Again, the algorithmic version is obtained by transforming the
% original system into a bidirectional system. The specialisation rule
% becomes tied together with function application, where a simple
% algorithm infers the right type for the polymorphic variable in the
% target function.
%
% Checking \emph{type equivalence} is the main challenge of the
% compiler. Due to the recursive structure underlying context-free 
% session types, a bisimulation between two types is often infinite. 
% Deciding the equivalence of types relies, then, on the construction 
% of a finite relation whose least congruence with respect to  
% sequential composition coincides with the bisimulation. As mentioned
% in section~\ref{sec:valid}, we have implemented an algorithm 
% to check the equivalence of types. We have proved its soundness 
% and completeness with respect to the meta-theory
% of context-free session types proposed by Thiemann and 
% Vasconcelos~\cite{DBLP:conf/icfp/ThiemannV16}. This algorithm
% is incorporated in the compiler.
%
This section concentrates on the \emph{runtime system}, a surprisingly
compact system. We build on modules \lstinline|Control.Concurrent| and
\lstinline|Unsafe.Coerce|, and make particular use of the monadic
combinators below~\cite{DBLP:conf/afp/Wadler95}. The
\lstinline[language=Haskell]|do| notation is built on top of these
combinators.
%
\begin{lstlisting}[language=Haskell]
(>>) :: Monad m => m a -> m b -> m b
(>>=) :: Monad m => m a -> (a -> m b) -> m b
return :: Monad m => a -> m a
\end{lstlisting}

To fork a new thread, we use the forkIO primitive. The primitive
returns a threadId, which we discard and convert into the unit value.
%
\begin{lstlisting}[language=Haskell]
fork :: IO () -> IO ()
fork e = forkIO e >> return ()
\end{lstlisting}

Each channel is implemented with a pair of \lstinline|MVar|s first
introduced in Concurrent ML~\cite{DBLP:conf/mcmaster/Reppy93} and made
available in Haskell via module
\lstinline|Concurrent.Control|~\cite{DBLP:conf/popl/JonesGF96}. Each
channel end is itself a pair of crossed \lstinline|MVar|s.
%
\begin{lstlisting}
type ChannelEnd a b = (MVar a, MVar b)
\end{lstlisting}

The \lstinline|new| function creates such a pair and returns the two
channel ends in a pair.
%
\begin{lstlisting}[language=Haskell, literate={<-}{{$\leftarrow$}}1]
new :: IO (ChannelEnd a b, ChannelEnd b a)
new = do
  m1 <- newEmptyMVar
  m2 <- newEmptyMVar
  return ((m1, m2), (m2, m1))
\end{lstlisting}
% new = newEmptyMVar >>= \m1 -> newEmptyMVar >>= \m2 -> return ((m1, m2), (m2, m1)) 

To write on a channel end, we use the second \lstinline|MVar| in the
given pair. Because the type of values transmitted on a channel vary
over time, we use \lstinline|unsafeCoerce| to bypass the Haskell type
system, a technique common in standard implementations of session
types, including that of Pucella and
Tov~\cite{DBLP:conf/haskell/PucellaT08}. To write on the channel end
we use the \lstinline|putMVar| primitive. If the \lstinline|MVar| is
currently full, \lstinline|putMVar| waits until it becomes empty.  The
result of \lstinline|send| is the original channel end, which must be
rebound in programs, as discussed in the previous section.
%
\begin{lstlisting}[language=Haskell, literate={<-}{{$\leftarrow$}}1]
send :: b -> ChannelEnd a b -> IO (ChannelEnd a b)
send x (m1, m2) = putMVar m2 (unsafeCoerce x) >> return (m1, m2)
\end{lstlisting}

Finally, to read from a channel end, we use the first element of the
pair. The \lstinline|takeMVar| primitive returns the contents of the
\lstinline|MVar|. If the \lstinline|MVar| is empty,
\lstinline|takeMVar| waits until it is full. After a
\lstinline|takeMVar|, the \lstinline|MVar| is left empty. The result
of \lstinline|receive| is a pair composed of the value read from the
\lstinline|MVar| and the original channel (which, again, should be
rebound in the program).
%
\begin{lstlisting}[language=Haskell, literate={->}{{$\rightarrow$}}1]
receive :: ChannelEnd a b -> IO (a, ChannelEnd a b)
receive (m1, m2) = takeMVar m1 >>= \x -> return (unsafeCoerce x, (m1, m2))
\end{lstlisting}

Our implementation is \emph{not} completely aligned with the
operational semantics of \emph{synchronous} session types (and that
proposed by Thiemman and Vasconcelos in particular). We use
\lstinline|MVar|s to implement \emph{asynchronous} communication with
buffers of size one. The discrepancy can be witnessed with the standard
cross write-read on two channels. In the following program
\lstinline|w1|-\lstinline|r1| and \lstinline|w2|-\lstinline|r2| are
two channels.
%
\begin{lstlisting}
writer :: !Char -> !Bool -> Skip
writer w1 w2 =
  let _ = send 'c' w1 in
  send False w2
reader :: ?Char -> ?Bool -> Bool
reader r1 r2 =
  let x, r2 = receive r2 in
  let _, r1 = receive r1 in
  x
\end{lstlisting}
%
The program does not deadlock in our current implementation but does
so in a synchronous semantics. However, deadlock occurs in a simple
adaptation of the program with two consecutive writes two consecutive
reads on each channel (using a \lstinline|writer| of type
\lstinline|!Char;!Char -> !Bool;!Bool -> Skip| and dually for
\lstinline|reader|).

% The semantics of Haskell \lstinline|MVar|s are completely aligned with
% that of the communication primitives of (synchronous) session types. O
% \lstinline|MVar|s implement a one-place buffer providing for the
% rendez-vous (the first to arrive at the read/write point waits)
% mechanism underlying session communication. Given the linear nature of
% \freest{} channels, no actual queues are required.

\freest{} is a standalone language whose types need not be in the
runtime system of Haskell, since type checking is performed by the
\freest{} front-end.
%
Coercions (that is, calls to the \lstinline|unsafeCoerce| function)
are then inserted so as to avoid typing errors when compiling the
target Haskell code. The occurrences of \lstinline|unsafeCoerce| are
limited to \emph{two} places: when reading and when writing from
\lstinline|MVar|s, in runtime functions \lstinline|receive| and
\lstinline|send|, respectively.

% Call-by-value and call-by-name.
The original proposal of context-free session types feature a
call-by-value semantics. In order to align \freest{} with this
semantics, we use Haskell's \emph{bang patterns}. For example, the
\lstinline|transform| function is compiled into
\lstinline|transform !tree !c = ...|, forcing the evaluation of both
parameters, prior to the execution of the function body, thus
effectively implementing a call-by-value strategy.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
