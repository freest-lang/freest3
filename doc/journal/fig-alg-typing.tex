\begin{figure}[t]
  The \emph{type synthesise} relation\hfill\fbox{$\algtypeout e T \Gamma$}
  \begin{gather*}
    % Variables
    \frac{
      x\colon \forallt \Empty T \in \Gamma
      \quad
      \isLin{\forallt \Empty T}
    }{
      \algtypeout x T {\Gamma\setminus x}
    }
    \quad
    \frac{
      x\colon \forallt \Empty T \in \Gamma
      \quad
      \isUn{\forallt \Empty T}
    }{
      \algtypeout x T \Gamma
    }
    \\
    % Type application
    \frac{
      x\colon\forallt{\vec y\colon\vec\kind}{T} \in \Gamma
      \quad
      \isLin{\forallt{\vec y\colon\vec\kind}{T}}
      \quad
      \algkindin{\vec U}{\vec\kind}
    }{
      \algtypeout{x[U]}{\subs{\vec U}{\vec y}T}{\Gamma\setminus x}
    }
    \\
    \frac{
      x\colon\forallt{\vec y\colon\vec\kind}{T} \in \Gamma
      \quad
      \isUn{\forallt{\vec y\colon\vec\kind}{T}}
      \quad
      \algkindin{\vec U}{\vec\kind}
    }{
      \algtypeout{x[U]}{\subs{\vec U}{\vec y}T}{\Gamma}
    }
    % \frac{
    %   \isUn T
    %   \quad
    %   \algkindout U {\kind'}
    %   \quad
    %   \isSubkind{\kind'}{\kind}
    % }{
    %   \algtypeout[\Delta;\Gamma,x\colon\forallt{y\colon\kind}{T}]{x[U]}{\subs
    %     U x T}{\Gamma,x\colon\forallt{y\colon\kind}{T}}
    %   }
    \\
    % Abstraction
    \frac{
      \algkindout{T_1} \kind
      \quad
      \algtypeout[\Delta;\Gamma_1,x\colon T_1]{e}{T_2}{\Gamma_2}
      \quad
      m=\unk \text{ implies } \Gamma_1 = \Gamma_2 \div x
    }{
      \algtypeout[\Delta;\Gamma_1]{(\abs x{T_1}e)}{(\funt{T_1}{T_2})}{\Gamma_2 \div x}
    }
    \\
    % Application
    \frac{
      \algtypeout[\Delta;\Gamma_1]{e_1}{T}{\Gamma_2}
      \quad
      T \extract{} U_1\rightarrow_m U_2
      \quad
      \algtypein[\Delta;\Gamma_2]{e_2}{U_1}{\Gamma_3}
    }{
      \algtypeout[\Delta;\Gamma_1]{e_1e_2}{U_2}{\Gamma_3}
    }
    \\
    % Let, a derived constructor
    % \frac{
    %   \algtypeout[\Delta;\Gamma_1]{e_1}{T_1}{\Gamma_2}
    %   \quad
    %   \algtypeout[\Delta;\Gamma_2,x\colon T_1]{e_2}{T_2}{\Gamma_3}
    % }{
    %   \algtypeout[\Delta;\Gamma_1]{\unlete{x}{e_1}{e_2}}{T_2}{\Gamma_3 \div x}
    % }
    % \\
    % Conditional
    \frac{
      \algtypein[\Delta;\Gamma_1]{e_1}{\boolt}{\Gamma_2}
      \quad
      \algtypeout[\Delta;\Gamma_2]{e_2}{T}{\Gamma_3}
      \quad
      \algtypein[\Delta;\Gamma_2]{e_3}{T}{\Gamma_4}
      \quad
      \ctxequiv{\Gamma_3}{\Gamma_4}
    }{
      \algtypeout[\Delta;\Gamma_1]{\conde{e_1}{e_2}{e_3}}{T}{\Gamma_3}
    }
    \\
    % Pair constructor
    \frac{
      \algtypeout[\Delta ; \Gamma_1]{e_1}{T_1}{\Gamma_2}
      \quad
      \algtypeout[\Delta ; \Gamma_2]{e_2}{T_2}{\Gamma_3}
      \quad
      \isType{T_1,T_2}{m}
    }{
      \algtypeout[\Delta ; \Gamma_1]{m(e_1, e_2)}{(T_1,T_2)}{\Gamma_3}
    }
    \\
    % Pair destructor
    \frac{
      \algtypeout[\Delta ; \Gamma_1]{e_1}{T_1}{\Gamma_2}
      \quad
      T_1 \extract{} q(U_1, U_2)
      \quad
      \algtypeout[\Delta; \Gamma_2, x\colon U_1, y\colon U_2]{e_2}{T_2}{\Gamma_3}
    }{
      \algtypeout[\Delta;
      \Gamma_1]{\binlete{x}{y}{e_1}{e_2}}{T_2}{\Gamma_3} \div x \div y
    }
    \\
    % Channel creation
    \frac{
      \Delta \Alg T \leftarrow \kinds^{\lin}
    }{
      \Delta;\Gamma \Alg \newe{T} \rightarrow (T, \dual{T}); \Gamma
    }
    \quad
    % Send
    \frac{
      \algtypeout[\Delta;\Gamma_1]{e}{T}{\Gamma_2}
      \quad
      T\extract{} !U_1;U_2
    }{
      \algtypeout[\Delta;\Gamma_1]{\sendce e}{(U_1\multimap U_2)}{\Gamma_2}
    }
    \\
    % Receive
    \frac{
      \algtypeout[\Delta;\Gamma_1]{e_1}{T}{\Gamma_2}
      \quad T
      \extract{} ?U_1;U_2
    }{
      \algtypeout[\Delta;\Gamma_1]{\recve e}{(U_1,U_2)}{\Gamma_2}
    }
    \quad
    % Select
    \frac{
      \algtypeout[\Delta;\Gamma_1]{e}{T}{\Gamma_2}
      \quad
      T \extract{}\oplus\{C_i\colon U_i\}_{i\in I}
      \quad
      j \in I
    }{
      \algtypeout[\Delta;\Gamma_1]{\selecte{C_j}{e}}{U_j}{\Gamma_2}
    }
    \\
    % Match 
    \frac{
      \begin{array}{c}
      \algtypeout[\Delta;\Gamma_1]{e}{T}{\Gamma_2}
      \quad
      T \extract{} \&\{C_i\colon T_i\}
    \quad
      \algtypeout[\Delta;\Gamma_2, x_i\colon T_i]{e_i}{U_i}{\Sigma_i}
      \\
      \typeequiv{U_1}{U_i}
      \quad
      \ctxequiv{\Sigma_1 \div (x_1\colon T_1)}{\Sigma_i \div (x_i\colon T_i)} 
      \end{array}
    }{
      \algtypeout[\Delta;\Gamma_1]{\matche{e}{\{C_i\,x_i
          \rightarrow e_i\}}}{U_1}{\Sigma_1 \div (x_1\colon T_1)}
    }
  \\
  \frac{
    \begin{array}{c}
    \algtypeout[\Delta;\Gamma_1]{e}{T}{\Gamma_2}
    \quad
    T \extract{}[C_i\colon T_i]
    \quad
    (T_i;\vec x_i) \extract{}{\vec V_i}
    \quad
    \algtypeout[\Delta;\Gamma_2, \vec x_i\colon\vec V_i]{e_i}{U_i}{\Sigma_i}
    \\
    \typeequiv{U_1}{U_i}    
    \quad
    \ctxequiv{\Sigma_1 \div (\vec x_1\colon\vec V_1)}{\Sigma_i \div (\vec x_i\colon\vec V_i)} 
    \end{array}
  }{
    \algtypeout[\Delta;\Gamma_1]{\casee{e}{\{C_i\,\vec x_i\rightarrow e_i\}}}{U}{\Sigma_1 \div (\vec x_1\colon\vec V_1)}
  }
  % \\ % Fork -- Fork is now a program variable in context
  % \frac{
  %   \algtypeout[\Delta;\Gamma_1]{e}{T}{\Gamma_2}
  %   \quad
  %   \isUn T
  % }{
  %   \algtypeout[\Delta;\Gamma_1]{\forke{e}}{\unite}{\Gamma_2}
  % }
  \end{gather*}
\end{figure}

\begin{figure}[t]
  The \emph{type check against} relation\hfill\fbox{$\algtypein e T \Gamma$}
  \begin{gather*}
    % Let, a derived constructor (this rule is wrong)
    % \frac{
    %   \algtypeout[\Delta;\Gamma_1]{e_1}{T_1}{\Gamma_2}
    %   \quad
    %   \algtypein[\Delta;\Gamma_2,x\colon T_1]{e_2}{T_2}{\Gamma_3}
    % }{
    %   \algtypein[\Delta;\Gamma_1]{\unlete{x}{e_1}{e_2}}{T_2}{\Gamma_3}
    % }
    % \\
    % Pair destructor
    \frac{
      \algtypeout[\Delta ; \Gamma_1]{e_1}{T_1}{\Gamma_2}
      \quad
      T_1 \extract{} q(U_1, U_2)
      \quad
      \algtypein[\Delta; \Gamma_2, x\colon U_1, y\colon U_2]{e_2}{T_2}{\Gamma_3}
    }{
      \algtypein[\Delta;
      \Gamma_1]{\binlete{x}{y}{e_1}{e_2}}{T_2}{\Gamma_3} \div x \div y
    }
    \\
    % Conditional
    \frac{
      \algtypein[\Delta;\Gamma_1]{e_1}{\boolt}{\Gamma_2}
      \quad
      \algtypein[\Delta;\Gamma_2]{e_2}{T}{\Gamma_3}
      \quad
      \algtypein[\Delta;\Gamma_2]{e_3}{T}{\Gamma_4}
      \quad
      \ctxequiv{\Gamma_3}{\Gamma_4}
    }{
      \algtypein[\Delta;\Gamma_1]{\conde{e_1}{e_2}{e_3}}{T}{\Gamma_3}
    }
    \\
    % Match 
    \frac{
      \begin{array}{c}
        \algtypeout[\Delta;\Gamma_1]{e}{T}{\Gamma_2}
        \quad
        T \extract{} \&\{C_i\colon T_i\}
        \\
        \algtypein[\Delta;\Gamma_2, x_i\colon T_i]{e_i}{U}{\Sigma_i}
        \quad
        \ctxequiv{\Sigma_1 \div (x_1\colon T_1)}{\Sigma_i \div (x_i\colon T_i)} 
      \end{array}
    }{
      \algtypein[\Delta;\Gamma_1]{\matche{e}{\{C_i\,x_i
          \rightarrow e_i\}}}{U_1}{\Sigma_1 \div (x_1\colon T_1)}
    }
    \\
    % Case
    \frac{
      \begin{array}{c}
        \algtypeout[\Delta;\Gamma_1]{e}{T}{\Gamma_2}
        \quad
        T \extract{}[C_i\colon T_i]
        \quad
        (T_i;\vec x_i) \extract{}{\vec V_i}
        \\
        \algtypein[\Delta;\Gamma_2, \vec x_i\colon\vec V_i]{e_i}{U}{\Sigma_i}
        \quad
        \ctxequiv{\Sigma_1 \div (\vec x_1\colon\vec V_1)}{\Sigma_i \div (\vec x_i\colon\vec V_i)} 
      \end{array}
    }{
      \algtypein[\Delta;\Gamma_1]{\casee{e}{\{C_i\,\vec x_i\rightarrow e_i\}}}{U}{\Sigma_1 \div (\vec x_1\colon\vec V_1)}
    }
    \\
    % Application _ It seems that we cannot do checkAgainst for we
    % cannot decide whether to use a Lin or a Un function. See
    % counterexamples: polySUTL.fst when using Lin, and mult.fst when
    % using Un
    % \frac{
    %   \algtypeout[\Delta;\Gamma_1]{e_2}{T}{\Gamma_2}
    %   \quad
    %   \algtypein[\Delta;\Gamma_2]{e_1}{T\multimap U}{\Gamma_3}
    % }{
    %   \algtypein[\Delta;\Gamma_1]{e_1e_2}{U}{\Gamma_3}
    % }
    % \quad
    % Equivalence
    \frac{
      \algtypeout e U \Gamma
      \quad
      \typeequiv T U
    }{
      \algtypein e T \Gamma
    }
  \end{gather*}
  \caption{Algorithmic type checking}
  \label{fig:alg-typing}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
